[{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"peppwR","title":"peppwR","text":"Power analysis phosphopeptide abundance hypothesis tests via simulation. Repository: https://github.com/TeamMacLean/peppwR Documentation: https://teammaclean.github.io/peppwR/ Version: 0.1.0 (CRAN-ready)","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"related-package","dir":"","previous_headings":"","what":"Related Package","title":"peppwR","text":"pepdiff - Companion package differential abundance analysis phosphopeptide data. peppwR handles experimental design (power analysis), pepdiff handles actual analysis data collected.","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"purpose","dir":"","previous_headings":"","what":"Purpose","title":"peppwR","text":"Help proteomics researchers answer experimental design questions: “sample size need?” → find = \"sample_size\" “’s power?” → find = \"power\" “’s minimum detectable effect?” → find = \"effect_size\"","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"core-workflow","dir":"","previous_headings":"","what":"Core Workflow","title":"peppwR","text":"","code":"pilot_data → fit_distributions() → power_analysis() → results + plots"},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"aggregate-mode-no-pilot-data","dir":"","previous_headings":"Core Workflow","what":"Aggregate Mode (No Pilot Data)","title":"peppwR","text":"","code":"result <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.1),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\" )"},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"per-peptide-mode-with-pilot-data","dir":"","previous_headings":"Core Workflow","what":"Per-Peptide Mode (With Pilot Data)","title":"peppwR","text":"","code":"fits <- fit_distributions(pilot_data, id = \"peptide\", group = \"condition\", value = \"abundance\") result <- power_analysis(fits, effect_size = 2, target_power = 0.8, find = \"sample_size\") # Output: \"73% of peptides achieve 80% power with N=6 per group\""},{"path":[]},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"peppwr_fits","dir":"","previous_headings":"S3 Classes","what":"peppwr_fits","title":"peppwR","text":"Distribution fitting results print(), plot(), summary() methods.","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"peppwr_power","dir":"","previous_headings":"S3 Classes","what":"peppwr_power","title":"peppwR","text":"Power analysis results print(), plot(), summary() methods.","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"file-structure","dir":"","previous_headings":"","what":"File Structure","title":"peppwR","text":"","code":"R/ ├── classes.R       # S3 class constructors and validators ├── fits.R          # fit_distributions(), missingness computation, MNAR detection ├── plots.R         # All plot methods and diagnostic plots ├── power.R         # power_analysis() and methods ├── simulation.R    # Simulation engine, run_power_sim*() ├── tests.R         # Statistical test wrappers └── utils.R         # Distribution utilities, helpers  vignettes/ ├── getting-started.Rmd        # CRAN vignette (quick) ├── find-fits.Rmd              # CRAN vignette (quick) └── articles/                  # pkgdown articles (not in CRAN package)     ├── benchmarking.Rmd     ├── power-analysis-workflow.Rmd     ├── dda-time-course-power.Rmd     └── prm-genotype-power.Rmd  sample_data/                   # Example datasets (in .Rbuildignore) ├── dda_data.csv               # Anonymized DDA phosphoproteomics └── prm_data.csv               # Anonymized PRM phosphoproteomics"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"github-actions","dir":"","previous_headings":"Distribution & CI","what":"GitHub Actions","title":"peppwR","text":"R-CMD-check.yaml - Multi-platform R CMD check (Ubuntu, macOS, Windows) pkgdown.yaml - Builds deploys documentation gh-pages","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"cran-preparation","dir":"","previous_headings":"Distribution & CI","what":"CRAN Preparation","title":"peppwR","text":"Version 0.1.0, passes R CMD check ---cran 0 errors, 0 warnings Heavy vignettes moved pkgdown articles reduce check time Package size optimized (<5MB)","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"pkgdown-site","dir":"","previous_headings":"Distribution & CI","what":"pkgdown Site","title":"peppwR","text":"Hosted https://teammaclean.github.io/peppwR/ Includes articles, function reference, hex logo","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"development-style","dir":"","previous_headings":"","what":"Development Style","title":"peppwR","text":"Tidyverse style - Pipes, dplyr verbs Explicit namespacing - dplyr::filter(), ggplot2::ggplot() S3 OOP - Classes print/plot/summary methods TDD - testthat 299 tests","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"development-workflow-for-future-changes","dir":"","previous_headings":"","what":"Development Workflow for Future Changes","title":"peppwR","text":"See semi-autonomous-feature-development.md detailed workflow.","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"discuss--tdd--ralph-loop","dir":"","previous_headings":"Development Workflow for Future Changes","what":"Discuss → TDD → Ralph Loop","title":"peppwR","text":"Discuss - Human describes feature/bug, Claude asks clarifying questions, agree scope TDD - Write failing test first (test spec) Ralph Loop - Claude iterates autonomously tests pass","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"key-principles","dir":"","previous_headings":"Development Workflow for Future Changes","what":"Key Principles","title":"peppwR","text":"Tests contract - ambiguity completion implementation test fails - Red → Green → Refactor Clear context implementation - Commit test, start fresh session Self-contained prompts - Reference files, discussion history","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"for-bug-fixes--features","dir":"","previous_headings":"Development Workflow for Future Changes","what":"For Bug Fixes / Features","title":"peppwR","text":"","code":"1. Discuss requirements 2. Write failing test in tests/testthat/ 3. Commit the test 4. /clear or new session 5. /ralph-loop with verification command: devtools::test(filter = \"test-name\") 6. Human smoke test"},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"peppwR","text":"Imports: - fitdistrplus, univariateML - Distribution fitting - dplyr, tidyr, purrr, tibble - Data manipulation - ggplot2, cowplot, RColorBrewer, scales - Visualization Suggests: - testthat, knitr, rmarkdown, pkgdown, bench","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"fit-failures","dir":"","previous_headings":"Design Decisions","what":"Fit Failures","title":"peppwR","text":"Configurable via on_fit_failure: - \"exclude\" (default) - Skip peptides, report count - \"empirical\" - Bootstrap resample observed values - \"lognormal\" - Fallback moment-matched parameters","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"fdr-aware-mode","dir":"","previous_headings":"Design Decisions","what":"FDR-Aware Mode","title":"peppwR","text":"Use apply_fdr = TRUE per-peptide mode whole-peptidome simulation Benjamini-Hochberg correction. Configure prop_null (default 0.9).","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"performance","dir":"","previous_headings":"Design Decisions","what":"Performance","title":"peppwR","text":"Single-threaded R vectorization. Benchmarks show acceptable performance typical datasets (1000s peptides).","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"project-status","dir":"","previous_headings":"","what":"Project Status","title":"peppwR","text":"COMPLETE - planned features implemented: Core power analysis (aggregate per-peptide modes) three questions: power, sample_size, effect_size Distribution fitting multiple candidates Statistical tests: wilcoxon, bootstrap_t, bayes_t Diagnostic plots: density overlay, QQ, heatmap, param distribution Missingness handling dataset-level MNAR detection FDR-aware power analysis Empirical bootstrap fallback Real-world examples (DDA PRM) Comprehensive documentation pkgdown site Hex sticker logo (chilli pepper power curve)","code":""},{"path":"https://teammaclean.github.io/peppwR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 peppwR authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarking peppwR","text":"Proteomics datasets often contain thousands tens thousands peptides. vignette characterizes peppwR’s performance characteristics help : Estimate runtime dataset size Choose appropriate n_sim values Understand memory requirements Make informed trade-offs precision compute time","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"test-data-generator","dir":"Articles","previous_headings":"Experimental Setup","what":"Test Data Generator","title":"Benchmarking peppwR","text":"","code":"generate_test_data <- function(n_peptides, n_per_group = 4, seed = 42) {   set.seed(seed)    peptide_params <- tibble::tibble(     peptide_id = paste0(\"pep_\", sprintf(\"%05d\", 1:n_peptides)),     shape = runif(n_peptides, 1.5, 5),     rate = runif(n_peptides, 0.01, 0.1)   )    peptide_params |>     dplyr::rowwise() |>     dplyr::mutate(       data = list(tibble::tibble(         condition = rep(c(\"control\", \"treatment\"), each = n_per_group),         replicate = rep(1:n_per_group, 2),         abundance = rgamma(n_per_group * 2, shape = shape, rate = rate)       ))     ) |>     dplyr::ungroup() |>     dplyr::select(peptide_id, data) |>     tidyr::unnest(data) }"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"test-configurations","dir":"Articles","previous_headings":"Experimental Setup","what":"Test Configurations","title":"Benchmarking peppwR","text":"Note: practical vignette build times, use smaller dataset sizes full specification (includes 5000, 10000, 20000 peptides). Scale estimates linearly larger datasets.","code":"# Peptide counts for scaling tests peptide_counts <- c(100, 500, 1000, 2000)  # Simulation counts for power analysis sim_counts <- c(500, 1000, 2000)"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"generate-test-datasets","dir":"Articles","previous_headings":"Distribution Fitting Scaling","what":"Generate Test Datasets","title":"Benchmarking peppwR","text":"","code":"fit_data <- lapply(peptide_counts, function(n) {   generate_test_data(n, n_per_group = 4) }) names(fit_data) <- paste0(\"n\", peptide_counts)"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"benchmark-fitting","dir":"Articles","previous_headings":"Distribution Fitting Scaling","what":"Benchmark Fitting","title":"Benchmarking peppwR","text":"benchmarks use distributions = \"continuous\" fits distributions appropriate continuous abundance data (gamma, lognormal, normal, etc.). Distribution fitting scaling","code":"fit_results <- bench::mark(   `100 peptides` = fit_distributions(fit_data$n100, \"peptide_id\", \"condition\", \"abundance\",                                       distributions = \"continuous\"),   `500 peptides` = fit_distributions(fit_data$n500, \"peptide_id\", \"condition\", \"abundance\",                                       distributions = \"continuous\"),   `1000 peptides` = fit_distributions(fit_data$n1000, \"peptide_id\", \"condition\", \"abundance\",                                        distributions = \"continuous\"),   `2000 peptides` = fit_distributions(fit_data$n2000, \"peptide_id\", \"condition\", \"abundance\",                                        distributions = \"continuous\"),   iterations = 1,   check = FALSE,   memory = TRUE ) #> Loading required namespace: intervals  fit_results_df <- tibble::tibble(   peptides = peptide_counts,   time_s = as.numeric(fit_results$median),   memory_mb = as.numeric(fit_results$mem_alloc) / 1024^2 )  fit_results_df$time_per_peptide_ms <- fit_results_df$time_s * 1000 / fit_results_df$peptides  knitr::kable(   fit_results_df,   col.names = c(\"Peptides\", \"Time (s)\", \"Memory (MB)\", \"Time/peptide (ms)\"),   digits = 2,   caption = \"Distribution fitting scaling\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"fitting-scaling-plot","dir":"Articles","previous_headings":"Distribution Fitting Scaling","what":"Fitting Scaling Plot","title":"Benchmarking peppwR","text":"Distribution fitting scales approximately linearly number peptides, peptide fitted independently.","code":"ggplot2::ggplot(fit_results_df, ggplot2::aes(x = peptides, y = time_s)) +   ggplot2::geom_point(size = 3, color = \"steelblue\") +   ggplot2::geom_line(color = \"steelblue\") +   ggplot2::scale_x_log10() +   ggplot2::scale_y_log10() +   ggplot2::theme_minimal() +   ggplot2::labs(     x = \"Number of Peptides (log scale)\",     y = \"Time (seconds, log scale)\",     title = \"Distribution Fitting: Time vs Dataset Size\"   )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"power-analysis---aggregate-mode","dir":"Articles","previous_headings":"","what":"Power Analysis - Aggregate Mode","title":"Benchmarking peppwR","text":"Aggregate mode performance depends primarily n_sim, dataset size (since simulates single “typical” peptide).","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"effect-of-n_sim","dir":"Articles","previous_headings":"Power Analysis - Aggregate Mode","what":"Effect of n_sim","title":"Benchmarking peppwR","text":"Aggregate mode timing n_sim","code":"set.seed(123)  agg_results <- bench::mark(   `n_sim=500` = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                                effect_size = 2, n_per_group = 6,                                find = \"power\", n_sim = 500),   `n_sim=1000` = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                                 effect_size = 2, n_per_group = 6,                                 find = \"power\", n_sim = 1000),   `n_sim=2000` = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                                 effect_size = 2, n_per_group = 6,                                 find = \"power\", n_sim = 2000),   iterations = 3,   check = FALSE )  agg_df <- tibble::tibble(   n_sim = sim_counts,   time_s = as.numeric(agg_results$median) )  knitr::kable(   agg_df,   col.names = c(\"n_sim\", \"Time (s)\"),   digits = 3,   caption = \"Aggregate mode timing by n_sim\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"power-estimate-stabilization","dir":"Articles","previous_headings":"Power Analysis - Aggregate Mode","what":"Power Estimate Stabilization","title":"Benchmarking peppwR","text":"simulations yield stable power estimates. Let’s examine convergence: Power estimate stability n_sim  Key insight: n_sim = 1000 provides good balance precision (CI width ~0.03) speed. publication-quality results, use n_sim = 2000+.","code":"set.seed(42)  # Run multiple times at each n_sim level stabilization_data <- do.call(rbind, lapply(c(100, 250, 500, 1000, 2000), function(n) {   powers <- replicate(10, {     result <- power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                             effect_size = 2, n_per_group = 6,                             find = \"power\", n_sim = n)     result$answer   })    tibble::tibble(     n_sim = n,     mean_power = mean(powers),     sd_power = sd(powers),     ci_width = 1.96 * sd(powers) * 2   ) }))  knitr::kable(   stabilization_data,   col.names = c(\"n_sim\", \"Mean Power\", \"SD\", \"95% CI Width\"),   digits = 3,   caption = \"Power estimate stability by n_sim\" ) ggplot2::ggplot(stabilization_data, ggplot2::aes(x = n_sim)) +   ggplot2::geom_ribbon(     ggplot2::aes(ymin = mean_power - 1.96 * sd_power,                  ymax = mean_power + 1.96 * sd_power),     fill = \"steelblue\", alpha = 0.3   ) +   ggplot2::geom_line(ggplot2::aes(y = mean_power), color = \"steelblue\", linewidth = 1) +   ggplot2::geom_point(ggplot2::aes(y = mean_power), color = \"steelblue\", size = 2) +   ggplot2::scale_x_log10() +   ggplot2::theme_minimal() +   ggplot2::labs(     x = \"Number of Simulations (log scale)\",     y = \"Power Estimate\",     title = \"Power Estimate Convergence\",     subtitle = \"Shaded region shows 95% confidence interval across 10 runs\"   )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"power-analysis---per-peptide-mode","dir":"Articles","previous_headings":"","what":"Power Analysis - Per-Peptide Mode","title":"Benchmarking peppwR","text":"Per-peptide mode scales number peptides n_sim.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"prepare-fits-for-benchmarking","dir":"Articles","previous_headings":"Power Analysis - Per-Peptide Mode","what":"Prepare Fits for Benchmarking","title":"Benchmarking peppwR","text":"","code":"fits_100 <- fit_distributions(fit_data$n100, \"peptide_id\", \"condition\", \"abundance\",                                distributions = \"continuous\") fits_500 <- fit_distributions(fit_data$n500, \"peptide_id\", \"condition\", \"abundance\",                                distributions = \"continuous\") fits_1000 <- fit_distributions(fit_data$n1000, \"peptide_id\", \"condition\", \"abundance\",                                 distributions = \"continuous\")"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"scaling-by-peptide-count","dir":"Articles","previous_headings":"Power Analysis - Per-Peptide Mode","what":"Scaling by Peptide Count","title":"Benchmarking peppwR","text":"Per-peptide mode scaling peptide count (n_sim=500)","code":"set.seed(123)  pp_peptide_results <- bench::mark(   `100 peptides` = power_analysis(fits_100, effect_size = 2, n_per_group = 6,                                   find = \"power\", n_sim = 500),   `500 peptides` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                   find = \"power\", n_sim = 500),   `1000 peptides` = power_analysis(fits_1000, effect_size = 2, n_per_group = 6,                                    find = \"power\", n_sim = 500),   iterations = 1,   check = FALSE )  pp_pep_df <- tibble::tibble(   peptides = c(100, 500, 1000),   time_s = as.numeric(pp_peptide_results$median),   time_per_peptide_ms = time_s * 1000 / peptides )  knitr::kable(   pp_pep_df,   col.names = c(\"Peptides\", \"Time (s)\", \"Time/peptide (ms)\"),   digits = 2,   caption = \"Per-peptide mode scaling by peptide count (n_sim=500)\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"scaling-by-n_sim","dir":"Articles","previous_headings":"Power Analysis - Per-Peptide Mode","what":"Scaling by n_sim","title":"Benchmarking peppwR","text":"Per-peptide mode scaling n_sim (500 peptides)","code":"set.seed(123)  pp_nsim_results <- bench::mark(   `n_sim=250` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                find = \"power\", n_sim = 250),   `n_sim=500` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                find = \"power\", n_sim = 500),   `n_sim=1000` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                 find = \"power\", n_sim = 1000),   iterations = 1,   check = FALSE )  pp_nsim_df <- tibble::tibble(   n_sim = c(250, 500, 1000),   time_s = as.numeric(pp_nsim_results$median) )  knitr::kable(   pp_nsim_df,   col.names = c(\"n_sim\", \"Time (s)\"),   digits = 2,   caption = \"Per-peptide mode scaling by n_sim (500 peptides)\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"scaling-visualization","dir":"Articles","previous_headings":"Power Analysis - Per-Peptide Mode","what":"Scaling Visualization","title":"Benchmarking peppwR","text":"","code":"ggplot2::ggplot(pp_pep_df, ggplot2::aes(x = peptides, y = time_s)) +   ggplot2::geom_point(size = 3, color = \"steelblue\") +   ggplot2::geom_line(color = \"steelblue\") +   ggplot2::scale_x_log10() +   ggplot2::scale_y_log10() +   ggplot2::theme_minimal() +   ggplot2::labs(     x = \"Number of Peptides (log scale)\",     y = \"Time (seconds, log scale)\",     title = \"Per-Peptide Power Analysis: Scaling with Dataset Size\"   )"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"time-estimation-formula","dir":"Articles","previous_headings":"Recommendations","what":"Time Estimation Formula","title":"Benchmarking peppwR","text":"per-peptide mode: : - time_per_sim ≈ 0.002-0.005 seconds (depends test type) - fitting_time ≈ 0.02 seconds per peptide","code":"Estimated time (s) ≈ (n_peptides × n_sim × time_per_sim) + fitting_time"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"memory-considerations","dir":"Articles","previous_headings":"Recommendations","what":"Memory Considerations","title":"Benchmarking peppwR","text":"Fitting: ~0.1-0.2 MB per 100 peptides Power analysis: Minimal additional memory (results stored per peptide) large datasets (>10000 peptides), ensure least 4GB available RAM","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"statistical-test-speed-comparison","dir":"Articles","previous_headings":"Recommendations","what":"Statistical Test Speed Comparison","title":"Benchmarking peppwR","text":"Statistical test speed comparison (n_sim=500) Note: bootstrap_t rankprod tests slower due resampling procedures. large-scale analyses, wilcoxon bayes_t faster options.","code":"set.seed(123)  test_timing <- bench::mark(   wilcoxon = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                             effect_size = 2, n_per_group = 6,                             find = \"power\", test = \"wilcoxon\", n_sim = 500),   bootstrap_t = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                                effect_size = 2, n_per_group = 6,                                find = \"power\", test = \"bootstrap_t\", n_sim = 500),   bayes_t = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                            effect_size = 2, n_per_group = 6,                            find = \"power\", test = \"bayes_t\", n_sim = 500),   rankprod = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                             effect_size = 2, n_per_group = 6,                             find = \"power\", test = \"rankprod\", n_sim = 500),   iterations = 2,   check = FALSE )  test_df <- tibble::tibble(   test = c(\"wilcoxon\", \"bootstrap_t\", \"bayes_t\", \"rankprod\"),   time_s = as.numeric(test_timing$median),   relative = time_s / min(time_s) )  knitr::kable(   test_df,   col.names = c(\"Test\", \"Time (s)\", \"Relative Speed\"),   digits = 2,   caption = \"Statistical test speed comparison (n_sim=500)\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"missingness-aware-simulation-performance","dir":"Articles","previous_headings":"","what":"Missingness-Aware Simulation Performance","title":"Benchmarking peppwR","text":"include_missingness = TRUE, peppwR incorporates peptide-specific NA rates simulations. Let’s measure overhead: Missingness-aware simulation overhead overhead include_missingness = TRUE minimal - ’s primarily NA handling within simulation loop, fast.","code":"# Generate data with realistic missingness generate_test_data_with_na <- function(n_peptides, n_per_group = 4, na_rate = 0.15, seed = 42) {   set.seed(seed)    data <- generate_test_data(n_peptides, n_per_group, seed)    # Introduce MNAR pattern: low values more likely to be missing   threshold <- quantile(data$abundance, 0.3)   data$abundance <- ifelse(     data$abundance < threshold & runif(nrow(data)) < na_rate * 2,     NA,     data$abundance   )    # Also some random MCAR missingness   data$abundance <- ifelse(     runif(nrow(data)) < na_rate / 3,     NA,     data$abundance   )    data }  data_with_na <- generate_test_data_with_na(500, n_per_group = 4, na_rate = 0.15) fits_with_na <- fit_distributions(data_with_na, \"peptide_id\", \"condition\", \"abundance\",                                    distributions = \"continuous\") set.seed(123)  miss_results <- bench::mark(   `Without missingness` = power_analysis(fits_with_na, effect_size = 2, n_per_group = 6,                                          find = \"power\", n_sim = 200,                                          include_missingness = FALSE),   `With missingness` = power_analysis(fits_with_na, effect_size = 2, n_per_group = 6,                                       find = \"power\", n_sim = 200,                                       include_missingness = TRUE),   iterations = 2,   check = FALSE )  miss_df <- tibble::tibble(   mode = c(\"Without missingness\", \"With missingness\"),   time_s = as.numeric(miss_results$median) )  knitr::kable(   miss_df,   col.names = c(\"Mode\", \"Time (s)\"),   digits = 2,   caption = \"Missingness-aware simulation overhead\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"fdr-mode-performance","dir":"Articles","previous_headings":"","what":"FDR Mode Performance","title":"Benchmarking peppwR","text":"FDR-aware mode simulates entire peptidome experiments mixed null alternative peptides, applies BH correction. computationally intensive per-peptide mode. FDR mode vs per-peptide mode timing FDR mode expensive simulation iteration requires: 1. Assigning peptides null/alternative 2. Simulating peptides together 3. Applying BH correction across p-values","code":"set.seed(123)  fdr_results <- bench::mark(   `Per-peptide (no FDR)` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                           find = \"power\", n_sim = 100),   `FDR-adjusted` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                   find = \"power\", apply_fdr = TRUE,                                   prop_null = 0.9, n_sim = 100),   iterations = 2,   check = FALSE )  fdr_df <- tibble::tibble(   mode = c(\"Per-peptide (no FDR)\", \"FDR-adjusted\"),   time_s = as.numeric(fdr_results$median) )  knitr::kable(   fdr_df,   col.names = c(\"Mode\", \"Time (s)\"),   digits = 2,   caption = \"FDR mode vs per-peptide mode timing\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"fdr-scaling-with-peptide-count","dir":"Articles","previous_headings":"FDR Mode Performance","what":"FDR Scaling with Peptide Count","title":"Benchmarking peppwR","text":"FDR mode scaling peptide count (n_sim=50)","code":"set.seed(123)  fdr_scaling_results <- bench::mark(   `100 peptides` = power_analysis(fits_100, effect_size = 2, n_per_group = 6,                                   find = \"power\", apply_fdr = TRUE, n_sim = 50),   `500 peptides` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                   find = \"power\", apply_fdr = TRUE, n_sim = 50),   `1000 peptides` = power_analysis(fits_1000, effect_size = 2, n_per_group = 6,                                    find = \"power\", apply_fdr = TRUE, n_sim = 50),   iterations = 1,   check = FALSE )  fdr_scale_df <- tibble::tibble(   peptides = c(100, 500, 1000),   time_s = as.numeric(fdr_scaling_results$median) )  knitr::kable(   fdr_scale_df,   col.names = c(\"Peptides\", \"Time (s)\"),   digits = 2,   caption = \"FDR mode scaling by peptide count (n_sim=50)\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"diagnostic-plot-generation-times","dir":"Articles","previous_headings":"","what":"Diagnostic Plot Generation Times","title":"Benchmarking peppwR","text":"Diagnostic plot generation times Power heatmap generation time Note: power heatmap expensive runs n_steps^2 × n_sim simulations. Use smaller grids fewer simulations exploratory work.","code":"set.seed(42)  plot_results <- bench::mark(   `Density overlay` = plot_density_overlay(fits_500, n_overlay = 6),   `QQ plots` = plot_qq(fits_500, n_plots = 6),   `Param distribution` = plot_param_distribution(fits_500),   iterations = 2,   check = FALSE )  plot_df <- tibble::tibble(   plot = c(\"Density overlay\", \"QQ plots\", \"Param distribution\"),   time_s = as.numeric(plot_results$median) )  knitr::kable(   plot_df,   col.names = c(\"Plot Type\", \"Time (s)\"),   digits = 3,   caption = \"Diagnostic plot generation times\" ) set.seed(123)  heatmap_results <- bench::mark(   `Power heatmap (5x5)` = plot_power_heatmap(     \"gamma\", list(shape = 2, rate = 0.05),     n_range = c(3, 12), effect_range = c(1.5, 3),     n_steps = 5, n_sim = 50   ),   iterations = 1,   check = FALSE )  knitr::kable(   tibble::tibble(     plot = \"Power heatmap (5x5 grid, n_sim=50)\",     time_s = as.numeric(heatmap_results$median)   ),   col.names = c(\"Plot Type\", \"Time (s)\"),   digits = 2,   caption = \"Power heatmap generation time\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Benchmarking peppwR","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices datasets  utils     methods   base      #>  #> other attached packages: #> [1] bench_1.1.4  peppwR_0.1.0 #>  #> loaded via a namespace (and not attached): #>  [1] sass_0.4.10         generics_0.1.4      tidyr_1.3.2         #>  [4] renv_0.12.2         fGarch_4052.93      lattice_0.22-7      #>  [7] digest_0.6.39       magrittr_2.0.4      RColorBrewer_1.1-3  #> [10] evaluate_1.0.5      grid_4.5.2          fastmap_1.2.0       #> [13] jsonlite_2.0.0      Matrix_1.7-4        purrr_1.2.1         #> [16] scales_1.4.0        gbutils_0.5.1       codetools_0.2-20    #> [19] textshaping_1.0.4   jquerylib_0.1.4     Rdpack_2.6.6        #> [22] cli_3.6.5           timeSeries_4052.112 rlang_1.1.7         #> [25] rbibutils_2.4.1     intervals_0.15.5    withr_3.0.2         #> [28] cachem_1.1.0        yaml_2.3.12         cvar_0.6            #> [31] tools_4.5.2         dplyr_1.2.0         ggplot2_4.0.2       #> [34] profmem_0.7.0       assertthat_0.2.1    vctrs_0.7.1         #> [37] R6_2.6.1            lifecycle_1.0.5     fs_1.6.6            #> [40] univariateML_1.5.0  ragg_1.5.0          pkgconfig_2.0.3     #> [43] desc_1.4.3          gtable_0.3.6        pkgdown_2.2.0       #> [46] pillar_1.11.1       bslib_0.10.0        glue_1.8.0          #> [49] systemfonts_1.3.1   xfun_0.56           tibble_3.3.1        #> [52] tidyselect_1.2.1    knitr_1.51          farver_2.1.2        #> [55] spatial_7.3-18      htmltools_0.5.9     fBasics_4052.98     #> [58] labeling_0.4.3      rmarkdown_2.30      timeDate_4052.112   #> [61] compiler_4.5.2      S7_0.2.1"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"what-is-statistical-power","dir":"Articles","previous_headings":"Introduction","what":"What is Statistical Power?","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Statistical power probability detecting true effect one exists. proteomics experiments, translates : “phosphopeptide truly changes conditions, likely find statistically significant?” Power depends four interconnected factors: Effect size - large biological change? (e.g., 2-fold) Sample size - many biological replicates per group? Variability - noisy measurement? Significance threshold - alpha level using? (typically 0.05)","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"why-does-power-matter","dir":"Articles","previous_headings":"Introduction","what":"Why Does Power Matter?","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Phosphoproteomics experiments expensive time-consuming. -powered experiments waste resources failing detect real biological changes. -powered experiments waste resources using samples necessary. Power analysis helps researchers: experiment: Determine required sample size adequate power pilot: Assess effects can detected current data grant planning: Justify sample size requirements reviewers","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"the-peppwr-approach","dir":"Articles","previous_headings":"Introduction","what":"The peppwR Approach","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"peppwR uses simulation-based power analysis: Fit distributions pilot data capture realistic abundance patterns Simulate experiments drawing fitted distributions Apply statistical tests simulated data Estimate power proportion simulations significant results approach captures full complexity phosphoproteomics data, including heterogeneity across peptides.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"about-the-data","dir":"Articles","previous_headings":"","what":"About the Data","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"analysis uses Arabidopsis phosphoproteomics data time-course experiment:","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"data-preparation","dir":"Articles","previous_headings":"","what":"Data Preparation","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Distribution log2 abundance values across conditions. broad range right-skew typical phosphoproteomics data. abundance values span several orders magnitude, typical phosphoproteomics data. distributions appear similar timepoints global level, though individual peptides may show significant changes.","code":"library(peppwR) library(dplyr) library(ggplot2) library(tibble) # Load the DDA experiment data dda <- read.csv(\"../../sample_data/dda_data.csv\")  # Examine the structure glimpse(dda) ## Rows: 26,820 ## Columns: 7 ## $ protein_name      <chr> \"PROT_0001\", \"PROT_0001\", \"PROT_0001\", \"PROT_0001\", … ## $ genotype          <chr> \"Genotype_A\", \"Genotype_A\", \"Genotype_A\", \"Genotype_… ## $ bio_rep           <int> 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3… ## $ tech_rep          <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ timepoints        <int> 0, 0, 0, 150, 150, 150, 300, 300, 300, 600, 600, 600… ## $ timepoints_values <dbl> 111486.89, 169993.66, 7241966.48, 174394.39, 2955899… ## $ new_annotation    <chr> \"PEP_00001\", \"PEP_00001\", \"PEP_00001\", \"PEP_00001\", … # Filter to early (0) vs late (600) timepoints and format for peppwR pilot <- dda |>   filter(timepoints %in% c(0, 600)) |>   transmute(     peptide_id = new_annotation,     condition = paste0(\"t\", timepoints),     abundance = timepoints_values   )  # Summary statistics cat(\"Unique peptides:\", n_distinct(pilot$peptide_id), \"\\n\") ## Unique peptides: 2228 cat(\"Observations per condition:\\n\") ## Observations per condition: pilot |> count(condition) ##   condition    n ## 1        t0 6705 ## 2      t600 6705 # Exploratory visualization ggplot(pilot, aes(x = log2(abundance), fill = condition)) +   geom_density(alpha = 0.5) +   labs(     x = \"Log2 Abundance\",     y = \"Density\",     title = \"Phosphopeptide Abundance Distribution\"   ) +   theme_minimal()"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"why-fit-distributions","dir":"Articles","previous_headings":"Distribution Fitting","what":"Why Fit Distributions?","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"simulate realistic experiments, need parametric models capture statistical properties peptide’s abundance values. peppwR fits multiple candidate distributions (gamma, lognormal, inverse Gaussian, Pareto, skew normal, etc.) selects best fit peptide based AIC. Best-fit distribution counts across peptidome.","code":"# Fit distributions to each peptide fits <- fit_distributions(pilot, \"peptide_id\", \"condition\", \"abundance\")  # Summary of fitting results print(fits) ## peppwr_fits object ## ------------------ ## 4456 peptides fitted ##  ## Best fit distribution counts: ##   Gamma: 416 ##   Inverse Gaussian: 1 ##   Loggamma: 1 ##   Normal: 515 ##   Pareto: 3522 ##   Skew Normal: 1 # Visualize which distributions fit best plot(fits)"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"interpreting-distribution-fitting-results-a-cautionary-note","dir":"Articles","previous_headings":"Distribution Fitting","what":"Interpreting Distribution Fitting Results: A Cautionary Note","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Important: 6 observations per peptide (3 replicates x 2 conditions), distribution selection unreliable. may observe distributions like Pareto Skew Normal dominate “best fit” counts. artifact small sample size, statement true underlying distributions. biological replicates, expect gamma lognormal distributions fit better - typical distributions mass spectrometry abundance data based underlying measurement process. Key insight: specific distribution matters less enough data fit reliably. power analysis, proceed best available fits acknowledging limitation.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"parameter-distribution","dir":"Articles","previous_headings":"Distribution Fitting","what":"Parameter Distribution","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Distribution AIC values across peptides fitted distribution. Lower AIC indicates better fit.","code":"p <- plot_param_distribution(fits) print(p) # Count peptides per best-fit distribution for context cat(\"\\nPeptides per best-fit distribution:\\n\") ##  ## Peptides per best-fit distribution: tibble(distribution = fits$best) |>   count(distribution) |>   arrange(desc(n)) ## # A tibble: 6 × 2 ##   distribution         n ##   <chr>            <int> ## 1 Pareto            3522 ## 2 Normal             515 ## 3 Gamma              416 ## 4 Inverse Gaussian     1 ## 5 Loggamma             1 ## 6 Skew Normal          1"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"choosing-the-right-statistical-test","dir":"Articles","previous_headings":"Power Analysis","what":"Choosing the Right Statistical Test","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Critical first step: small samples (N=3), choice statistical test dramatically affects power. proceeding detailed analysis, must compare tests understand behavior. peppwR supports several tests: Let’s compare three tests N=3 2-fold effect: Power comparison across statistical tests (N=3, 2-fold effect)","code":"# Run all three tests (use n_sim = 100 for faster rendering) power_wilcox <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                 find = \"power\", test = \"wilcoxon\", n_sim = 100)  power_boot <- power_analysis(fits, effect_size = 2, n_per_group = 3,                               find = \"power\", test = \"bootstrap_t\", n_sim = 100)  power_bayes <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                find = \"power\", test = \"bayes_t\", n_sim = 100)  # Create comparison table comparison <- tibble(   Test = c(\"Wilcoxon rank-sum\", \"Bootstrap-t\", \"Bayes factor\"),   `Median Power` = c(     median(power_wilcox$simulations$peptide_power, na.rm = TRUE),     median(power_boot$simulations$peptide_power, na.rm = TRUE),     median(power_bayes$simulations$peptide_power, na.rm = TRUE)   ),   `% > 50% Power` = c(     mean(power_wilcox$simulations$peptide_power > 0.5, na.rm = TRUE) * 100,     mean(power_boot$simulations$peptide_power > 0.5, na.rm = TRUE) * 100,     mean(power_bayes$simulations$peptide_power > 0.5, na.rm = TRUE) * 100   ),   `% > 80% Power` = c(     mean(power_wilcox$simulations$peptide_power > 0.8, na.rm = TRUE) * 100,     mean(power_boot$simulations$peptide_power > 0.8, na.rm = TRUE) * 100,     mean(power_bayes$simulations$peptide_power > 0.8, na.rm = TRUE) * 100   ) )  knitr::kable(comparison, digits = 2,              caption = \"Power comparison across statistical tests (N=3, 2-fold effect)\")"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"understanding-the-test-comparison-results","dir":"Articles","previous_headings":"Power Analysis","what":"Understanding the Test Comparison Results","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"comparison table reveals important insights: Wilcoxon rank-sum conservative small samples. Non-parametric tests don’t make distributional assumptions, comes cost: need data achieve comparable power. Bootstrap-t uses resampling handle non-normality, potentially offering better power Wilcoxon. Bayes factor tests provide evidence effect. small N, Bayesian approaches can informative frequentist tests. Recommendation: remaining analyses document, use Bayes factor test since provides usable power estimates N=3.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"the-three-questions","dir":"Articles","previous_headings":"Power Analysis","what":"The Three Questions","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Power analysis can answer three related questions experimental design: Power: Given sample size effect size, power? Sample size: Given target power effect size, N need? Minimum detectable effect: Given sample size target power, ’s smallest effect can detect? questions mathematically related - fixing three parameters determines fourth.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"question-1-current-power-n3","dir":"Articles","previous_headings":"Power Analysis","what":"Question 1: Current Power (N=3)","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"3 biological replicates per group (experiment), power detect 2-fold change? Distribution power across peptides N=3 2-fold effect (Bayes factor test). bar represents proportion peptides achieving power level. N=3, power detect 2-fold change varies across peptides. Peptides lower variability higher power, noisy peptides remain -powered.","code":"# Using Bayes factor test based on our comparison results power_n3 <- power_analysis(fits, effect_size = 2, n_per_group = 3,                            find = \"power\", test = \"bayes_t\", n_sim = 100) print(power_n3) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Power: 51% ## Sample size: 3 per group ## Effect size: 2.00-fold ##  ## Statistical test: bayes_t ## Decision threshold: BF > 3 (substantial evidence) plot(power_n3)"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"question-2-sample-size-for-target-power","dir":"Articles","previous_headings":"Power Analysis","what":"Question 2: Sample Size for Target Power","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"sample size need achieve 80% power detect 2-fold change peptides? Percentage peptides reaching 80% power sample size. curve shows diminishing returns N increases. curve directly answers “percentage peptides well-powered sample size N?” - useful experimental planning budget constraints limit replication.","code":"sample_size <- power_analysis(fits, effect_size = 2, target_power = 0.8,                               find = \"sample_size\", test = \"bayes_t\", n_sim = 100) print(sample_size) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Recommended sample size: N=15 per group ## Target power: 80% ## Effect size: 2.00-fold ##  ## Statistical test: bayes_t ## Decision threshold: BF > 3 (substantial evidence) plot(sample_size)"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"question-3-minimum-detectable-effect","dir":"Articles","previous_headings":"Power Analysis","what":"Question 3: Minimum Detectable Effect","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"N=3 80% power target, ’s smallest effect can reliably detect? Understanding two thresholds: per-peptide mode, two distinct thresholds: target_power (set 0.8) - power level individual peptide must achieve proportion_threshold (default 0.5) - fraction peptides must reach target_power plot shows “% peptides reaching 80% power” y-axis. answer tells us: “effect size 50% peptides achieve 80% power?” Proportion peptides reaching 80% power effect size. default threshold 50% peptides (proportion_threshold = 0.5). N=3, large effects needed majority peptides well-powered. realistic sobering assessment -powered experiments can detect. require higher fraction peptides well-powered, increase proportion_threshold:","code":"min_effect <- power_analysis(fits, n_per_group = 3, target_power = 0.8,                              find = \"effect_size\", test = \"bayes_t\", n_sim = 100) print(min_effect) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Minimum detectable effect: 10.00-fold ## Sample size: 3 per group ## Target power: 80% ##  ## Statistical test: bayes_t ## Decision threshold: BF > 3 (substantial evidence) plot(min_effect) # Require 80% of peptides to reach 80% power (stricter) power_analysis(fits, n_per_group = 3, target_power = 0.8,                find = \"effect_size\", proportion_threshold = 0.8, ...)"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"power-heatmap","dir":"Articles","previous_headings":"","what":"Power Heatmap","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"power heatmap visualizes power varies across combinations sample size effect size - useful identifying “sweet spot” experimental design.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"why-aggregate-mode-for-heatmaps","dir":"Articles","previous_headings":"Power Heatmap","what":"Why Aggregate Mode for Heatmaps?","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"plot_power_heatmap() function uses aggregate mode (single distribution) rather per-peptide mode : Computational cost: Per-peptide heatmaps require millions simulations Visualization: single heatmap interpretable 2000+ individual heatmaps Purpose: Heatmaps answer “’s general tradeoff?” “’s power peptide X?” make heatmap relevant data, derive representative parameters fitted distributions: Power function sample size effect size representative peptide. Colors indicate expected power. Individual peptides vary based specific variability.","code":"# Derive representative parameters from the data log_abundances <- log(pilot$abundance[pilot$abundance > 0]) derived_params <- list(   meanlog = median(log_abundances),   sdlog = mad(log_abundances, constant = 1)  # robust SD estimate )  cat(\"Using representative lognormal parameters:\\n\") ## Using representative lognormal parameters: cat(\"  meanlog =\", round(derived_params$meanlog, 2), \"\\n\") ##   meanlog = 13.72 cat(\"  sdlog =\", round(derived_params$sdlog, 2), \"\\n\") ##   sdlog = 1.41 # Generate heatmap with data-derived parameters plot_power_heatmap(   distribution = \"lnorm\",   params = derived_params,   n_range = c(3, 12),   effect_range = c(1.2, 3),   test = \"wilcoxon\"  # heatmap uses aggregate mode )"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"interpreting-the-heatmap","dir":"Articles","previous_headings":"Power Heatmap","what":"Interpreting the Heatmap","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"heatmap shows power representative peptide typical abundance characteristics. Individual peptides vary: Low-variability peptides higher power shown High-variability peptides lower power shown Use per-peptide find = \"power\" results understand distribution across peptides heatmap shows: Lower-left corner (small N, small effect): Low power - avoid region Upper-right corner (large N, large effect): High power potentially wasteful Diagonal transition zone: practical planning region tradeoffs matter","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"key-findings","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Key Findings","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Distribution fitting: 6 observations per peptide, distribution selection unreliable. observed “best fit” distributions artifacts small sample size, true underlying distributions. Test selection matters: Wilcoxon rank-sum may limited power N=3 due conservative nature. Bayes factor tests can provide informative power estimates small samples. Current power (N=3): 3 replicates Bayes factor test, power detect 2-fold change varies across peptides based individual variability. Sample size requirements: Achieving consistently high power (80%+) across peptides requires N=3 biological replicates. Minimum detectable effect: N=3, relatively large fold changes can reliably detected 80% power peptides.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"practical-recommendations","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Practical Recommendations","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"future experiments: Consider N=6 biological replicates detecting smaller fold changes (<2-fold) important. current data interpretation: Results showing non-significance may reflect insufficient power rather absence biological effect. cautious concluding “difference.” Test selection: small samples, consider Bayes factor tests may informative traditional frequentist tests. Effect size expectations: Set realistic expectations - detecting subtle changes requires adequate replication.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"caveats","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Caveats","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"analysis uses single genotype (Col-0) specific timepoint comparison (0 vs 600) Distribution fitting limited small sample size (6 observations per peptide) Power estimates assume fitted distributions accurately represent underlying biology Technical variability (modeled ) may reduce effective power Real experimental factors (batch effects, sample quality) captured","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"","code":"sessionInfo() ## R version 4.5.2 (2025-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices datasets  utils     methods   base      ##  ## other attached packages: ## [1] tibble_3.3.1  ggplot2_4.0.2 dplyr_1.2.0   peppwR_0.1.0  ##  ## loaded via a namespace (and not attached): ##  [1] utf8_1.2.6          sass_0.4.10         generics_0.1.4      ##  [4] tidyr_1.3.2         renv_0.12.2         lattice_0.22-7      ##  [7] fGarch_4052.93      digest_0.6.39       magrittr_2.0.4      ## [10] evaluate_1.0.5      grid_4.5.2          RColorBrewer_1.1-3  ## [13] fastmap_1.2.0       Matrix_1.7-4        jsonlite_2.0.0      ## [16] purrr_1.2.1         scales_1.4.0        gbutils_0.5.1       ## [19] textshaping_1.0.4   jquerylib_0.1.4     Rdpack_2.6.6        ## [22] cli_3.6.5           timeSeries_4052.112 rlang_1.1.7         ## [25] rbibutils_2.4.1     intervals_0.15.5    withr_3.0.2         ## [28] cachem_1.1.0        yaml_2.3.12         cvar_0.6            ## [31] tools_4.5.2         assertthat_0.2.1    vctrs_0.7.1         ## [34] R6_2.6.1            lifecycle_1.0.5     fs_1.6.6            ## [37] univariateML_1.5.0  ragg_1.5.0          pkgconfig_2.0.3     ## [40] desc_1.4.3          pkgdown_2.2.0       pillar_1.11.1       ## [43] bslib_0.10.0        gtable_0.3.6        glue_1.8.0          ## [46] systemfonts_1.3.1   xfun_0.56           tidyselect_1.2.1    ## [49] knitr_1.51          farver_2.1.2        spatial_7.3-18      ## [52] htmltools_0.5.9     fBasics_4052.98     rmarkdown_2.30      ## [55] labeling_0.4.3      timeDate_4052.112   compiler_4.5.2      ## [58] S7_0.2.1"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with peppwR","text":"peppwR helps researchers answer power analysis questions phosphoproteomics experiments: Sample size: “sample size need 80% power detect 2-fold change?” Power: “N=6 per group, ’s power detect 2-fold change?” Effect size: “N=6 80% power, ’s minimum detectable effect?” vignette demonstrates minimal workflow get zero power estimates.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Getting Started with peppwR","text":"","code":"# From GitHub devtools::install_github(\"danmaclean/peppwR\")"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Getting Started with peppwR","text":"","code":"library(peppwR)"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"generate-synthetic-pilot-data","dir":"Articles","previous_headings":"","what":"Generate Synthetic Pilot Data","title":"Getting Started with peppwR","text":"Let’s create realistic phosphopeptide abundance data: 100 peptides, 2 conditions (control/treatment), 4 replicates . ’ll use gamma distributions typical proteomics data.","code":"set.seed(42)  # Generate peptide-level parameters n_peptides <- 100 n_per_group <- 4  peptide_params <- tibble::tibble(   peptide_id = paste0(\"pep_\", sprintf(\"%04d\", 1:n_peptides)),   # Shape parameter: 1.5-5 (lower = more skewed)   shape = runif(n_peptides, 1.5, 5),   # Rate parameter: scaled to give realistic abundances   rate = runif(n_peptides, 0.01, 0.1) )  # Generate observations for each peptide pilot_data <- peptide_params |>   dplyr::rowwise() |>   dplyr::mutate(     data = list(tibble::tibble(       condition = rep(c(\"control\", \"treatment\"), each = n_per_group),       replicate = rep(1:n_per_group, 2),       abundance = rgamma(n_per_group * 2, shape = shape, rate = rate)     ))   ) |>   dplyr::ungroup() |>   dplyr::select(peptide_id, data) |>   tidyr::unnest(data)  # Preview the data head(pilot_data, 12) #> # A tibble: 12 × 4 #>    peptide_id condition replicate abundance #>    <chr>      <chr>         <int>     <dbl> #>  1 pep_0001   control           1     106.  #>  2 pep_0001   control           2      99.7 #>  3 pep_0001   control           3      36.1 #>  4 pep_0001   control           4      62.1 #>  5 pep_0001   treatment         1      66.6 #>  6 pep_0001   treatment         2      50.9 #>  7 pep_0001   treatment         3      97.6 #>  8 pep_0001   treatment         4      52.2 #>  9 pep_0002   control           1     143.  #> 10 pep_0002   control           2     295.  #> 11 pep_0002   control           3     216.  #> 12 pep_0002   control           4      89.0"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"fit-distributions","dir":"Articles","previous_headings":"","what":"Fit Distributions","title":"Getting Started with peppwR","text":"Use fit_distributions() determine statistical distributions best describe peptide abundance data. distributions parameter controls distributions fitted: - \"continuous\" (default) - gamma, normal, lognormal, etc. abundance data - \"counts\" - includes negative binomial count-based quantification - \"\" - tries distributions auto-detection output shows many peptides best fit distribution. helps understand statistical properties data. data contains missing values, output also show: - Missingness statistics (NA rates, peptides missing data) - Dataset-level MNAR: Correlation abundance missingness (negative correlation indicates low-abundance peptides missing values) See vignette(\"power-analysis-workflow\") details missingness handling.","code":"fits <- fit_distributions(   pilot_data,   id = \"peptide_id\",   group = \"condition\",   value = \"abundance\",   distributions = \"continuous\" ) #> Loading required namespace: intervals  print(fits) #> peppwr_fits object #> ------------------ #> 200 peptides fitted #>  #> Best fit distribution counts: #>   Gamma: 13 #>   Normal: 22 #>   Pareto: 124 #>   Skew Normal: 41"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"visualize-distribution-fits","dir":"Articles","previous_headings":"Fit Distributions","what":"Visualize Distribution Fits","title":"Getting Started with peppwR","text":"plot shows count best-fit distributions two metrics: - AIC (Akaike Information Criterion): Balances fit quality model complexity - LogLikelihood: Pure goodness--fit measure metrics agree, can confident distribution choice.","code":"plot(fits)"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"assess-fit-quality","dir":"Articles","previous_headings":"","what":"Assess Fit Quality","title":"Getting Started with peppwR","text":"larger pilot datasets (n≥15 per group), can visually assess fit quality using diagnostic plots. peppwR provides two options: Density overlay - overlays fitted density curves observed histograms: QQ plots - compare observed vs theoretical quantiles: small pilot data (n=4 per group), plots informative - simply points per peptide meaningful visual assessment. See vignette(\"power-analysis-workflow\") examples larger datasets. fits look poor, consider: - Using different candidate distributions - Checking outliers data quality issues - Using on_fit_failure = \"empirical\" power analysis bootstrap raw data","code":"# Visual check: does the fitted distribution match the data? plot_density_overlay(fits, n_overlay = 4) # Goodness-of-fit assessment via QQ plots plot_qq(fits, n_plots = 4)"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"a-note-on-sample-size-and-distribution-detection","dir":"Articles","previous_headings":"","what":"A Note on Sample Size and Distribution Detection","title":"Getting Started with peppwR","text":"small pilot datasets (n=4 per group = 8 observations per peptide), “best” distribution may match true underlying distribution. synthetic data generated Gamma distributions, small samples may see Pareto Skew Normal selected “best.” Let’s verify larger samples, correct distribution identified: 30 samples per group, Gamma distribution correctly identified best fit. Takeaway: small pilot studies, interpret “best fit” “best among candidates given limited data” rather definitive truth. fitted parameters still useful power simulation regardless distribution family selected.","code":"set.seed(42)  # Generate data with larger sample size - 30 per group large_n_data <- tibble::tibble(   peptide_id = \"test_peptide\",   condition = rep(c(\"control\", \"treatment\"), each = 30),   replicate = rep(1:30, 2),   abundance = rgamma(60, shape = 3, rate = 0.05)  # True distribution: Gamma )  large_fits <- fit_distributions(   large_n_data,   id = \"peptide_id\",   group = \"condition\",   value = \"abundance\",   distributions = \"continuous\" )  print(large_fits) #> peppwr_fits object #> ------------------ #> 2 peptides fitted #>  #> Best fit distribution counts: #>   Gamma: 2"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"power-analysis---aggregate-mode","dir":"Articles","previous_headings":"","what":"Power Analysis - Aggregate Mode","title":"Getting Started with peppwR","text":"don’t pilot data, want quick ballpark estimate, use aggregate mode. specify assumed distribution parameters.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"finding-required-sample-size","dir":"Articles","previous_headings":"Power Analysis - Aggregate Mode","what":"Finding Required Sample Size","title":"Getting Started with peppwR","text":"“many samples need per group achieve 80% power detecting 2-fold change?”  plot shows power curve target power recommended sample size highlighted.","code":"result_n <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 1000 )  print(result_n) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Recommended sample size: N=25 per group #> Target power: 80% #> Effect size: 2.00-fold #>  #> Statistical test: wilcoxon #> Significance level: 0.05 plot(result_n)"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"finding-power-at-fixed-n","dir":"Articles","previous_headings":"Power Analysis - Aggregate Mode","what":"Finding Power at Fixed N","title":"Getting Started with peppwR","text":"“’s power detect 2-fold change N=6 per group?”","code":"result_power <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 1000 )  print(result_power) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 24% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Statistical test: wilcoxon #> Significance level: 0.05"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"power-analysis---per-peptide-mode","dir":"Articles","previous_headings":"","what":"Power Analysis - Per-Peptide Mode","title":"Getting Started with peppwR","text":"pilot data, use per-peptide mode accurate, peptide-specific power estimates. mode: 1. Uses fitted distribution peptide 2. Simulates power individually 3. Reports proportion peptidome reaches target power  plot shows percentage peptides achieve target power sample size. 50% line indicates majority peptides well-powered.","code":"result_pp <- power_analysis(   fits,   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  print(result_pp) #> peppwr_power analysis #> --------------------- #> Mode: per_peptide #>  #> Recommended sample size: N=12 per group #> Target power: 80% #> Effect size: 2.00-fold #>  #> Statistical test: wilcoxon #> Significance level: 0.05 plot(result_pp)"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"interpreting-per-peptide-results","dir":"Articles","previous_headings":"Power Analysis - Per-Peptide Mode","what":"Interpreting Per-Peptide Results","title":"Getting Started with peppwR","text":"Unlike aggregate mode, per-peptide mode acknowledges peptides behave . peptides may require samples due higher variance, others achieve target power fewer samples. “% peptides target power” metric helps understand: - N peptides become well-powered? - fraction peptides remain underpowered even larger samples?","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Getting Started with peppwR","text":"Power Analysis Workflow: See vignette(\"power-analysis-workflow\") detailed guidance modes, three power questions, statistical test options. Benchmarking: See vignette(\"benchmarking\") performance characteristics large datasets.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Power Analysis Workflow","text":"peppwR addresses three fundamental power analysis questions: Sample size: “sample size need achieve target power?” Power: “power given sample size?” Effect size: “’s minimum detectable effect given power sample size?” package offers two modes analysis:","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"when-to-use-aggregate-mode","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"When to Use Aggregate Mode","title":"Power Analysis Workflow","text":"Planning new experiment without pilot data Quick ballpark estimates needed Comparing different experimental scenarios Teaching demonstration purposes","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"choosing-distribution-parameters","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"Choosing Distribution Parameters","title":"Power Analysis Workflow","text":"phosphoproteomics, gamma distributions common. Typical parameters: Conservative estimates use lower shape (skewed, higher variance), optimistic estimates use higher shape (symmetric, lower variance).","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"finding-sample-size","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"Finding Sample Size","title":"Power Analysis Workflow","text":"“many samples per group need 80% power detect 2-fold change?”  power curve shows power increases sample size. recommended N smallest value achieving target.","code":"set.seed(123)  result <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 1000 )  print(result) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Recommended sample size: N=25 per group #> Target power: 80% #> Effect size: 2.00-fold #>  #> Statistical test: wilcoxon #> Significance level: 0.05 plot(result)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"finding-power","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"Finding Power","title":"Power Analysis Workflow","text":"“N=6 per group, ’s power detect 2-fold change?”","code":"set.seed(123)  result <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 1000 )  print(result) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 24% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Statistical test: wilcoxon #> Significance level: 0.05"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"finding-minimum-detectable-effect","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"Finding Minimum Detectable Effect","title":"Power Analysis Workflow","text":"“N=6 80% target power, ’s smallest effect can reliably detect?”","code":"set.seed(123)  result <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   n_per_group = 6,   target_power = 0.8,   find = \"effect_size\",   n_sim = 1000 )  print(result) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Minimum detectable effect: 5.00-fold #> Sample size: 6 per group #> Target power: 80% #>  #> Statistical test: wilcoxon #> Significance level: 0.05 plot(result)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"sensitivity-to-parameter-choices","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"Sensitivity to Parameter Choices","title":"Power Analysis Workflow","text":"Let’s see results change different distribution assumptions: unsure, use conservative estimates avoid underpowered experiments.","code":"set.seed(123)  # Conservative (high variance) conservative <- power_analysis(   \"gamma\",   params = list(shape = 1.5, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  # Moderate moderate <- power_analysis(   \"gamma\",   params = list(shape = 2.5, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  # Optimistic (low variance) optimistic <- power_analysis(   \"gamma\",   params = list(shape = 4, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  cat(\"Conservative (shape=1.5): N =\", conservative$answer, \"per group\\n\") #> Conservative (shape=1.5): N = 30 per group cat(\"Moderate (shape=2.5):     N =\", moderate$answer, \"per group\\n\") #> Moderate (shape=2.5):     N = 20 per group cat(\"Optimistic (shape=4):     N =\", optimistic$answer, \"per group\\n\") #> Optimistic (shape=4):     N = 12 per group"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"when-to-use-per-peptide-mode","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"When to Use Per-Peptide Mode","title":"Power Analysis Workflow","text":"pilot data similar experiments Peptide heterogeneity expected want realistic power estimates across peptidome Planning follow-studies","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"step-1-distribution-fitting","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"Step 1: Distribution Fitting","title":"Power Analysis Workflow","text":"First, fit distributions pilot data: use distributions = \"continuous\" abundance data. Use \"counts\" count-based quantification (e.g., spectral counts). Note distribution detection: n=4 per group (8 observations total), distribution selection uncertainty. may see distributions like Pareto Skew Normal selected even true underlying distribution Gamma. normal - fitted parameters still useful power simulation. larger samples (n≥15 per group), correct distribution family reliably identified.","code":"set.seed(42)  # Generate heterogeneous pilot data n_peptides <- 100 n_per_group <- 4  peptide_params <- tibble::tibble(   peptide_id = paste0(\"pep_\", sprintf(\"%04d\", 1:n_peptides)),   shape = runif(n_peptides, 1.5, 5),   rate = runif(n_peptides, 0.01, 0.1) )  pilot_data <- peptide_params |>   dplyr::rowwise() |>   dplyr::mutate(     data = list(tibble::tibble(       condition = rep(c(\"control\", \"treatment\"), each = n_per_group),       replicate = rep(1:n_per_group, 2),       abundance = rgamma(n_per_group * 2, shape = shape, rate = rate)     ))   ) |>   dplyr::ungroup() |>   dplyr::select(peptide_id, data) |>   tidyr::unnest(data) fits <- fit_distributions(   pilot_data,   id = \"peptide_id\",   group = \"condition\",   value = \"abundance\",   distributions = \"continuous\" ) #> Loading required namespace: intervals  print(fits) #> peppwr_fits object #> ------------------ #> 200 peptides fitted #>  #> Best fit distribution counts: #>   Gamma: 13 #>   Normal: 22 #>   Pareto: 124 #>   Skew Normal: 41"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"understanding-fit-results","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"Understanding Fit Results","title":"Power Analysis Workflow","text":"print output shows: - Total peptides fitted - Distribution best-fit models - fit failures summary provides detailed statistics including AIC ranges median values.","code":"summary(fits) #> Summary of peppwr_fits #> ====================== #>  #> Peptides fitted: 200 #> Failed fits: 0 (0.0%) #>  #> Best distribution counts: #>   Gamma: 13 #>   Normal: 22 #>   Pareto: 124 #>   Skew Normal: 41 #>  #> Fit statistics: #>   AIC range: [17.6, Inf] #>   AIC median: 40.5 #>   LogLik range: [-Inf, -5.9] #>   LogLik median: -18.1"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"step-2-per-peptide-power-analysis","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"Step 2: Per-Peptide Power Analysis","title":"Power Analysis Workflow","text":"Now use fits power analysis:  histogram shows distribution power across peptides. Note power varies substantially - peptides achieve near 100% power others remain underpowered.","code":"set.seed(123)  result_pp <- power_analysis(   fits,   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 500 )  print(result_pp) #> peppwr_power analysis #> --------------------- #> Mode: per_peptide #>  #> Power: 55% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Statistical test: wilcoxon #> Significance level: 0.05 plot(result_pp)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"finding-sample-size-per-peptide","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"Finding Sample Size (Per-Peptide)","title":"Power Analysis Workflow","text":"“sample size gives 80% power peptides?”  “peptide threshold curve” shows proportion peptides achieve target power sample size. 50% line indicates majority peptides become well-powered.","code":"set.seed(123)  result_n <- power_analysis(   fits,   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  print(result_n) #> peppwr_power analysis #> --------------------- #> Mode: per_peptide #>  #> Recommended sample size: N=12 per group #> Target power: 80% #> Effect size: 2.00-fold #>  #> Statistical test: wilcoxon #> Significance level: 0.05 plot(result_n)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"interpreting-per-peptide-results","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"Interpreting Per-Peptide Results","title":"Power Analysis Workflow","text":"Key insights per-peptide analysis: Heterogeneity: Power varies across peptides due different underlying distributions Majority rule: recommended N aims power majority (50%+) peptides Underpowered fraction: peptides may never achieve target power practical sample sizes","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"comparing-the-two-modes","dir":"Articles","previous_headings":"","what":"Comparing the Two Modes","title":"Power Analysis Workflow","text":"Let’s run modes data:","code":"set.seed(123)  # Aggregate mode with \"typical\" parameters agg_result <- power_analysis(   \"gamma\",   params = list(shape = 2.5, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  # Per-peptide mode pp_result <- power_analysis(   fits,   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  cat(\"Aggregate mode:   N =\", agg_result$answer, \"per group\\n\") #> Aggregate mode:   N = 20 per group cat(\"Per-peptide mode: N =\", pp_result$answer, \"per group\\n\") #> Per-peptide mode: N = 12 per group"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"when-results-disagree","dir":"Articles","previous_headings":"Comparing the Two Modes","what":"When Results Disagree","title":"Power Analysis Workflow","text":"Per-peptide > Aggregate: peptidome heterogeneous assumed Aggregate > Per-peptide: assumed parameters conservative Large disagreement: Reconsider aggregate assumptions Recommendation: pilot data available, trust per-peptide results.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"statistical-test-options","dir":"Articles","previous_headings":"","what":"Statistical Test Options","title":"Power Analysis Workflow","text":"peppwR supports multiple statistical tests:","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"default-wilcoxon-test","dir":"Articles","previous_headings":"Statistical Test Options","what":"Default: Wilcoxon Test","title":"Power Analysis Workflow","text":"Wilcoxon rank-sum test default : - Makes distributional assumptions - robust outliers - Works well small samples typical proteomics","code":"set.seed(123)  result_wilcox <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   test = \"wilcoxon\",   n_sim = 500 )  print(result_wilcox) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 24% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Statistical test: wilcoxon #> Significance level: 0.05"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"bootstrap-t-test","dir":"Articles","previous_headings":"Statistical Test Options","what":"Bootstrap-t Test","title":"Power Analysis Workflow","text":"small samples non-normal data:","code":"set.seed(123)  result_boot <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   test = \"bootstrap_t\",   n_sim = 500 )  print(result_boot) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 28% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Statistical test: bootstrap_t #> Significance level: 0.05"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"bayes-factor-test","dir":"Articles","previous_headings":"Statistical Test Options","what":"Bayes Factor Test","title":"Power Analysis Workflow","text":"Bayes factor test provides evidence strength rather p-value. result considered “significant” BF > 3 (substantial evidence).","code":"set.seed(123)  result_bayes <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   test = \"bayes_t\",   n_sim = 500 )  print(result_bayes) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 58% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Statistical test: bayes_t #> Decision threshold: BF > 3 (substantial evidence)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"rank-products-test","dir":"Articles","previous_headings":"Statistical Test Options","what":"Rank Products Test","title":"Power Analysis Workflow","text":"Designed specifically omics experiments:","code":"set.seed(123)  result_rp <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   test = \"rankprod\",   n_sim = 500 )  print(result_rp) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 31% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Statistical test: rankprod #> Significance level: 0.05"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"diagnostic-plots","dir":"Articles","previous_headings":"","what":"Diagnostic Plots","title":"Power Analysis Workflow","text":"peppwR provides several diagnostic plots assess fit quality explore power landscapes.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"assessing-fit-quality","dir":"Articles","previous_headings":"Diagnostic Plots","what":"Assessing Fit Quality","title":"Power Analysis Workflow","text":"fitting distributions, verify fits reasonable:  density overlay shows observed histogram (blue) fitted distribution curve (red). Good fits show curve closely following histogram shape.  QQ plot, points fall along diagonal line. Systematic deviations indicate poor fit: - S-shaped curve: Distribution wrong tail behavior - Points line right: Heavy right tail data - Points line left: Heavy left tail data","code":"set.seed(42)  # For reproducible peptide selection  # Histogram with fitted density overlay plot_density_overlay(fits, n_overlay = 6) # QQ plots for goodness-of-fit plot_qq(fits, n_plots = 6)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"distribution-of-fit-statistics","dir":"Articles","previous_headings":"Diagnostic Plots","what":"Distribution of Fit Statistics","title":"Power Analysis Workflow","text":"shows AIC values distributed across peptides, grouped best-fitting distribution.","code":"# AIC distribution across the peptidome by best-fit distribution plot_param_distribution(fits)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"exploring-power-landscapes","dir":"Articles","previous_headings":"Diagnostic Plots","what":"Exploring Power Landscapes","title":"Power Analysis Workflow","text":"planning purposes, can visualize power varies across sample sizes effect sizes:  heatmap provides quick lookup table power different experimental designs.","code":"# Power heatmap: sample size vs effect size grid plot_power_heatmap(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   n_range = c(3, 12),   effect_range = c(1.5, 3),   n_steps = 5,   n_sim = 200 ) set.seed(123)  # First create a result to use result_for_plot <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 500 )  # Power sensitivity at fixed sample size plot_power_vs_effect(result_for_plot, effect_range = c(1.2, 4), n_sim = 200)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"handling-missing-data","dir":"Articles","previous_headings":"","what":"Handling Missing Data","title":"Power Analysis Workflow","text":"Proteomics data often contains missing values, particularly low-abundance peptides near detection limit. peppwR tracks models missingness provide realistic power estimates.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"understanding-missingness","dir":"Articles","previous_headings":"Handling Missing Data","what":"Understanding Missingness","title":"Power Analysis Workflow","text":"fit_distributions() function automatically computes missingness statistics peptide:","code":"# Fits object includes missingness statistics print(fits) #> peppwr_fits object #> ------------------ #> 200 peptides fitted #>  #> Best fit distribution counts: #>   Gamma: 13 #>   Normal: 22 #>   Pareto: 124 #>   Skew Normal: 41  # Detailed missingness summary summary(fits)$missingness #> $total_missing #> [1] 0 #>  #> $total_values #> [1] 800 #>  #> $mean_na_rate #> [1] 0 #>  #> $median_na_rate #> [1] 0 #>  #> $max_na_rate #> [1] 0 #>  #> $n_peptides_with_na #> [1] 0 #>  #> $dataset_mnar_correlation #> [1] NA #>  #> $dataset_mnar_pvalue #> [1] NA #>  #> $dataset_mnar_interpretation #> [1] \"Insufficient peptides with missing data (< 5)\""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"visualizing-missingness-patterns","dir":"Articles","previous_headings":"Handling Missing Data","what":"Visualizing Missingness Patterns","title":"Power Analysis Workflow","text":"plot shows two panels: Left: Distribution NA rates across peptides Right: Mean abundance vs NA rate dataset-level correlation. negative correlation (shown subtitle) indicates low-abundance peptides missing values - hallmark MNAR proteomics","code":"# Visualize NA rate distribution and MNAR pattern plot_missingness(fits_na)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"mnar-detection","dir":"Articles","previous_headings":"Handling Missing Data","what":"MNAR Detection","title":"Power Analysis Workflow","text":"MNAR (Missing Random) occurs probability value missing depends value . proteomics, typically happens low-abundance peptides fall detection limit. peppwR detects MNAR correlating mean abundance NA rate across peptides. dataset-level metric shown automatically print fits object plot_missingness() visualization. strong negative correlation indicates low-abundance peptides missing values, consistent detection-limit-driven MNAR.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"incorporating-missingness-into-simulations","dir":"Articles","previous_headings":"Handling Missing Data","what":"Incorporating Missingness into Simulations","title":"Power Analysis Workflow","text":"realistic power estimates, can incorporate peptide-specific NA rates: include_missingness = TRUE, simulations incorporate peptide’s observed NA rate, providing power estimates reflect ’d actually observe experiment.","code":"set.seed(123)  # Power analysis accounting for expected NA rates result_na <- power_analysis(   fits_na,   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 500,   include_missingness = TRUE )  print(result_na) #> peppwr_power analysis #> --------------------- #> Mode: per_peptide #>  #> Power: 51% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Statistical test: wilcoxon #> Significance level: 0.05"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"fdr-aware-power-analysis","dir":"Articles","previous_headings":"","what":"FDR-Aware Power Analysis","title":"Power Analysis Workflow","text":"Standard power analysis computes per-peptide power nominal alpha (e.g., 0.05). However, thousands peptides, ’ll apply multiple testing correction - affects effective power.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"the-multiple-testing-problem","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"The Multiple Testing Problem","title":"Power Analysis Workflow","text":"testing thousands peptides: - α = 0.05, expect 50 false positives per 1000 true nulls - FDR correction (e.g., Benjamini-Hochberg) controls false discovery rate - makes harder detect true effects","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"running-fdr-adjusted-analysis","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Running FDR-Adjusted Analysis","title":"Power Analysis Workflow","text":"apply_fdr mode simulates entire experiments mixture null alternative peptides, applies Benjamini-Hochberg correction computing power. Note: FDR-adjusted mode requires frequentist tests (wilcoxon bootstrap_t). bayes_t test compatible FDR mode Bayes factors converted p-values BH correction.","code":"set.seed(123)  result_fdr <- power_analysis(   fits,   effect_size = 2,   n_per_group = 6,   find = \"power\",   apply_fdr = TRUE,   prop_null = 0.9,       # 90% of peptides are true nulls   fdr_threshold = 0.05,  # Target 5% FDR   n_sim = 200 )  print(result_fdr) #> peppwr_power analysis #> --------------------- #> Mode: per_peptide #>  #> Power: 5% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Statistical test: wilcoxon #> Significance level: 0.05 #>  #> FDR-adjusted analysis (Benjamini-Hochberg) #> Proportion true nulls: 90% #> FDR threshold: 5%"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"understanding-prop_null","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Understanding prop_null","title":"Power Analysis Workflow","text":"prop_null parameter specifies proportion peptides expect effect: - prop_null = 0.9: 10% peptides show differential abundance - prop_null = 0.95: 5% change (conservative) - prop_null = 0.8: 20% change (liberal) Higher prop_null makes FDR correction stringent, reducing power.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"fdr-vs-uncorrected-power","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"FDR vs Uncorrected Power","title":"Power Analysis Workflow","text":"FDR-adjusted power typically lower BH correction requires stronger evidence call discoveries. Use FDR mode want know many true positives ’ll actually detect correction.","code":"set.seed(123)  # Uncorrected (per-peptide) power result_uncorr <- power_analysis(   fits,   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 200 )  cat(\"Uncorrected power: \", round(result_uncorr$answer * 100), \"%\\n\", sep = \"\") #> Uncorrected power: 55% cat(\"FDR-adjusted power:\", round(result_fdr$answer * 100), \"%\\n\", sep = \"\") #> FDR-adjusted power:5%"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"fit-failures","dir":"Articles","previous_headings":"Handling Edge Cases","what":"Fit Failures","title":"Power Analysis Workflow","text":"distributions fail fit peptides, three options: Recommendations: - Start \"exclude\" see many peptides fail - Use \"lognormal\" fit failures common enough data points - Use \"empirical\" want purely data-driven simulation without distribution assumptions","code":"set.seed(123)  # Option 1: Exclude failed fits (default) result_exclude <- power_analysis(fits, effect_size = 2, n_per_group = 6,                                  find = \"power\", on_fit_failure = \"exclude\", n_sim = 200)  # Option 2: Use lognormal fallback result_lognorm <- power_analysis(fits, effect_size = 2, n_per_group = 6,                                  find = \"power\", on_fit_failure = \"lognormal\", n_sim = 200)  # Option 3: Bootstrap from empirical data result_empirical <- power_analysis(fits, effect_size = 2, n_per_group = 6,                                    find = \"power\", on_fit_failure = \"empirical\", n_sim = 200)  cat(\"Exclude failures:    \", round(result_exclude$answer * 100), \"% power\\n\", sep = \"\") #> Exclude failures:    55% power cat(\"Lognormal fallback:  \", round(result_lognorm$answer * 100), \"% power\\n\", sep = \"\") #> Lognormal fallback:  55% power cat(\"Empirical bootstrap: \", round(result_empirical$answer * 100), \"% power\\n\", sep = \"\") #> Empirical bootstrap: 55% power"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"very-small-pilot-datasets","dir":"Articles","previous_headings":"Handling Edge Cases","what":"Very Small Pilot Datasets","title":"Power Analysis Workflow","text":"<3 replicates per group: - Distribution fitting may unreliable - Consider aggregate mode conservative parameters - Increase n_sim stable estimates","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"extreme-effect-sizes","dir":"Articles","previous_headings":"Handling Edge Cases","what":"Extreme Effect Sizes","title":"Power Analysis Workflow","text":"large effects (>5-fold) typically achieve high power minimal samples. small effects (<1.2-fold) may require impractically large samples.","code":"set.seed(123)  # Large effect large <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 5,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  # Small effect small <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 1.2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  cat(\"5-fold change:   N =\", large$answer, \"per group\\n\") #> 5-fold change:   N = 6 per group cat(\"1.2-fold change: N =\", small$answer, \"per group\\n\") #> 1.2-fold change: N = 50 per group"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Power Analysis Workflow","text":"Start aggregate mode quick estimates planning Use per-peptide mode pilot data available accurate estimates Consider heterogeneity - peptides behave Choose appropriate tests - Wilcoxon safe default conservative - underpowered experiments waste resources","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Power Analysis Workflow","text":"Getting Started: See vignette(\"getting-started\") minimal workflow Benchmarking: See vignette(\"benchmarking\") performance large datasets","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"what-makes-targeted-proteomics-different","dir":"Articles","previous_headings":"Introduction","what":"What Makes Targeted Proteomics Different?","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Targeted proteomics (PRM/SRM) takes aim specific targets: Measures pre-defined panel peptides Higher sensitivity reproducibility Better hypothesis testing Lower multiple testing burden document analyzes PRM dataset, demonstrating peppwR handles unique challenges targeted proteomics, including missing data FDR considerations.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"the-missing-data-challenge","dir":"Articles","previous_headings":"Introduction","what":"The Missing Data Challenge","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Even targeted methods, missing values ubiquitous mass spectrometry. missing data created equal: MCAR (Missing Completely Random) Values missing due random technical failures relationship abundance Reduces sample size doesn’t bias results MNAR (Missing Random) Low-abundance peptides systematically missing detection limit = measurement Can bias abundance estimates upward Common mass spectrometry peppwR tracks rate missingness evidence MNAR patterns, enabling realistic power estimates.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"goals-of-this-analysis","dir":"Articles","previous_headings":"Introduction","what":"Goals of This Analysis","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Characterize missingness patterns data Identify peptides MNAR evidence Compare statistical tests small sample sizes Determine realistic sample size requirements Understand FDR impact power","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"about-the-data","dir":"Articles","previous_headings":"","what":"About the Data","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"analysis uses fungal phosphoproteomics data targeted PRM experiment:","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"data-preparation","dir":"Articles","previous_headings":"","what":"Data Preparation","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"","code":"library(peppwR) library(dplyr) library(ggplot2) library(tibble) # Load the PRM experiment data prm <- read.csv(\"../../sample_data/prm_data.csv\")  # Examine the structure glimpse(prm) ## Rows: 20,520 ## Columns: 7 ## $ molecule_list_name        <chr> \"MOL_0001\", \"MOL_0001\", \"MOL_0001\", \"MOL_000… ## $ peptide_modified_sequence <chr> \"PEP_00001\", \"PEP_00001\", \"PEP_00001\", \"PEP_… ## $ genotype                  <chr> \"Genotype_A\", \"Genotype_A\", \"Genotype_A\", \"G… ## $ timepoint                 <dbl> 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0,… ## $ bio_rep                   <int> 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2,… ## $ tech_rep                  <int> 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,… ## $ total_area                <dbl> 1.031275e-03, 1.130267e-03, 5.243216e-04, 2.… # Check for missing values in raw data cat(\"Total observations:\", nrow(prm), \"\\n\") ## Total observations: 20520 cat(\"Missing values:\", sum(is.na(prm$total_area)), \"\\n\") ## Missing values: 3547 cat(\"Missing rate:\", round(mean(is.na(prm$total_area)) * 100, 1), \"%\\n\") ## Missing rate: 17.3 %"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"why-average-technical-replicates","dir":"Articles","previous_headings":"Data Preparation","what":"Why Average Technical Replicates?","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Technical replicates measure biological sample multiple times. capture measurement variability, biological variability. power analysis, biological replicates true unit replication - represent independent observations biological phenomenon ’re studying. average technical replicates get one value per biological replicate.","code":"# Filter to early (0) vs late (6) timepoints # Average technical replicates within each biological replicate pilot <- prm |>   filter(timepoint %in% c(0, 6)) |>   group_by(peptide_modified_sequence, genotype, timepoint, bio_rep) |>   summarise(abundance = mean(total_area, na.rm = TRUE), .groups = \"drop\") |>   transmute(     peptide_id = peptide_modified_sequence,     condition = paste0(\"t\", timepoint),     abundance = abundance   )  # Summary statistics cat(\"Unique peptides:\", n_distinct(pilot$peptide_id), \"\\n\") ## Unique peptides: 285 cat(\"Observations per condition:\\n\") ## Observations per condition: pilot |> count(condition) ## # A tibble: 2 × 2 ##   condition     n ##   <chr>     <int> ## 1 t0         1710 ## 2 t6         1710 # Check missingness after averaging technical replicates # (NaN results when both tech reps are NA) pilot <- pilot |>   mutate(abundance = ifelse(is.nan(abundance), NA, abundance))  cat(\"Missing after averaging tech reps:\", sum(is.na(pilot$abundance)), \"\\n\") ## Missing after averaging tech reps: 429 cat(\"Missing rate:\", round(mean(is.na(pilot$abundance)) * 100, 1), \"%\\n\") ## Missing rate: 12.5 %"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"examining-the-extent-of-missingness","dir":"Articles","previous_headings":"Missingness Analysis","what":"Examining the Extent of Missingness","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"diving power analysis, need understand missing data. peppwR automatically computes missingness statistics distribution fitting.","code":"# Fit distributions - missingness is tracked automatically fits <- fit_distributions(pilot, \"peptide_id\", \"condition\", \"abundance\")  # Summary includes missingness information print(fits) ## peppwr_fits object ## ------------------ ## 570 peptides fitted ##  ## Best fit distribution counts: ##   Gamma: 103 ##   Inverse Gaussian: 36 ##   InvGamma: 2 ##   Lognormal: 5 ##   Normal: 91 ##   Pareto: 273 ##   Skew Normal: 60 ##  ## Missingness: 429/3420 values NA (12.5%) ## Peptides with missing data: 180 ##  ## MNAR detection (abundance vs missingness): ##   Correlation: r = -0.40 (p = 1.3e-07) ##   Moderate evidence of MNAR: low-abundance peptides have more missing values (p = 1.3e-07)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"visualizing-missingness-patterns","dir":"Articles","previous_headings":"Missingness Analysis","what":"Visualizing Missingness Patterns","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"plot_missingness() function provides three complementary views: NA Rate Distribution: fraction observations missing peptide? Abundance vs NA Rate: low-abundance peptides missing values? Missingness patterns across PRM peptidome. Left: Distribution NA rates. Right: Relationship mean abundance NA rate.","code":"plot_missingness(fits)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"mnar-detection","dir":"Articles","previous_headings":"Missingness Analysis","what":"MNAR Detection","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"MNAR (Missing Random) mass spectrometry typically occurs low-abundance peptides fall detection limit. peppwR detects correlating mean abundance NA rate across peptides. negative correlation indicates low-abundance peptides missing values - hallmark detection-limit-driven missingness.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"implications-of-mnar","dir":"Articles","previous_headings":"Missingness Analysis","what":"Implications of MNAR","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"MNAR detected, aware : Abundance estimates low-abundance peptides may biased upward (since low values missing) Power calculations may optimistic peptides Consider robust statistical methods account non-random missingness Report MNAR pattern publications","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"distribution-fitting-results","dir":"Articles","previous_headings":"","what":"Distribution Fitting Results","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Best-fit distribution counts PRM data.","code":"plot(fits)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"interpreting-distribution-fitting-a-cautionary-note","dir":"Articles","previous_headings":"Distribution Fitting Results","what":"Interpreting Distribution Fitting: A Cautionary Note","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Important: Like DDA dataset, see certain distributions may dominate “best fit” counts. artifact small sample size (6 observations per peptide averaged across tech reps), statement true underlying distributions. biological replicates, expect gamma lognormal distributions fit better - typical distributions mass spectrometry abundance data.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"parameter-distribution","dir":"Articles","previous_headings":"Distribution Fitting Results","what":"Parameter Distribution","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Distribution AIC values across peptides fitted distribution.","code":"p <- plot_param_distribution(fits) print(p) # Count peptides per best-fit distribution cat(\"\\nPeptides per best-fit distribution:\\n\") ##  ## Peptides per best-fit distribution: tibble(distribution = fits$best) |>   count(distribution) |>   arrange(desc(n)) ## # A tibble: 7 × 2 ##   distribution         n ##   <chr>            <int> ## 1 Pareto             273 ## 2 Gamma              103 ## 3 Normal              91 ## 4 Skew Normal         60 ## 5 Inverse Gaussian    36 ## 6 Lognormal            5 ## 7 InvGamma             2"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"choosing-the-right-statistical-test","dir":"Articles","previous_headings":"Power Analysis","what":"Choosing the Right Statistical Test","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Critical first step: small samples (N=3), test choice dramatically affects power. committing detailed analyses, compare available tests. Power comparison across statistical tests (N=3, 2-fold effect)","code":"# Run all three tests (use n_sim = 100 for faster rendering) power_wilcox <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                 find = \"power\", test = \"wilcoxon\", n_sim = 100)  power_boot <- power_analysis(fits, effect_size = 2, n_per_group = 3,                               find = \"power\", test = \"bootstrap_t\", n_sim = 100)  power_bayes <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                find = \"power\", test = \"bayes_t\", n_sim = 100)  # Create comparison table comparison <- tibble(   Test = c(\"Wilcoxon rank-sum\", \"Bootstrap-t\", \"Bayes factor\"),   `Median Power` = c(     median(power_wilcox$simulations$peptide_power, na.rm = TRUE),     median(power_boot$simulations$peptide_power, na.rm = TRUE),     median(power_bayes$simulations$peptide_power, na.rm = TRUE)   ),   `% > 50% Power` = c(     mean(power_wilcox$simulations$peptide_power > 0.5, na.rm = TRUE) * 100,     mean(power_boot$simulations$peptide_power > 0.5, na.rm = TRUE) * 100,     mean(power_bayes$simulations$peptide_power > 0.5, na.rm = TRUE) * 100   ),   `% > 80% Power` = c(     mean(power_wilcox$simulations$peptide_power > 0.8, na.rm = TRUE) * 100,     mean(power_boot$simulations$peptide_power > 0.8, na.rm = TRUE) * 100,     mean(power_bayes$simulations$peptide_power > 0.8, na.rm = TRUE) * 100   ) )  knitr::kable(comparison, digits = 2,              caption = \"Power comparison across statistical tests (N=3, 2-fold effect)\")"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"understanding-the-test-comparison-results","dir":"Articles","previous_headings":"Power Analysis","what":"Understanding the Test Comparison Results","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"table shows different tests perform small sample sizes: Wilcoxon rank-sum conservative - non-parametric tests trade statistical assumptions larger sample size requirements. Bootstrap-t uses resampling handle non-normality, potentially offering intermediate power. Bayes factor tests quantify evidence effect, often performing better small N. remaining analyses: use Bayes factor test since provides usable power estimates N=3.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"the-three-questions","dir":"Articles","previous_headings":"Power Analysis","what":"The Three Questions","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Power analysis can answer three related questions: Power: Given N effect size, power ? Sample size: Given target power effect size, N need? Minimum detectable effect: Given N target power, effect can detect?","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"question-1-what-power-do-we-have","dir":"Articles","previous_headings":"Power Analysis","what":"Question 1: What Power Do We Have?","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"3 biological replicates 2-fold effect, power achieve? Distribution power across peptides N=3 2-fold effect (Bayes factor test).","code":"# Using Bayes factor test based on comparison results power_current <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                  find = \"power\", test = \"bayes_t\", n_sim = 100) print(power_current) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Power: 60% ## Sample size: 3 per group ## Effect size: 2.00-fold ##  ## Statistical test: bayes_t ## Decision threshold: BF > 3 (substantial evidence) plot(power_current)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"question-2-what-sample-size-do-we-need","dir":"Articles","previous_headings":"Power Analysis","what":"Question 2: What Sample Size Do We Need?","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"N achieve 80% power detect 2-fold change? Percentage peptides achieving 80% power sample size.","code":"sample_size <- power_analysis(fits, effect_size = 2, target_power = 0.8,                               find = \"sample_size\", test = \"bayes_t\", n_sim = 100) print(sample_size) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Recommended sample size: N=10 per group ## Target power: 80% ## Effect size: 2.00-fold ##  ## Statistical test: bayes_t ## Decision threshold: BF > 3 (substantial evidence) plot(sample_size)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"question-3-whats-the-minimum-detectable-effect","dir":"Articles","previous_headings":"Power Analysis","what":"Question 3: What’s the Minimum Detectable Effect?","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"N=3, ’s smallest effect can reliably detect? Understanding two thresholds: per-peptide mode, two distinct thresholds: target_power (set 0.8) - power level individual peptide must achieve proportion_threshold (default 0.5) - fraction peptides must reach target_power plot shows “% peptides reaching 80% power” y-axis. answer tells us: “effect size 50% peptides achieve 80% power?” Proportion peptides reaching 80% power effect size. default threshold 50% peptides. tells us effect sizes realistically detectable current sample sizes. require peptides well-powered, increase proportion_threshold.","code":"min_effect <- power_analysis(fits, n_per_group = 3, target_power = 0.8,                              find = \"effect_size\", test = \"bayes_t\", n_sim = 100) print(min_effect) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Minimum detectable effect: 5.00-fold ## Sample size: 3 per group ## Target power: 80% ##  ## Statistical test: bayes_t ## Decision threshold: BF > 3 (substantial evidence) plot(min_effect)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"impact-of-missingness-on-power","dir":"Articles","previous_headings":"Power Analysis","what":"Impact of Missingness on Power","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"accounting missingness affect power estimates? Accounting missingness typically reduces power estimates - realistic cost missing data experiment’s ability detect effects.","code":"# Power without accounting for missingness (optimistic) power_no_miss <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                  find = \"power\", test = \"bayes_t\",                                  include_missingness = FALSE, n_sim = 100)  # Power accounting for missingness (realistic) power_with_miss <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                    find = \"power\", test = \"bayes_t\",                                    include_missingness = TRUE, n_sim = 100)  cat(\"Median power WITHOUT missingness:\",     round(median(power_no_miss$simulations$peptide_power, na.rm = TRUE), 3), \"\\n\") ## Median power WITHOUT missingness: 0.575 cat(\"Median power WITH missingness:   \",     round(median(power_with_miss$simulations$peptide_power, na.rm = TRUE), 3), \"\\n\") ## Median power WITH missingness:    0.565"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"why-fdr-matters","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Why FDR Matters","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"285 peptides tested, multiple testing concern. use alpha = 0.05 test, expect ~14 false positives chance alone (285 x 0.05 = 14.25). FDR (False Discovery Rate) control methods like Benjamini-Hochberg adjust p-values control expected proportion false discoveries. stringent nominal testing reduces power.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"understanding-prop_null","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Understanding prop_null","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"prop_null parameter specifies assumed proportion true null hypotheses - peptides real effect. affects FDR correction stringency: targeted proteomics, typically select peptides expected change, prop_null might lower discovery experiments.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"standard-vs-fdr-corrected-power","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Standard vs FDR-Corrected Power","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Note: FDR-aware mode requires frequentist tests (Wilcoxon bootstrap-t) Benjamini-Hochberg correction operates p-values. Bayes factors meaningfully converted p-values correction.","code":"# Standard power with Wilcoxon (nominal alpha = 0.05) power_nominal <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                 find = \"power\", test = \"wilcoxon\",                                 apply_fdr = FALSE, n_sim = 100)  # FDR-aware power (BH correction) # prop_null = 0.8 means we assume 80% of peptides have no true effect power_fdr <- power_analysis(fits, effect_size = 2, n_per_group = 3,                             find = \"power\", test = \"wilcoxon\",                             apply_fdr = TRUE, prop_null = 0.8,                             fdr_threshold = 0.05, n_sim = 100) # Extract power values safely nominal_power <- power_nominal$simulations$peptide_power fdr_power <- power_fdr$simulations$peptide_power  cat(\"Nominal power (Wilcoxon, no FDR correction):\\n\") ## Nominal power (Wilcoxon, no FDR correction): if (is.numeric(nominal_power) && length(nominal_power) > 0) {   cat(\"  Median power:\", round(median(nominal_power, na.rm = TRUE), 3), \"\\n\")   cat(\"  % peptides > 80% power:\", round(mean(nominal_power > 0.8, na.rm = TRUE) * 100, 1), \"%\\n\") } else {   print(power_nominal) } ##   Median power: 0  ##   % peptides > 80% power: 0 % cat(\"\\nFDR-aware power (Wilcoxon, BH correction, 80% true nulls):\\n\") ##  ## FDR-aware power (Wilcoxon, BH correction, 80% true nulls): if (is.numeric(fdr_power) && length(fdr_power) > 0) {   cat(\"  Median power:\", round(median(fdr_power, na.rm = TRUE), 3), \"\\n\")   cat(\"  % peptides > 80% power:\", round(mean(fdr_power > 0.8, na.rm = TRUE) * 100, 1), \"%\\n\") } else {   print(power_fdr) } ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Power: 0% ## Sample size: 3 per group ## Effect size: 2.00-fold ##  ## Statistical test: wilcoxon ## Significance level: 0.05 ##  ## FDR-adjusted analysis (Benjamini-Hochberg) ## Proportion true nulls: 80% ## FDR threshold: 5%"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"understanding-the-fdr-impact","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Understanding the FDR Impact","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"FDR correction reduces power : evidence required: Adjusted p-values larger, requiring stronger effects reach significance Depends number tests: peptides = stringent correction Depends true effect proportion: peptides true effects (prop_null low), FDR correction less severe targeted panel 285 peptides, FDR impact modest discovery proteomics thousands tests.","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"key-findings","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Key Findings","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Missingness patterns: PRM dataset ~17% missing values. peptides may show evidence MNAR (informative missingness), low-abundance values preferentially missing. Distribution fitting: 6 observations per peptide (averaging tech reps), distribution selection unreliable. small sample size artifact, reflection true underlying distributions. Test selection: Different statistical tests show varying power small N. Bayes factor tests can provide informative estimates conservative non-parametric tests samples limited. Missingness impact: Accounting missing data reduces power estimates - reflects real cost missingness. FDR impact: 285 peptides, FDR correction modestly reduces power compared nominal testing.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"practical-recommendations","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Practical Recommendations","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"future experiments: Consider N=6 biological replicates reliable detection 2-fold changes. current data: Set realistic expectations detectable effect sizes. Subtle changes may detectable N=3. Test selection: small samples, Bayes factor tests may informative traditional frequentist approaches. MNAR patterns: dataset-level MNAR detected, low-abundance peptide results interpreted cautiously.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"caveats","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Caveats","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"analysis combines genotypes; genotype-specific analyses may differ Technical replicate averaging reduces noise masks technical variability MNAR models approximations; true missing data mechanisms may complex prop_null parameter requires assumptions true effect rates Distribution fitting limited small sample size","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"","code":"sessionInfo() ## R version 4.5.2 (2025-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices datasets  utils     methods   base      ##  ## other attached packages: ## [1] tibble_3.3.1  ggplot2_4.0.2 dplyr_1.2.0   peppwR_0.1.0  ##  ## loaded via a namespace (and not attached): ##  [1] sass_0.4.10         utf8_1.2.6          generics_0.1.4      ##  [4] tidyr_1.3.2         renv_0.12.2         lattice_0.22-7      ##  [7] fGarch_4052.93      digest_0.6.39       magrittr_2.0.4      ## [10] evaluate_1.0.5      grid_4.5.2          RColorBrewer_1.1-3  ## [13] fastmap_1.2.0       Matrix_1.7-4        jsonlite_2.0.0      ## [16] mgcv_1.9-3          purrr_1.2.1         scales_1.4.0        ## [19] gbutils_0.5.1       textshaping_1.0.4   jquerylib_0.1.4     ## [22] Rdpack_2.6.6        cli_3.6.5           timeSeries_4052.112 ## [25] rlang_1.1.7         rbibutils_2.4.1     splines_4.5.2       ## [28] cowplot_1.2.0       intervals_0.15.5    withr_3.0.2         ## [31] cachem_1.1.0        yaml_2.3.12         cvar_0.6            ## [34] tools_4.5.2         assertthat_0.2.1    vctrs_0.7.1         ## [37] R6_2.6.1            lifecycle_1.0.5     fs_1.6.6            ## [40] univariateML_1.5.0  ragg_1.5.0          pkgconfig_2.0.3     ## [43] desc_1.4.3          pkgdown_2.2.0       pillar_1.11.1       ## [46] bslib_0.10.0        gtable_0.3.6        glue_1.8.0          ## [49] systemfonts_1.3.1   xfun_0.56           tidyselect_1.2.1    ## [52] knitr_1.51          farver_2.1.2        spatial_7.3-18      ## [55] nlme_3.1-168        htmltools_0.5.9     fBasics_4052.98     ## [58] labeling_0.4.3      rmarkdown_2.30      timeDate_4052.112   ## [61] compiler_4.5.2      S7_0.2.1"},{"path":"https://teammaclean.github.io/peppwR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dan MacLean. Author, maintainer.","code":""},{"path":"https://teammaclean.github.io/peppwR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"MacLean D (2026). peppwR: Power Analysis Phosphopeptide Abundance Hypothesis Test. R package version 0.1.0, https://teammaclean.github.io/peppwR/.","code":"@Manual{,   title = {peppwR: Power Analysis For Phosphopeptide Abundance Hypothesis Test},   author = {Dan MacLean},   year = {2026},   note = {R package version 0.1.0},   url = {https://teammaclean.github.io/peppwR/}, }"},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"peppwr-","dir":"","previous_headings":"","what":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"Power analysis phosphopeptide abundance hypothesis tests via simulation. peppwR helps proteomics researchers answer critical experimental design questions: “sample size need?” — Find N required 80% power detect given effect “’s power?” — Calculate power given sample size effect “can detect?” — Find minimum detectable effect size design","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"Distribution fitting — Fit gamma, lognormal, normal, distributions pilot data Per-peptide analysis — Get power estimates across entire peptidome Multiple statistical tests — Wilcoxon, bootstrap-t, Bayes factor t-tests Missing data handling — Model MNAR (Missing Random) patterns common proteomics FDR-aware mode — Account multiple testing correction power calculations Rich visualizations — Power curves, heatmaps, QQ plots, diagnostic plots","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"Install development version GitHub:","code":"# install.packages(\"pak\") pak::pak(\"TeamMacLean/peppwR\")"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"from-pilot-data-per-peptide-mode","dir":"","previous_headings":"Quick Start","what":"From Pilot Data (Per-Peptide Mode)","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"","code":"library(peppwR)  # Fit distributions to your pilot data fits <- fit_distributions(   pilot_data,   id = \"peptide\",   group = \"condition\",   value = \"abundance\" )  # Find required sample size for 80% power to detect 2-fold change result <- power_analysis(   fits,   effect_size = 2,   target_power = 0.8,   find = \"sample_size\" )  print(result) #> Per-peptide power analysis #> Question: sample_size #> Answer: N = 6 per group #> 73% of peptides achieve 80% power  plot(result)"},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"from-scratch-aggregate-mode","dir":"","previous_headings":"Quick Start","what":"From Scratch (Aggregate Mode)","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"pilot data? Specify assumed distribution parameters:","code":"result <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.1),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\" )"},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"Getting Started — Introduction basic usage Power Analysis Workflow — Complete workflow real data Benchmarking — Performance characteristics Function Reference — Full API documentation","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"real-world-examples","dir":"","previous_headings":"Documentation","what":"Real-World Examples","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"DDA Time Course Analysis PRM Genotype Analysis","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"workflow-overview","dir":"","previous_headings":"","what":"Workflow Overview","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"","code":"flowchart TD     A[pilot_data] --> B[fit_distributions]     B --> C[power_analysis]     C --> D{find = ?}     D --> E[\"power\"]     D --> F[\"sample_size\"]     D --> G[\"effect_size\"]     E --> H[results + plots]     F --> H     G --> H      style A fill:#FFFFCC,stroke:#BD0026     style B fill:#FD8D3C,stroke:#BD0026,color:#fff     style C fill:#FD8D3C,stroke:#BD0026,color:#fff     style H fill:#FFFFCC,stroke:#BD0026"},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"use peppwR research, please cite:","code":"MacLean, D. (2026). peppwR: Power Analysis for Phosphopeptide Abundance Hypothesis Tests. R package version 0.1.0. https://github.com/TeamMacLean/peppwR"},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"Contributions welcome! Please open issue submit pull request.","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"MIT © Dan MacLean","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/apply_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply missingness to a vector — apply_missingness","title":"Apply missingness to a vector — apply_missingness","text":"Apply missingness vector","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/apply_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply missingness to a vector — apply_missingness","text":"","code":"apply_missingness(x, na_rate, mnar_score = 0)"},{"path":"https://teammaclean.github.io/peppwR/reference/apply_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply missingness to a vector — apply_missingness","text":"x Numeric vector na_rate Proportion make NA mnar_score MNAR intensity (0 = MCAR)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/apply_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply missingness to a vector — apply_missingness","text":"Vector values replaced NA","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/bf_jzs.html","id":null,"dir":"Reference","previous_headings":"","what":"JZS Bayes factor approximation — bf_jzs","title":"JZS Bayes factor approximation — bf_jzs","text":"JZS Bayes factor approximation","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/bf_jzs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"JZS Bayes factor approximation — bf_jzs","text":"","code":"bf_jzs(t, n1, n2)"},{"path":"https://teammaclean.github.io/peppwR/reference/bf_jzs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"JZS Bayes factor approximation — bf_jzs","text":"t t-statistic n1 Sample size group 1 n2 Sample size group 2","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/bf_jzs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"JZS Bayes factor approximation — bf_jzs","text":"Bayes factor","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_dataset_mnar.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute dataset-level MNAR metric — compute_dataset_mnar","title":"Compute dataset-level MNAR metric — compute_dataset_mnar","text":"Calculates Spearman correlation log(mean_abundance) NA rate across peptides detect whether low-abundance peptides missing values high-abundance peptides.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_dataset_mnar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute dataset-level MNAR metric — compute_dataset_mnar","text":"","code":"compute_dataset_mnar(missingness)"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_dataset_mnar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute dataset-level MNAR metric — compute_dataset_mnar","text":"missingness tibble columns na_rate mean_abundance (produced fit_distributions)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_dataset_mnar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute dataset-level MNAR metric — compute_dataset_mnar","text":"list : correlation: Spearman correlation coefficient (negative = MNAR pattern) p_value: p-value correlation n_peptides: Number peptides missing data used calculation interpretation: Human-readable interpretation string","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_dataset_mnar.html","id":"mnar-detection","dir":"Reference","previous_headings":"","what":"MNAR Detection","title":"Compute dataset-level MNAR metric — compute_dataset_mnar","text":"MNAR (Missing Random) mass spectrometry typically manifests low-abundance peptides higher rates missing values due detection limits. function detects pattern correlating mean abundance NA rate across peptides. negative correlation indicates low-abundance peptides missing values - hallmark detection-limit-driven MNAR.","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/reference/compute_fitted_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute fitted density values — compute_fitted_density","title":"Compute fitted density values — compute_fitted_density","text":"Compute fitted density values","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_fitted_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute fitted density values — compute_fitted_density","text":"","code":"compute_fitted_density(raw_vals, dist_name, x_range)"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_fitted_density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute fitted density values — compute_fitted_density","text":"raw_vals Raw observed values dist_name Distribution name x_range X values compute density ","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_fitted_density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute fitted density values — compute_fitted_density","text":"Density values NULL failure","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute missingness statistics for a vector of values — compute_missingness","title":"Compute missingness statistics for a vector of values — compute_missingness","text":"Calculates number proportion missing (NA) values.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute missingness statistics for a vector of values — compute_missingness","text":"","code":"compute_missingness(values)"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute missingness statistics for a vector of values — compute_missingness","text":"values Numeric vector (may contain NAs)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute missingness statistics for a vector of values — compute_missingness","text":"List : n_total: Total number values n_missing: Number NA values na_rate: Proportion missing (0-1)","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/reference/compute_perpeptide_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute per-peptide power (helper for plot_power_vs_effect) — compute_perpeptide_power","title":"Compute per-peptide power (helper for plot_power_vs_effect) — compute_perpeptide_power","text":"Compute per-peptide power (helper plot_power_vs_effect)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_perpeptide_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute per-peptide power (helper for plot_power_vs_effect) — compute_perpeptide_power","text":"","code":"compute_perpeptide_power(   fits_data,   n_per_group,   effect_size,   alpha,   test,   n_sim )"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_qq_points.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute QQ points for a distribution fit — compute_qq_points","title":"Compute QQ points for a distribution fit — compute_qq_points","text":"Compute QQ points distribution fit","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_qq_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute QQ points for a distribution fit — compute_qq_points","text":"","code":"compute_qq_points(raw_vals, dist_name)"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_qq_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute QQ points for a distribution fit — compute_qq_points","text":"raw_vals Raw observed values dist_name Distribution name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_qq_points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute QQ points for a distribution fit — compute_qq_points","text":"List theoretical sample quantiles, NULL","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_t_stat.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute t-statistic for two groups — compute_t_stat","title":"Compute t-statistic for two groups — compute_t_stat","text":"Compute t-statistic two groups","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_t_stat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute t-statistic for two groups — compute_t_stat","text":"","code":"compute_t_stat(x, y)"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_t_stat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute t-statistic for two groups — compute_t_stat","text":"x First group y Second group","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_t_stat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute t-statistic for two groups — compute_t_stat","text":"t-statistic","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_effect_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Find minimum detectable effect size — find_effect_size","title":"Find minimum detectable effect size — find_effect_size","text":"Find minimum detectable effect size","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_effect_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find minimum detectable effect size — find_effect_size","text":"","code":"find_effect_size(   distribution,   params,   n_per_group,   target_power,   alpha,   test,   n_sim )"},{"path":"https://teammaclean.github.io/peppwR/reference/find_effect_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find minimum detectable effect size — find_effect_size","text":"distribution Distribution name params Distribution parameters n_per_group Sample size per group target_power Target power level alpha Significance level test Statistical test n_sim Number simulations per effect size","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_effect_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find minimum detectable effect size — find_effect_size","text":"List effect_size effect_curve","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_sample_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Find required sample size for target power — find_sample_size","title":"Find required sample size for target power — find_sample_size","text":"Find required sample size target power","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_sample_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find required sample size for target power — find_sample_size","text":"","code":"find_sample_size(   distribution,   params,   effect_size,   target_power,   alpha,   test,   n_sim )"},{"path":"https://teammaclean.github.io/peppwR/reference/find_sample_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find required sample size for target power — find_sample_size","text":"distribution Distribution name params Distribution parameters effect_size Effect size detect target_power Target power level alpha Significance level test Statistical test n_sim Number simulations per sample size","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_sample_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find required sample size for target power — find_sample_size","text":"List n power_curve","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/fit_distributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit distributions to peptide abundance data — fit_distributions","title":"Fit distributions to peptide abundance data — fit_distributions","text":"Fits candidate distributions peptide's abundance values selects best fit AIC. Also computes missingness statistics including dataset-level MNAR detection.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/fit_distributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit distributions to peptide abundance data — fit_distributions","text":"","code":"fit_distributions(data, id, group, value, distributions = \"continuous\")"},{"path":"https://teammaclean.github.io/peppwR/reference/fit_distributions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit distributions to peptide abundance data — fit_distributions","text":"data data frame containing peptide abundance data id Column name peptide identifier group Column name group/condition value Column name abundance values distributions distributions fit: \"continuous\" (default), \"counts\", \"\", character vector distribution names","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/fit_distributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit distributions to peptide abundance data — fit_distributions","text":"peppwr_fits object containing: $data: Nested tibble original data fit results $best: Best-fitting distribution peptide $missingness: Per-peptide missingness statistics $dataset_mnar: Dataset-level MNAR correlation interpretation","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/fit_distributions.html","id":"missingness-tracking","dir":"Reference","previous_headings":"","what":"Missingness Tracking","title":"Fit distributions to peptide abundance data — fit_distributions","text":"returned object includes: Per-peptide NA rates ($missingness) Dataset-level MNAR correlation ($dataset_mnar) dataset-level MNAR metric correlates log(mean_abundance) NA rate across peptides. negative correlation indicates low-abundance peptides missing values - typical detection-limit-driven MNAR. Print result see metrics. small sample sizes (N < 15), dataset-level correlation reliable per-peptide scores.","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/reference/format_answer.html","id":null,"dir":"Reference","previous_headings":"","what":"Format answer based on question type — format_answer","title":"Format answer based on question type — format_answer","text":"Format answer based question type","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/format_answer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format answer based on question type — format_answer","text":"","code":"format_answer(answer, question)"},{"path":"https://teammaclean.github.io/peppwR/reference/format_answer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format answer based on question type — format_answer","text":"answer answer value question question type","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/format_answer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format answer based on question type — format_answer","text":"Formatted string","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dfunc.html","id":null,"dir":"Reference","previous_headings":"","what":"Get density function for a distribution — get_dfunc","title":"Get density function for a distribution — get_dfunc","text":"Get density function distribution","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dfunc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get density function for a distribution — get_dfunc","text":"","code":"get_dfunc(distribution)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_dfunc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get density function for a distribution — get_dfunc","text":"distribution Distribution name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dfunc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get density function for a distribution — get_dfunc","text":"Density function","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dist_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Get distribution parameters from fitted results — get_dist_params","title":"Get distribution parameters from fitted results — get_dist_params","text":"Get distribution parameters fitted results","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dist_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get distribution parameters from fitted results — get_dist_params","text":"","code":"get_dist_params(dist_name, fit_df, raw_data)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_dist_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get distribution parameters from fitted results — get_dist_params","text":"dist_name Distribution name fit_df Fit results data frame raw_data Raw data values","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dist_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get distribution parameters from fitted results — get_dist_params","text":"List parameters","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_distribution_preset.html","id":null,"dir":"Reference","previous_headings":"","what":"Get distributions for a preset — get_distribution_preset","title":"Get distributions for a preset — get_distribution_preset","text":"Get distributions preset","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_distribution_preset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get distributions for a preset — get_distribution_preset","text":"","code":"get_distribution_preset(preset = \"continuous\")"},{"path":"https://teammaclean.github.io/peppwR/reference/get_distribution_preset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get distributions for a preset — get_distribution_preset","text":"preset One \"continuous\" (default), \"counts\", \"\"","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_distribution_preset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get distributions for a preset — get_distribution_preset","text":"Character vector distribution names","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_qfunc.html","id":null,"dir":"Reference","previous_headings":"","what":"Get quantile function for a distribution — get_qfunc","title":"Get quantile function for a distribution — get_qfunc","text":"Get quantile function distribution","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_qfunc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get quantile function for a distribution — get_qfunc","text":"","code":"get_qfunc(distribution)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_qfunc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get quantile function for a distribution — get_qfunc","text":"distribution Distribution name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_qfunc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get quantile function for a distribution — get_qfunc","text":"Quantile function","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_rfunc.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the random generation function for a distribution — get_rfunc","title":"Get the random generation function for a distribution — get_rfunc","text":"Get random generation function distribution","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_rfunc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the random generation function for a distribution — get_rfunc","text":"","code":"get_rfunc(distribution)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_rfunc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the random generation function for a distribution — get_rfunc","text":"distribution Distribution name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_rfunc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the random generation function for a distribution — get_rfunc","text":"Random generation function","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_test_func.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the test function for a given test name — get_test_func","title":"Get the test function for a given test name — get_test_func","text":"Get test function given test name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_test_func.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the test function for a given test name — get_test_func","text":"","code":"get_test_func(test)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_test_func.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the test function for a given test name — get_test_func","text":"test Test name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_test_func.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the test function for a given test name — get_test_func","text":"Test function","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/interpret_dataset_mnar.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpret dataset-level MNAR result — interpret_dataset_mnar","title":"Interpret dataset-level MNAR result — interpret_dataset_mnar","text":"Interpret dataset-level MNAR result","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/interpret_dataset_mnar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpret dataset-level MNAR result — interpret_dataset_mnar","text":"","code":"interpret_dataset_mnar(correlation, p_value, n_peptides)"},{"path":"https://teammaclean.github.io/peppwR/reference/interpret_dataset_mnar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpret dataset-level MNAR result — interpret_dataset_mnar","text":"correlation Spearman correlation coefficient p_value p-value correlation n_peptides Number peptides calculation","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/interpret_dataset_mnar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpret dataset-level MNAR result — interpret_dataset_mnar","text":"Interpretation string","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/is_count_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if data appears to be count data (non-negative integers) — is_count_data","title":"Check if data appears to be count data (non-negative integers) — is_count_data","text":"Check data appears count data (non-negative integers)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/is_count_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if data appears to be count data (non-negative integers) — is_count_data","text":"","code":"is_count_data(x)"},{"path":"https://teammaclean.github.io/peppwR/reference/is_count_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if data appears to be count data (non-negative integers) — is_count_data","text":"x Numeric vector","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/is_count_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if data appears to be count data (non-negative integers) — is_count_data","text":"TRUE data looks like counts, FALSE otherwise","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/map_dist_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Map distribution name to R function prefix — map_dist_name","title":"Map distribution name to R function prefix — map_dist_name","text":"Map distribution name R function prefix","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/map_dist_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map distribution name to R function prefix — map_dist_name","text":"","code":"map_dist_name(dist_name)"},{"path":"https://teammaclean.github.io/peppwR/reference/map_dist_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map distribution name to R function prefix — map_dist_name","text":"dist_name Distribution name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/map_dist_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map distribution name to R function prefix — map_dist_name","text":"R function name random generation","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new peppwr_fits object — new_peppwr_fits","title":"Create a new peppwr_fits object — new_peppwr_fits","text":"Create new peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new peppwr_fits object — new_peppwr_fits","text":"","code":"new_peppwr_fits(   data,   fits,   best,   call,   missingness = NULL,   dataset_mnar = NULL )"},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new peppwr_fits object — new_peppwr_fits","text":"data Original data (nested tibble) fits Fit results per peptide (list tibbles dist, loglik, aic) best Best-fitting distribution per peptide (character vector) call Original function call missingness Tibble missingness statistics per peptide (optional) dataset_mnar Dataset-level MNAR metric (optional, compute_dataset_mnar)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new peppwr_fits object — new_peppwr_fits","text":"peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new peppwr_power object — new_peppwr_power","title":"Create a new peppwr_power object — new_peppwr_power","text":"Create new peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new peppwr_power object — new_peppwr_power","text":"","code":"new_peppwr_power(mode, question, answer, simulations, params, call)"},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new peppwr_power object — new_peppwr_power","text":"mode Either \"aggregate\" \"per_peptide\" question solved : \"power\", \"sample_size\", \"effect_size\" answer computed answer simulations List simulation details params List input parameters used call Original function call","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new peppwr_power object — new_peppwr_power","text":"peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for peppwr_fits — plot.peppwr_fits","title":"Plot method for peppwr_fits — plot.peppwr_fits","text":"Creates bar chart showing count best-fit distributions","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for peppwr_fits — plot.peppwr_fits","text":"","code":"# S3 method for class 'peppwr_fits' plot(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for peppwr_fits — plot.peppwr_fits","text":"x peppwr_fits object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for peppwr_fits — plot.peppwr_fits","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for peppwr_power — plot.peppwr_power","title":"Plot method for peppwr_power — plot.peppwr_power","text":"Creates power curves % peptides threshold plots","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for peppwr_power — plot.peppwr_power","text":"","code":"# S3 method for class 'peppwr_power' plot(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for peppwr_power — plot.peppwr_power","text":"x peppwr_power object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for peppwr_power — plot.peppwr_power","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_density_overlay.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot density overlay: observed histogram with fitted density curve — plot_density_overlay","title":"Plot density overlay: observed histogram with fitted density curve — plot_density_overlay","text":"Plot density overlay: observed histogram fitted density curve","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_density_overlay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot density overlay: observed histogram with fitted density curve — plot_density_overlay","text":"","code":"plot_density_overlay(fits, peptide_id = NULL, n_overlay = 6)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_density_overlay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot density overlay: observed histogram with fitted density curve — plot_density_overlay","text":"fits peppwr_fits object peptide_id Specific peptide plot (NULL multiple) n_overlay Number peptides overlay peptide_id NULL","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_density_overlay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot density overlay: observed histogram with fitted density curve — plot_density_overlay","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot missingness statistics — plot_missingness","title":"Plot missingness statistics — plot_missingness","text":"Creates visualization missing data patterns two panels:","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot missingness statistics — plot_missingness","text":"","code":"plot_missingness(fits)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot missingness statistics — plot_missingness","text":"fits peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot missingness statistics — plot_missingness","text":"ggplot object gtable (combined panels)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_missingness.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot missingness statistics — plot_missingness","text":"Panel 1: Distribution NA rates across peptides Panel 2: Mean abundance vs NA rate scatter plot showing dataset-level MNAR correlation. subtitle displays Spearman correlation coefficient p-value. negative correlation indicates low-abundance peptides missing values - hallmark detection-limit-driven MNAR.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_missingness.html","id":"mnar-detection","dir":"Reference","previous_headings":"","what":"MNAR Detection","title":"Plot missingness statistics — plot_missingness","text":"MNAR (Missing Random) mass spectrometry typically manifests low-abundance peptides higher rates missing values due detection limits. Panel 2 visualizes relationship reports correlation coefficient.","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/reference/plot_param_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot distribution of fitted parameters across peptidome — plot_param_distribution","title":"Plot distribution of fitted parameters across peptidome — plot_param_distribution","text":"Plot distribution fitted parameters across peptidome","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_param_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot distribution of fitted parameters across peptidome — plot_param_distribution","text":"","code":"plot_param_distribution(fits)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_param_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot distribution of fitted parameters across peptidome — plot_param_distribution","text":"fits peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_param_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot distribution of fitted parameters across peptidome — plot_param_distribution","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_aggregate.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot power curve for aggregate mode — plot_power_aggregate","title":"Plot power curve for aggregate mode — plot_power_aggregate","text":"Plot power curve aggregate mode","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_aggregate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot power curve for aggregate mode — plot_power_aggregate","text":"","code":"plot_power_aggregate(x)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_aggregate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot power curve for aggregate mode — plot_power_aggregate","text":"x peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_aggregate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot power curve for aggregate mode — plot_power_aggregate","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_heatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot power heatmap: N x effect size grid — plot_power_heatmap","title":"Plot power heatmap: N x effect size grid — plot_power_heatmap","text":"Plot power heatmap: N x effect size grid","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_heatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot power heatmap: N x effect size grid — plot_power_heatmap","text":"","code":"plot_power_heatmap(   distribution,   params,   n_range,   effect_range,   n_steps = 6,   n_sim = 100,   test = \"wilcoxon\",   alpha = 0.05 )"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_heatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot power heatmap: N x effect size grid — plot_power_heatmap","text":"distribution Distribution name params Distribution parameters n_range Range sample sizes (vector length 2) effect_range Range effect sizes (vector length 2) n_steps Number grid points per dimension n_sim Number simulations per grid cell test Statistical test use alpha Significance level","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_heatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot power heatmap: N x effect size grid — plot_power_heatmap","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_perpeptide.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot % peptides at threshold for per-peptide mode — plot_power_perpeptide","title":"Plot % peptides at threshold for per-peptide mode — plot_power_perpeptide","text":"Plot % peptides threshold per-peptide mode","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_perpeptide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot % peptides at threshold for per-peptide mode — plot_power_perpeptide","text":"","code":"plot_power_perpeptide(x)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_perpeptide.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot % peptides at threshold for per-peptide mode — plot_power_perpeptide","text":"x peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_perpeptide.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot % peptides at threshold for per-peptide mode — plot_power_perpeptide","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_vs_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot power vs effect size at fixed N — plot_power_vs_effect","title":"Plot power vs effect size at fixed N — plot_power_vs_effect","text":"Plot power vs effect size fixed N","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_vs_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot power vs effect size at fixed N — plot_power_vs_effect","text":"","code":"plot_power_vs_effect(power_result, effect_range, n_steps = 10, n_sim = NULL)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_vs_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot power vs effect size at fixed N — plot_power_vs_effect","text":"power_result peppwr_power object effect_range Range effect sizes explore n_steps Number effect size values compute n_sim Number simulations per point","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_vs_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot power vs effect size at fixed N — plot_power_vs_effect","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_qq.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot QQ plots for goodness-of-fit — plot_qq","title":"Plot QQ plots for goodness-of-fit — plot_qq","text":"Plot QQ plots goodness--fit","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_qq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot QQ plots for goodness-of-fit — plot_qq","text":"","code":"plot_qq(fits, peptide_id = NULL, n_plots = 6)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_qq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot QQ plots for goodness-of-fit — plot_qq","text":"fits peppwr_fits object peptide_id Specific peptide plot (NULL multiple) n_plots Number peptides plot peptide_id NULL","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_qq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot QQ plots for goodness-of-fit — plot_qq","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.character.html","id":null,"dir":"Reference","previous_headings":"","what":"Power analysis with specified distribution (aggregate mode) — power_analysis.character","title":"Power analysis with specified distribution (aggregate mode) — power_analysis.character","text":"Power analysis specified distribution (aggregate mode) Default power analysis method (aggregate mode defaults)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power analysis with specified distribution (aggregate mode) — power_analysis.character","text":"","code":"# S3 method for class 'character' power_analysis(   distribution,   params,   effect_size = NULL,   n_per_group = NULL,   target_power = NULL,   alpha = 0.05,   test = \"wilcoxon\",   find = \"power\",   n_sim = 1000,   ... )  # Default S3 method power_analysis(distribution, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power analysis with specified distribution (aggregate mode) — power_analysis.character","text":"distribution Distribution name (e.g., \"norm\", \"gamma\", \"lnorm\") params List distribution parameters effect_size Fold change detect n_per_group Sample size per group (required find=\"power\") target_power Target power (required find=\"sample_size\" find=\"effect_size\") alpha Significance level (default 0.05) test Statistical test use (default \"wilcoxon\") find solve : \"power\", \"sample_size\", \"effect_size\" n_sim Number simulations (default 1000) ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power analysis with specified distribution (aggregate mode) — power_analysis.character","text":"peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.html","id":null,"dir":"Reference","previous_headings":"","what":"Power analysis for peptide abundance data — power_analysis","title":"Power analysis for peptide abundance data — power_analysis","text":"Power analysis peptide abundance data","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power analysis for peptide abundance data — power_analysis","text":"","code":"power_analysis(distribution, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power analysis for peptide abundance data — power_analysis","text":"distribution Distribution name (character) peppwr_fits object per-peptide mode ... Additional arguments","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power analysis for peptide abundance data — power_analysis","text":"peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Power analysis for per-peptide mode using fitted distributions — power_analysis.peppwr_fits","title":"Power analysis for per-peptide mode using fitted distributions — power_analysis.peppwr_fits","text":"Power analysis per-peptide mode using fitted distributions","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power analysis for per-peptide mode using fitted distributions — power_analysis.peppwr_fits","text":"","code":"# S3 method for class 'peppwr_fits' power_analysis(   distribution,   effect_size = NULL,   n_per_group = NULL,   target_power = NULL,   alpha = 0.05,   test = \"wilcoxon\",   find = \"power\",   n_sim = 1000,   on_fit_failure = \"exclude\",   proportion_threshold = 0.5,   include_missingness = FALSE,   apply_fdr = FALSE,   prop_null = 0.9,   fdr_threshold = 0.05,   ... )"},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power analysis for per-peptide mode using fitted distributions — power_analysis.peppwr_fits","text":"distribution peppwr_fits object fit_distributions() effect_size Fold change detect n_per_group Sample size per group (required find=\"power\") target_power Target power (required find=\"sample_size\") alpha Significance level (default 0.05) test Statistical test use (default \"wilcoxon\") find solve : \"power\" \"sample_size\" n_sim Number simulations per peptide (default 1000) on_fit_failure handle failed fits: \"exclude\", \"empirical\", \"lognormal\" proportion_threshold Proportion peptides must reach target_power (default 0.5) include_missingness TRUE, incorporate peptide-specific NA rates simulations apply_fdr TRUE, use FDR-aware simulation Benjamini-Hochberg correction. Note: compatible test = \"bayes_t\" (Bayes factors converted p-values) prop_null Proportion true null peptides (default 0.9 = 90% unchanged) fdr_threshold FDR threshold calling discoveries (default 0.05) ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power analysis for per-peptide mode using fitted distributions — power_analysis.peppwr_fits","text":"peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for peppwr_fits — print.peppwr_fits","title":"Print method for peppwr_fits — print.peppwr_fits","text":"Print method peppwr_fits","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for peppwr_fits — print.peppwr_fits","text":"","code":"# S3 method for class 'peppwr_fits' print(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for peppwr_fits — print.peppwr_fits","text":"x peppwr_fits object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for peppwr_fits — print.peppwr_fits","text":"object invisibly","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for peppwr_power — print.peppwr_power","title":"Print method for peppwr_power — print.peppwr_power","text":"Print method peppwr_power","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for peppwr_power — print.peppwr_power","text":"","code":"# S3 method for class 'peppwr_power' print(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for peppwr_power — print.peppwr_power","text":"x peppwr_power object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for peppwr_power — print.peppwr_power","text":"object invisibly","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary.peppwr_fits — print.summary.peppwr_fits","title":"Print method for summary.peppwr_fits — print.summary.peppwr_fits","text":"Print method summary.peppwr_fits","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary.peppwr_fits — print.summary.peppwr_fits","text":"","code":"# S3 method for class 'summary.peppwr_fits' print(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary.peppwr_fits — print.summary.peppwr_fits","text":"x summary.peppwr_fits object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for summary.peppwr_fits — print.summary.peppwr_fits","text":"object invisibly","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary.peppwr_power — print.summary.peppwr_power","title":"Print method for summary.peppwr_power — print.summary.peppwr_power","text":"Print method summary.peppwr_power","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary.peppwr_power — print.summary.peppwr_power","text":"","code":"# S3 method for class 'summary.peppwr_power' print(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary.peppwr_power — print.summary.peppwr_power","text":"x summary.peppwr_power object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for summary.peppwr_power — print.summary.peppwr_power","text":"object invisibly","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Run power simulation — run_power_sim","title":"Run power simulation — run_power_sim","text":"Run power simulation","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run power simulation — run_power_sim","text":"","code":"run_power_sim(   distribution,   params,   n_per_group,   effect_size,   alpha = 0.05,   test = \"wilcoxon\",   n_sim = 1000 )"},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run power simulation — run_power_sim","text":"distribution Distribution name params List distribution parameters n_per_group Number samples per group effect_size Fold change treatment alpha Significance level test Statistical test use (\"wilcoxon\", \"bootstrap_t\", \"bayes_t\", \"rankprod\") n_sim Number simulations","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run power simulation — run_power_sim","text":"Power estimate (proportion significant results)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_empirical.html","id":null,"dir":"Reference","previous_headings":"","what":"Run power simulation using empirical bootstrap — run_power_sim_empirical","title":"Run power simulation using empirical bootstrap — run_power_sim_empirical","text":"Estimates power repeatedly resampling observed data rather sampling fitted distributions.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_empirical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run power simulation using empirical bootstrap — run_power_sim_empirical","text":"","code":"run_power_sim_empirical(   raw_data,   n_per_group,   effect_size,   alpha = 0.05,   test = \"wilcoxon\",   n_sim = 1000 )"},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_empirical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run power simulation using empirical bootstrap — run_power_sim_empirical","text":"raw_data Numeric vector observed values n_per_group Number samples per group effect_size Fold change treatment alpha Significance level test Statistical test use n_sim Number simulations","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_empirical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run power simulation using empirical bootstrap — run_power_sim_empirical","text":"Power estimate (proportion significant results)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_fdr.html","id":null,"dir":"Reference","previous_headings":"","what":"Run FDR-aware power simulation for whole peptidome — run_power_sim_fdr","title":"Run FDR-aware power simulation for whole peptidome — run_power_sim_fdr","text":"Simulates entire peptidome experiment mix true nulls true alternatives, applies Benjamini-Hochberg correction compute FDR-adjusted power.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_fdr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run FDR-aware power simulation for whole peptidome — run_power_sim_fdr","text":"","code":"run_power_sim_fdr(   fits,   effect_size,   n_per_group,   prop_null = 0.9,   fdr_threshold = 0.05,   alpha = 0.05,   test = \"wilcoxon\",   n_sim = 1000 )"},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_fdr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run FDR-aware power simulation for whole peptidome — run_power_sim_fdr","text":"fits peppwr_fits object effect_size Fold change treatment n_per_group Number samples per group prop_null Proportion peptides true nulls (effect). Default 0.9 (90% unchanged). fdr_threshold FDR threshold calling discoveries. Default 0.05. alpha Nominal significance level (used simulation). Default 0.05. test Statistical test use. Default \"wilcoxon\". n_sim Number simulation iterations. Default 1000.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_fdr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run FDR-aware power simulation for whole peptidome — run_power_sim_fdr","text":"FDR-adjusted power estimate (proportion true alternatives detected)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_with_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Run power simulation with missingness — run_power_sim_with_missingness","title":"Run power simulation with missingness — run_power_sim_with_missingness","text":"Estimates power accounting realistic missing data patterns.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_with_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run power simulation with missingness — run_power_sim_with_missingness","text":"","code":"run_power_sim_with_missingness(   distribution,   params,   n_per_group,   effect_size,   na_rate = 0,   mnar_score = 0,   alpha = 0.05,   test = \"wilcoxon\",   n_sim = 1000 )"},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_with_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run power simulation with missingness — run_power_sim_with_missingness","text":"distribution Distribution name params List distribution parameters n_per_group Number samples per group effect_size Fold change treatment na_rate Proportion values NA mnar_score MNAR intensity (0 = MCAR) alpha Significance level test Statistical test use n_sim Number simulations","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_with_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run power simulation with missingness — run_power_sim_with_missingness","text":"Power estimate (proportion significant results)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_empirical.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate experiment using empirical bootstrap — simulate_empirical","title":"Simulate experiment using empirical bootstrap — simulate_empirical","text":"Resamples observed data instead using parametric distributions. Useful distribution fitting fails non-parametric analysis.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_empirical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate experiment using empirical bootstrap — simulate_empirical","text":"","code":"simulate_empirical(raw_data, n_per_group, effect_size)"},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_empirical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate experiment using empirical bootstrap — simulate_empirical","text":"raw_data Numeric vector observed values n_per_group Number samples per group effect_size Fold change treatment (multiplicative effect)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_empirical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate experiment using empirical bootstrap — simulate_empirical","text":"List control treatment vectors","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_experiment.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate an experiment with control and treatment groups — simulate_experiment","title":"Simulate an experiment with control and treatment groups — simulate_experiment","text":"Simulate experiment control treatment groups","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_experiment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate an experiment with control and treatment groups — simulate_experiment","text":"","code":"simulate_experiment(distribution, params, n_per_group, effect_size)"},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_experiment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate an experiment with control and treatment groups — simulate_experiment","text":"distribution Distribution name (e.g., \"norm\", \"gamma\", \"lnorm\") params List distribution parameters n_per_group Number samples per group effect_size Fold change treatment (multiplicative effect)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_experiment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate an experiment with control and treatment groups — simulate_experiment","text":"List control treatment vectors","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_with_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate experiment with realistic missingness — simulate_with_missingness","title":"Simulate experiment with realistic missingness — simulate_with_missingness","text":"Generates control treatment samples distribution, introduces missing values according specified rate MNAR pattern.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_with_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate experiment with realistic missingness — simulate_with_missingness","text":"","code":"simulate_with_missingness(   distribution,   params,   n_per_group,   effect_size,   na_rate = 0,   mnar_score = 0 )"},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_with_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate experiment with realistic missingness — simulate_with_missingness","text":"distribution Distribution name (e.g., \"norm\", \"gamma\", \"lnorm\") params List distribution parameters n_per_group Number samples per group effect_size Fold change treatment (multiplicative effect) na_rate Proportion values make NA (0-1) mnar_score MNAR intensity: 0 = MCAR, positive = low values likely missing. Typical values: 0-3.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_with_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate experiment with realistic missingness — simulate_with_missingness","text":"List control treatment vectors (may contain NAs)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for peppwr_fits — summary.peppwr_fits","title":"Summary method for peppwr_fits — summary.peppwr_fits","text":"Summary method peppwr_fits","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for peppwr_fits — summary.peppwr_fits","text":"","code":"# S3 method for class 'peppwr_fits' summary(object, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for peppwr_fits — summary.peppwr_fits","text":"object peppwr_fits object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for peppwr_fits — summary.peppwr_fits","text":"list summary statistics","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for peppwr_power — summary.peppwr_power","title":"Summary method for peppwr_power — summary.peppwr_power","text":"Summary method peppwr_power","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for peppwr_power — summary.peppwr_power","text":"","code":"# S3 method for class 'peppwr_power' summary(object, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for peppwr_power — summary.peppwr_power","text":"object peppwr_power object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for peppwr_power — summary.peppwr_power","text":"list summary statistics","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bayes_t.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayes factor t-test — test_bayes_t","title":"Bayes factor t-test — test_bayes_t","text":"Computes Bayes factor difference two groups","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bayes_t.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayes factor t-test — test_bayes_t","text":"","code":"test_bayes_t(control, treatment)"},{"path":"https://teammaclean.github.io/peppwR/reference/test_bayes_t.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayes factor t-test — test_bayes_t","text":"control Control group values treatment Treatment group values","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bayes_t.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayes factor t-test — test_bayes_t","text":"Bayes factor (BF10: evidence alternative null)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bootstrap_t.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap-t test — test_bootstrap_t","title":"Bootstrap-t test — test_bootstrap_t","text":"Performs bootstrap-t test comparing two groups","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bootstrap_t.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap-t test — test_bootstrap_t","text":"","code":"test_bootstrap_t(control, treatment, n_boot = 1000)"},{"path":"https://teammaclean.github.io/peppwR/reference/test_bootstrap_t.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap-t test — test_bootstrap_t","text":"control Control group values treatment Treatment group values n_boot Number bootstrap iterations (default 1000)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bootstrap_t.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap-t test — test_bootstrap_t","text":"p-value test","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_rankprod.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank Products test — test_rankprod","title":"Rank Products test — test_rankprod","text":"Performs rank products test comparing two groups Simplified implementation two-group comparison","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_rankprod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank Products test — test_rankprod","text":"","code":"test_rankprod(control, treatment, n_perm = 1000)"},{"path":"https://teammaclean.github.io/peppwR/reference/test_rankprod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank Products test — test_rankprod","text":"control Control group values treatment Treatment group values n_perm Number permutations p-value estimation (default 1000)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_rankprod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rank Products test — test_rankprod","text":"p-value test","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_wilcoxon.html","id":null,"dir":"Reference","previous_headings":"","what":"Wilcoxon rank-sum test — test_wilcoxon","title":"Wilcoxon rank-sum test — test_wilcoxon","text":"Wilcoxon rank-sum test","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_wilcoxon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wilcoxon rank-sum test — test_wilcoxon","text":"","code":"test_wilcoxon(control, treatment)"},{"path":"https://teammaclean.github.io/peppwR/reference/test_wilcoxon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wilcoxon rank-sum test — test_wilcoxon","text":"control Control group values treatment Treatment group values","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_wilcoxon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wilcoxon rank-sum test — test_wilcoxon","text":"p-value test","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate a peppwr_fits object — validate_peppwr_fits","title":"Validate a peppwr_fits object — validate_peppwr_fits","text":"Validate peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate a peppwr_fits object — validate_peppwr_fits","text":"","code":"validate_peppwr_fits(x)"},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate a peppwr_fits object — validate_peppwr_fits","text":"x Object validate","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate a peppwr_fits object — validate_peppwr_fits","text":"validated object (invisibly)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate a peppwr_power object — validate_peppwr_power","title":"Validate a peppwr_power object — validate_peppwr_power","text":"Validate peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate a peppwr_power object — validate_peppwr_power","text":"","code":"validate_peppwr_power(x)"},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate a peppwr_power object — validate_peppwr_power","text":"x Object validate","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate a peppwr_power object — validate_peppwr_power","text":"validated object (invisibly)","code":""},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"the-problem","dir":"","previous_headings":"","what":"The Problem","title":"NA","text":"Traditional AI-assisted development friction: - Human stays loop every iteration - Unclear “done” actually done - Context gets consumed discussion implementation - Repeated clarification questions","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"phase-1-discuss","dir":"","previous_headings":"The Solution: Discuss → TDD → Ralph Loop","what":"Phase 1: Discuss","title":"NA","text":"Goal: Reach shared understanding requirements code. Human describes feature/bug Claude asks clarifying questions Agree scope, edge cases, “done” looks like Identify relevant files architecture patterns Output: Clear requirements can expressed test.","code":""},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"phase-2-tdd-write-failing-test-first","dir":"","previous_headings":"The Solution: Discuss → TDD → Ralph Loop","what":"Phase 2: TDD (Write Failing Test First)","title":"NA","text":"Goal: Create objective, automated definition “done”. Claude writes test captures requirement Run test confirm fails (red) test spec - ambiguity completion Key principle: implementation code test exists fails.","code":""},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"phase-3-ralph-loop-autonomous-implementation","dir":"","previous_headings":"The Solution: Discuss → TDD → Ralph Loop","what":"Phase 3: Ralph Loop (Autonomous Implementation)","title":"NA","text":"Goal: Claude iterates autonomously tests pass. happens: 1. Claude works implementation 2. Runs verification command 3. tests fail, continues iterating 4. tests pass, outputs promise tag loop exits 5. Human final smoke test","code":"/ralph-loop \"Implement [feature description].  ## Failing Test tests/e2e/my-feature.test.ts  ## Relevant Files - src/lib/services/foo.ts - src/lib/components/Bar.svelte  ## Verification npx playwright test my-feature.test.ts Must show: X passed  ## Success Criteria All tests pass.\" --completion-promise \"FEATURE-COMPLETE\" --max-iterations 20"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"clear-context-before-ralph-loop","dir":"","previous_headings":"Context Management","what":"Clear Context Before Ralph Loop","title":"NA","text":"Discussion consumes context. starting Ralph Loop: Commit failing test (preserves spec files) Start fresh Claude session use /clear Run Ralph Loop full context available implementation ensures Claude maximum context actual work, filled discussion history.","code":""},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"what-goes-in-the-ralph-loop-prompt","dir":"","previous_headings":"Context Management","what":"What Goes in the Ralph Loop Prompt","title":"NA","text":"Since context cleared, prompt must self-contained: Feature description: ’re building (brief) Failing test: Exact file path Relevant files: look/modify Verification command: Exact command run Success criteria: “pass” looks like prompt references files (test, source) rather repeating discussion content.","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"id_1-discussion-phase","dir":"","previous_headings":"Example Workflow","what":"1. Discussion Phase","title":"NA","text":"Human Claude discuss bug, identify root cause possibilities, agree expected behavior.","code":""},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"id_2-tdd-phase","dir":"","previous_headings":"Example Workflow","what":"2. TDD Phase","title":"NA","text":"Claude writes test: Run , confirm failure:","code":"// tests/e2e/coordinate-input.test.ts test('accepts NC_ accession format', async ({ page }) => {   await page.goto('/');   const input = page.getByPlaceholder('chr1:1000-2000');   await input.fill('NC_000913.3:100000-100100');   await input.press('Enter');   // Should navigate without error   await expect(page.locator('.error')).not.toBeVisible();   await expect(input).toHaveValue(/NC_000913/); }); npx playwright test coordinate-input.test.ts # 1 failed"},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"id_3-commit-and-clear","dir":"","previous_headings":"Example Workflow","what":"3. Commit and Clear","title":"NA","text":"/clear start fresh session.","code":"git add tests/e2e/coordinate-input.test.ts git commit -m \"Add failing test for NC_ coordinate format\""},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"id_4-ralph-loop-phase","dir":"","previous_headings":"Example Workflow","what":"4. Ralph Loop Phase","title":"NA","text":"","code":"/ralph-loop \"Fix coordinate input to accept NC_ accession format.  ## Failing Test tests/e2e/coordinate-input.test.ts  ## Relevant Files - src/lib/types/genome.ts (parseCoordinate function) - src/lib/components/Header.svelte (input handling)  ## Verification npx playwright test coordinate-input.test.ts  ## Success Criteria Test passes.\" --completion-promise \"BUG-FIXED\" --max-iterations 15"},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"id_5-human-smoke-test","dir":"","previous_headings":"Example Workflow","what":"5. Human Smoke Test","title":"NA","text":"Ralph Loop exits, human quick manual verification browser.","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"writing-good-tests","dir":"","previous_headings":"Tips","what":"Writing Good Tests","title":"NA","text":"Test behavior, implementation details Include positive cases (work) negative cases (fail gracefully) Make assertions specific enough catch regressions","code":""},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"scoping-ralph-loop-prompts","dir":"","previous_headings":"Tips","what":"Scoping Ralph Loop Prompts","title":"NA","text":"List files likely need changes (helps Claude focus) Use specific test file, full test suite (faster iterations) Set reasonable max-iterations (15-25 bug fixes, 25-40 features)","code":""},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"when-things-go-wrong","dir":"","previous_headings":"Tips","what":"When Things Go Wrong","title":"NA","text":"Ralph Loop hits max iterations without success: 1. Read test output understand ’s failing 2. Check test correct 3. May need another discussion phase refine approach 4. Consider breaking smaller sub-tasks","code":""},{"path":"https://teammaclean.github.io/peppwR/semi-autonomous-feature-development.html","id":"summary","dir":"","previous_headings":"","what":"Summary","title":"NA","text":"key insight: tests contract. let Claude work autonomously clear, objective success criteria.","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"peppwr-010","dir":"Changelog","previous_headings":"","what":"peppwR 0.1.0","title":"peppwR 0.1.0","text":"Initial CRAN release.","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"core-features-0-1-0","dir":"Changelog","previous_headings":"","what":"Core Features","title":"peppwR 0.1.0","text":"fit_distributions() fits candidate distributions (gamma, lognormal, normal, inverse Gaussian, inverse gamma) peptide abundance data power_analysis() performs power analysis two modes: Aggregate mode: Specify distribution parameters directly Per-peptide mode: Use fitted distributions pilot data Three analysis questions supported via find parameter: find = \"sample_size\": N need target power? find = \"power\": ’s power given N? find = \"effect_size\": ’s minimum detectable effect?","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"statistical-tests-0-1-0","dir":"Changelog","previous_headings":"","what":"Statistical Tests","title":"peppwR 0.1.0","text":"Wilcoxon rank-sum test (test = \"wilcoxon\", default) Bootstrap-t test (test = \"bootstrap_t\") Bayes factor t-test (test = \"bayes_t\")","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"missing-data-handling-0-1-0","dir":"Changelog","previous_headings":"","what":"Missing Data Handling","title":"peppwR 0.1.0","text":"compute_missingness() calculates NA rates per peptide Dataset-level MNAR detection via abundance-missingness correlation simulate_with_missingness() incorporates missing data patterns power simulations","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"fdr-aware-mode-0-1-0","dir":"Changelog","previous_headings":"","what":"FDR-Aware Mode","title":"peppwR 0.1.0","text":"apply_fdr = TRUE per-peptide mode simulates whole-peptidome experiments Benjamini-Hochberg correction Configurable prop_null expected proportion true nulls","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"diagnostic-plots-0-1-0","dir":"Changelog","previous_headings":"","what":"Diagnostic Plots","title":"peppwR 0.1.0","text":"plot_density_overlay(): Observed histogram fitted density curve plot_qq(): QQ plots goodness--fit assessment plot_power_heatmap(): N x effect size power lookup grid plot_power_vs_effect(): Power sensitivity fixed N plot_param_distribution(): Distribution fit quality across peptidome plot_missingness(): NA rate distribution abundance vs missingness","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"empirical-bootstrap-0-1-0","dir":"Changelog","previous_headings":"","what":"Empirical Bootstrap","title":"peppwR 0.1.0","text":"on_fit_failure = \"empirical\" option uses bootstrap resampling parametric fitting fails","code":""}]

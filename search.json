[{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"peppwR","title":"peppwR","text":"Power analysis phosphopeptide abundance hypothesis tests via simulation.","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"purpose","dir":"","previous_headings":"","what":"Purpose","title":"peppwR","text":"Help researchers answer: 1. “sample size need 80% power detect given effect?” 2. “N samples per group, ’s power detect 2-fold change?” 3. “Given sample size target power, ’s minimum detectable effect?”","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"core-workflow","dir":"","previous_headings":"","what":"Core Workflow","title":"peppwR","text":"Two modes operation:","code":"pilot_data → fit_distributions() → power_analysis() → results/recommendation"},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"from-scratch-aggregate-mode","dir":"","previous_headings":"Core Workflow","what":"From Scratch (Aggregate Mode)","title":"peppwR","text":"pilot data required. User specifies assumed distribution parameters (uses sensible proteomics defaults). Simulates “typical” peptide.","code":"result <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.1),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\" )"},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"with-pilot-data-per-peptide-mode","dir":"","previous_headings":"Core Workflow","what":"With Pilot Data (Per-Peptide Mode)","title":"peppwR","text":"Uses real pilot data. Fits distributions peptide, simulates using actual fitted parameters. Reports power across peptidome.","code":"fits <- fit_distributions(pilot_data, id = \"peptide\", group = \"condition\", value = \"abundance\") result <- power_analysis(fits, effect_size = 2, target_power = 0.8, find = \"sample_size\") # Output: \"73% of peptides achieve 80% power with N=6 per group\""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"peppwr_fits","dir":"","previous_headings":"S3 Classes","what":"peppwr_fits","title":"peppwR","text":"Distribution fitting results. Contains nested data per-peptide fit statistics. Slots: - data - Original data (nested) - fits - Fit results per peptide (distribution, parameters, AIC, loglik) - best - Best-fitting distribution per peptide - call - Original function call Methods: - print() - Summary fits (best distribution counts, failure rate) - plot() - Distribution evaluation dashboard (best fits, failed fits) - summary() - Detailed fit statistics","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"peppwr_power","dir":"","previous_headings":"S3 Classes","what":"peppwr_power","title":"peppwR","text":"Power analysis results. Slots: - mode - “aggregate” “per_peptide” - question - question asked: “sample_size”, “power”, “effect_size” - answer - computed answer - simulations - Simulation details (diagnostics) - params - Input parameters used - call - Original function call Methods: - print() - Clear answer question asked - plot() - Power curves, sample size recommendations - summary() - Detailed simulation results","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"distribution-fitting","dir":"","previous_headings":"Core Functions","what":"Distribution Fitting","title":"peppwR","text":"Fits candidate distributions peptide’s values Returns peppwr_fits object distributions parameter: \"continuous\" (default), \"counts\", \"\", explicit vector Continuous distributions: gamma, normal, lognormal, inverse gaussian, etc. Count distributions: negative binomial (spectral count data)","code":"fit_distributions(data, id, group, value, distributions = \"continuous\")"},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"power-analysis","dir":"","previous_headings":"Core Functions","what":"Power Analysis","title":"peppwR","text":"Generic methods : - peppwr_fits - Per-peptide mode using fitted parameters - character - Aggregate mode specified distribution - default - Aggregate mode proteomics defaults Key parameters: - effect_size - Fold change (e.g., 2 2-fold) - n_per_group - Sample size per group (known) - target_power - Desired power (default 0.8) - alpha - Significance level (default 0.05) - find - solve : “sample_size”, “power”, “effect_size” - test - Statistical test use (see ) - n_sim - Number simulations (default 1000) - on_fit_failure - handle peptides valid fit: “exclude” (default), “empirical”, “lognormal”","code":"power_analysis(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"simulation-engine-internal","dir":"","previous_headings":"Core Functions","what":"Simulation Engine (Internal)","title":"peppwR","text":"","code":"simulate_experiment(distribution, params, n_per_group, effect_size, n_sim) run_test(control, treatment, test)"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"core-plots-v1","dir":"","previous_headings":"Plots","what":"Core plots (v1)","title":"peppwR","text":"1. plot(peppwr_fits) - Distribution summary Bar chart showing best-fit distribution counts metric (AIC/LogLik). Quick sanity check fitting worked. 2. plot(peppwr_power) aggregate mode - Power curve recommendation Power vs sample size curve : - Horizontal line target power (default 80%) - Vertical annotation recommended N - Clear title: “Recommended sample size: N=X per group” 3. plot(peppwr_power) per-peptide mode - Peptide threshold curve “% peptides reaching target power” vs sample size. Directly answers “many peptides well-powered N?”","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"statistical-tests","dir":"","previous_headings":"","what":"Statistical Tests","title":"peppwR","text":"Configurable via test parameter: Default: \"wilcoxon\"","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"simulation-approach","dir":"","previous_headings":"","what":"Simulation Approach","title":"peppwR","text":"Control group: Draw n_per_group samples fitted distribution Treatment group: Draw distribution, apply multiplicative effect Test: Run specified statistical test Repeat: n_sim iterations Power: Proportion significant results per-peptide mode, repeat across peptides report distribution power values.","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"file-structure","dir":"","previous_headings":"","what":"File Structure","title":"peppwR","text":"","code":"R/   fits.R          - Distribution fitting (fit_distributions, single_fit, do_fits)   power.R         - Power analysis (power_analysis, simulate_experiment)   tests.R         - Statistical tests (run_test, wilcoxon, bootstrap_t, etc.)   plots.R         - Visualization (plot methods, evaldist)   classes.R       - S3 class constructors and validators   utils.R         - Helpers (distribution utilities, parameter extraction)  tests/testthat/   test-fits.R     - Distribution fitting tests   test-power.R    - Power analysis tests   test-tests.R    - Statistical test implementations   test-plots.R    - Plot output tests"},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"project-plan","dir":"","previous_headings":"","what":"Project Plan","title":"peppwR","text":"Implementation order dependencies:","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-1-class-foundation","dir":"","previous_headings":"Project Plan","what":"Phase 1: Class Foundation","title":"peppwR","text":"peppwr_fits constructor - new_peppwr_fits() validation print.peppwr_fits - Summary output (fit counts, failure rate) peppwr_power constructor - new_peppwr_power() validation print.peppwr_power - Clear answer question asked","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-2-distribution-fitting-refactor-existing","dir":"","previous_headings":"Project Plan","what":"Phase 2: Distribution Fitting (refactor existing)","title":"peppwR","text":"Refactor fit_distributions() - Wraps existing logic, returns peppwr_fits plot.peppwr_fits - Distribution summary bar chart (refactor evaldist())","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-3-simulation-engine","dir":"","previous_headings":"Project Plan","what":"Phase 3: Simulation Engine","title":"peppwR","text":"simulate_experiment() - Draw distribution, apply effect, return samples test_wilcoxon() - Wilcoxon rank-sum test wrapper run_power_sim() - Run n_sim iterations, return power estimate","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-4-power-analysis---aggregate-mode","dir":"","previous_headings":"Project Plan","what":"Phase 4: Power Analysis - Aggregate Mode","title":"peppwR","text":"power_analysis.default - Aggregate mode, find = “power” Extend find = “sample_size” - Search N values Extend find = “effect_size” - Search effect values","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-5-power-analysis---per-peptide-mode","dir":"","previous_headings":"Project Plan","what":"Phase 5: Power Analysis - Per-Peptide Mode","title":"peppwR","text":"power_analysis.peppwr_fits - Per-peptide mode using fitted params on_fit_failure handling - exclude/empirical/lognormal options","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-6-core-plots","dir":"","previous_headings":"Project Plan","what":"Phase 6: Core Plots","title":"peppwR","text":"plot.peppwr_power aggregate - Power curve recommendation annotation plot.peppwr_power per-peptide - % peptides threshold vs N","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-7-additional-statistical-tests","dir":"","previous_headings":"Project Plan","what":"Phase 7: Additional Statistical Tests","title":"peppwR","text":"test_bootstrap_t() - Bootstrap-t implementation test_bayes_t() - Bayes factor t-test (via BayesFactor) test_rankprod() - Rank products implementation","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-8-polish-complete","dir":"","previous_headings":"Project Plan","what":"Phase 8: Polish (COMPLETE)","title":"peppwR","text":"summary() methods - Detailed output classes Vignettes - Three comprehensive vignettes (getting-started, power-analysis-workflow, benchmarking)","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"v2-feature-phases-complete","dir":"","previous_headings":"","what":"v2 Feature Phases (COMPLETE)","title":"peppwR","text":"See feature_plan_v2.md detailed specifications.","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-a-diagnostic-plots-","dir":"","previous_headings":"v2 Feature Phases (COMPLETE)","what":"Phase A: Diagnostic Plots ✓","title":"peppwR","text":"plot_density_overlay() - Observed histogram + fitted density curve plot_qq() - QQ plots goodness--fit plot_power_heatmap() - N × effect size lookup grid plot_power_vs_effect() - Sensitivity fixed N plot_param_distribution() - Fitted params across peptidome","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-b-empirical-bootstrap-","dir":"","previous_headings":"v2 Feature Phases (COMPLETE)","what":"Phase B: Empirical Bootstrap ✓","title":"peppwR","text":"simulate_empirical() - Bootstrap resample observed data run_power_sim_empirical() - Power sim using bootstrap on_fit_failure = \"empirical\" implemented","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-c-missing-data-handling-","dir":"","previous_headings":"v2 Feature Phases (COMPLETE)","what":"Phase C: Missing Data Handling ✓","title":"peppwR","text":"Philosophy: Track model missingness, never impute compute_missingness() - Calculate NA rate MNAR score (z-statistic) peppwr_fits includes missingness slot MNAR detection (Missing Random - low values systematically missing) simulate_with_missingness() - Incorporate NA rates simulations plot_missingness() - NA rate MNAR score distributions","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"phase-d-fdr-aware-mode-","dir":"","previous_headings":"v2 Feature Phases (COMPLETE)","what":"Phase D: FDR-Aware Mode ✓","title":"peppwR","text":"run_power_sim_fdr() - Whole-peptidome simulation BH correction apply_fdr, prop_null, fdr_threshold params power_analysis.peppwr_fits() User-configurable prop_null (default 0.9 = 90% true nulls)","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"project-status-all-features-complete","dir":"","previous_headings":"","what":"Project Status: ALL FEATURES COMPLETE","title":"peppwR","text":"planned features v1, v2, v2.1, v2.2 implemented: ✓ Core power analysis (aggregate per-peptide modes) ✓ three questions: find = “power”, “sample_size”, “effect_size” ✓ Distribution fitting multiple candidates ✓ Statistical tests: wilcoxon, bootstrap_t, bayes_t ✓ Diagnostic plots: density overlay, QQ, heatmap, param distribution ✓ Missingness handling MNAR detection ✓ FDR-aware power analysis ✓ Empirical bootstrap fallback ✓ Real-world examples (DDA PRM) ✓ Comprehensive vignettes","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"misleading-red-line-in-per-peptide-effect_size-plot","dir":"","previous_headings":"Known Issues / Bug Fixes for Future Sessions","what":"Misleading red line in per-peptide effect_size plot","title":"peppwR","text":"Problem: plot.peppwr_power() method per-peptide find = \"effect_size\" draws horizontal red line proportion_threshold (default 50%), users may confuse target_power (default 80%). Location: R/plots.R effect_size plotting section Current behavior: - Y-axis: “% peptides reaching [target_power]% power” - Red line: proportion_threshold (e.g., 50%) - technically correct visually confusing Proposed fix: 1. Remove red horizontal line plot 2. Add text annotation explaining: “Answer: X-fold effect needed Y% peptides reach Z% power” 3. Alternatively, add threshold info plot subtitle instead line Workaround: examples now include text explaining distinction target_power proportion_threshold.","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"development","dir":"","previous_headings":"","what":"Development","title":"peppwR","text":"See for_CLAUDE.md code style semi-autonomous-feature-development.md workflow. Key principles: - Tidyverse style (pipes, dplyr verbs) - Explicit namespacing (dplyr::filter()) - S3 classes print/plot methods - Discuss → TDD → Ralph Loop workflow","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"peppwR","text":"Current: - fitdistrplus, univariateML - Distribution fitting - dplyr, tidyr, purrr, tibble - Data manipulation - ggplot2, cowplot, RColorBrewer - Visualization Likely additions: - BayesFactor - Bayes factor t-tests - RankProd custom implementation - Rank products test - boot - Bootstrap methods","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"handling-fit-failures","dir":"","previous_headings":"Design Decisions","what":"Handling fit failures","title":"peppwR","text":"Configurable via on_fit_failure parameter: - \"exclude\" (default) - Skip peptides valid fit, report count output - \"empirical\" - Bootstrap resample observed values - \"lognormal\" - Fallback lognormal moment-matched parameters","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"multiple-testing--fdr","dir":"","previous_headings":"Design Decisions","what":"Multiple testing / FDR","title":"peppwR","text":"v2: FDR-aware mode implemented. Use apply_fdr = TRUE power_analysis.peppwr_fits() simulate whole-peptidome experiments Benjamini-Hochberg correction. Configure prop_null (default 0.9) expected proportion true nulls.","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"performance","dir":"","previous_headings":"Design Decisions","what":"Performance","title":"peppwR","text":"v1: Single-threaded. Rely R’s vectorization. Parallelization (via future/furrr) deferred - benchmarks show acceptable performance typical datasets.","code":""},{"path":"https://teammaclean.github.io/peppwR/CLAUDE.html","id":"distribution-presets","dir":"","previous_headings":"Design Decisions","what":"Distribution presets","title":"peppwR","text":"v2: Default changed distributions = \"\" \"continuous\" avoid nbinom warnings abundance data. Use \"counts\" spectral count data.","code":""},{"path":"https://teammaclean.github.io/peppwR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 peppwR authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarking peppwR","text":"Proteomics datasets often contain thousands tens thousands peptides. vignette characterizes peppwR’s performance characteristics help : Estimate runtime dataset size Choose appropriate n_sim values Understand memory requirements Make informed trade-offs precision compute time","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"test-data-generator","dir":"Articles","previous_headings":"Experimental Setup","what":"Test Data Generator","title":"Benchmarking peppwR","text":"","code":"generate_test_data <- function(n_peptides, n_per_group = 4, seed = 42) {   set.seed(seed)    peptide_params <- tibble::tibble(     peptide_id = paste0(\"pep_\", sprintf(\"%05d\", 1:n_peptides)),     shape = runif(n_peptides, 1.5, 5),     rate = runif(n_peptides, 0.01, 0.1)   )    peptide_params |>     dplyr::rowwise() |>     dplyr::mutate(       data = list(tibble::tibble(         condition = rep(c(\"control\", \"treatment\"), each = n_per_group),         replicate = rep(1:n_per_group, 2),         abundance = rgamma(n_per_group * 2, shape = shape, rate = rate)       ))     ) |>     dplyr::ungroup() |>     dplyr::select(peptide_id, data) |>     tidyr::unnest(data) }"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"test-configurations","dir":"Articles","previous_headings":"Experimental Setup","what":"Test Configurations","title":"Benchmarking peppwR","text":"Note: practical vignette build times, use smaller dataset sizes full specification (includes 5000, 10000, 20000 peptides). Scale estimates linearly larger datasets.","code":"# Peptide counts for scaling tests peptide_counts <- c(100, 500, 1000, 2000)  # Simulation counts for power analysis sim_counts <- c(500, 1000, 2000)"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"generate-test-datasets","dir":"Articles","previous_headings":"Distribution Fitting Scaling","what":"Generate Test Datasets","title":"Benchmarking peppwR","text":"","code":"fit_data <- lapply(peptide_counts, function(n) {   generate_test_data(n, n_per_group = 4) }) names(fit_data) <- paste0(\"n\", peptide_counts)"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"benchmark-fitting","dir":"Articles","previous_headings":"Distribution Fitting Scaling","what":"Benchmark Fitting","title":"Benchmarking peppwR","text":"benchmarks use distributions = \"continuous\" fits distributions appropriate continuous abundance data (gamma, lognormal, normal, etc.). Distribution fitting scaling","code":"fit_results <- bench::mark(   `100 peptides` = fit_distributions(fit_data$n100, \"peptide_id\", \"condition\", \"abundance\",                                       distributions = \"continuous\"),   `500 peptides` = fit_distributions(fit_data$n500, \"peptide_id\", \"condition\", \"abundance\",                                       distributions = \"continuous\"),   `1000 peptides` = fit_distributions(fit_data$n1000, \"peptide_id\", \"condition\", \"abundance\",                                        distributions = \"continuous\"),   `2000 peptides` = fit_distributions(fit_data$n2000, \"peptide_id\", \"condition\", \"abundance\",                                        distributions = \"continuous\"),   iterations = 1,   check = FALSE,   memory = TRUE ) #> Loading required namespace: intervals  fit_results_df <- tibble::tibble(   peptides = peptide_counts,   time_s = as.numeric(fit_results$median),   memory_mb = as.numeric(fit_results$mem_alloc) / 1024^2 )  fit_results_df$time_per_peptide_ms <- fit_results_df$time_s * 1000 / fit_results_df$peptides  knitr::kable(   fit_results_df,   col.names = c(\"Peptides\", \"Time (s)\", \"Memory (MB)\", \"Time/peptide (ms)\"),   digits = 2,   caption = \"Distribution fitting scaling\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"fitting-scaling-plot","dir":"Articles","previous_headings":"Distribution Fitting Scaling","what":"Fitting Scaling Plot","title":"Benchmarking peppwR","text":"Distribution fitting scales approximately linearly number peptides, peptide fitted independently.","code":"ggplot2::ggplot(fit_results_df, ggplot2::aes(x = peptides, y = time_s)) +   ggplot2::geom_point(size = 3, color = \"steelblue\") +   ggplot2::geom_line(color = \"steelblue\") +   ggplot2::scale_x_log10() +   ggplot2::scale_y_log10() +   ggplot2::theme_minimal() +   ggplot2::labs(     x = \"Number of Peptides (log scale)\",     y = \"Time (seconds, log scale)\",     title = \"Distribution Fitting: Time vs Dataset Size\"   )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"power-analysis---aggregate-mode","dir":"Articles","previous_headings":"","what":"Power Analysis - Aggregate Mode","title":"Benchmarking peppwR","text":"Aggregate mode performance depends primarily n_sim, dataset size (since simulates single “typical” peptide).","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"effect-of-n_sim","dir":"Articles","previous_headings":"Power Analysis - Aggregate Mode","what":"Effect of n_sim","title":"Benchmarking peppwR","text":"Aggregate mode timing n_sim","code":"set.seed(123)  agg_results <- bench::mark(   `n_sim=500` = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                                effect_size = 2, n_per_group = 6,                                find = \"power\", n_sim = 500),   `n_sim=1000` = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                                 effect_size = 2, n_per_group = 6,                                 find = \"power\", n_sim = 1000),   `n_sim=2000` = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                                 effect_size = 2, n_per_group = 6,                                 find = \"power\", n_sim = 2000),   iterations = 3,   check = FALSE )  agg_df <- tibble::tibble(   n_sim = sim_counts,   time_s = as.numeric(agg_results$median) )  knitr::kable(   agg_df,   col.names = c(\"n_sim\", \"Time (s)\"),   digits = 3,   caption = \"Aggregate mode timing by n_sim\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"power-estimate-stabilization","dir":"Articles","previous_headings":"Power Analysis - Aggregate Mode","what":"Power Estimate Stabilization","title":"Benchmarking peppwR","text":"simulations yield stable power estimates. Let’s examine convergence: Power estimate stability n_sim  Key insight: n_sim = 1000 provides good balance precision (CI width ~0.03) speed. publication-quality results, use n_sim = 2000+.","code":"set.seed(42)  # Run multiple times at each n_sim level stabilization_data <- do.call(rbind, lapply(c(100, 250, 500, 1000, 2000), function(n) {   powers <- replicate(10, {     result <- power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                             effect_size = 2, n_per_group = 6,                             find = \"power\", n_sim = n)     result$answer   })    tibble::tibble(     n_sim = n,     mean_power = mean(powers),     sd_power = sd(powers),     ci_width = 1.96 * sd(powers) * 2   ) }))  knitr::kable(   stabilization_data,   col.names = c(\"n_sim\", \"Mean Power\", \"SD\", \"95% CI Width\"),   digits = 3,   caption = \"Power estimate stability by n_sim\" ) ggplot2::ggplot(stabilization_data, ggplot2::aes(x = n_sim)) +   ggplot2::geom_ribbon(     ggplot2::aes(ymin = mean_power - 1.96 * sd_power,                  ymax = mean_power + 1.96 * sd_power),     fill = \"steelblue\", alpha = 0.3   ) +   ggplot2::geom_line(ggplot2::aes(y = mean_power), color = \"steelblue\", linewidth = 1) +   ggplot2::geom_point(ggplot2::aes(y = mean_power), color = \"steelblue\", size = 2) +   ggplot2::scale_x_log10() +   ggplot2::theme_minimal() +   ggplot2::labs(     x = \"Number of Simulations (log scale)\",     y = \"Power Estimate\",     title = \"Power Estimate Convergence\",     subtitle = \"Shaded region shows 95% confidence interval across 10 runs\"   )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"power-analysis---per-peptide-mode","dir":"Articles","previous_headings":"","what":"Power Analysis - Per-Peptide Mode","title":"Benchmarking peppwR","text":"Per-peptide mode scales number peptides n_sim.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"prepare-fits-for-benchmarking","dir":"Articles","previous_headings":"Power Analysis - Per-Peptide Mode","what":"Prepare Fits for Benchmarking","title":"Benchmarking peppwR","text":"","code":"fits_100 <- fit_distributions(fit_data$n100, \"peptide_id\", \"condition\", \"abundance\",                                distributions = \"continuous\") fits_500 <- fit_distributions(fit_data$n500, \"peptide_id\", \"condition\", \"abundance\",                                distributions = \"continuous\") fits_1000 <- fit_distributions(fit_data$n1000, \"peptide_id\", \"condition\", \"abundance\",                                 distributions = \"continuous\")"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"scaling-by-peptide-count","dir":"Articles","previous_headings":"Power Analysis - Per-Peptide Mode","what":"Scaling by Peptide Count","title":"Benchmarking peppwR","text":"Per-peptide mode scaling peptide count (n_sim=500)","code":"set.seed(123)  pp_peptide_results <- bench::mark(   `100 peptides` = power_analysis(fits_100, effect_size = 2, n_per_group = 6,                                   find = \"power\", n_sim = 500),   `500 peptides` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                   find = \"power\", n_sim = 500),   `1000 peptides` = power_analysis(fits_1000, effect_size = 2, n_per_group = 6,                                    find = \"power\", n_sim = 500),   iterations = 1,   check = FALSE )  pp_pep_df <- tibble::tibble(   peptides = c(100, 500, 1000),   time_s = as.numeric(pp_peptide_results$median),   time_per_peptide_ms = time_s * 1000 / peptides )  knitr::kable(   pp_pep_df,   col.names = c(\"Peptides\", \"Time (s)\", \"Time/peptide (ms)\"),   digits = 2,   caption = \"Per-peptide mode scaling by peptide count (n_sim=500)\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"scaling-by-n_sim","dir":"Articles","previous_headings":"Power Analysis - Per-Peptide Mode","what":"Scaling by n_sim","title":"Benchmarking peppwR","text":"Per-peptide mode scaling n_sim (500 peptides)","code":"set.seed(123)  pp_nsim_results <- bench::mark(   `n_sim=250` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                find = \"power\", n_sim = 250),   `n_sim=500` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                find = \"power\", n_sim = 500),   `n_sim=1000` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                 find = \"power\", n_sim = 1000),   iterations = 1,   check = FALSE )  pp_nsim_df <- tibble::tibble(   n_sim = c(250, 500, 1000),   time_s = as.numeric(pp_nsim_results$median) )  knitr::kable(   pp_nsim_df,   col.names = c(\"n_sim\", \"Time (s)\"),   digits = 2,   caption = \"Per-peptide mode scaling by n_sim (500 peptides)\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"scaling-visualization","dir":"Articles","previous_headings":"Power Analysis - Per-Peptide Mode","what":"Scaling Visualization","title":"Benchmarking peppwR","text":"","code":"ggplot2::ggplot(pp_pep_df, ggplot2::aes(x = peptides, y = time_s)) +   ggplot2::geom_point(size = 3, color = \"steelblue\") +   ggplot2::geom_line(color = \"steelblue\") +   ggplot2::scale_x_log10() +   ggplot2::scale_y_log10() +   ggplot2::theme_minimal() +   ggplot2::labs(     x = \"Number of Peptides (log scale)\",     y = \"Time (seconds, log scale)\",     title = \"Per-Peptide Power Analysis: Scaling with Dataset Size\"   )"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"time-estimation-formula","dir":"Articles","previous_headings":"Recommendations","what":"Time Estimation Formula","title":"Benchmarking peppwR","text":"per-peptide mode: : - time_per_sim ≈ 0.002-0.005 seconds (depends test type) - fitting_time ≈ 0.02 seconds per peptide","code":"Estimated time (s) ≈ (n_peptides × n_sim × time_per_sim) + fitting_time"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"memory-considerations","dir":"Articles","previous_headings":"Recommendations","what":"Memory Considerations","title":"Benchmarking peppwR","text":"Fitting: ~0.1-0.2 MB per 100 peptides Power analysis: Minimal additional memory (results stored per peptide) large datasets (>10000 peptides), ensure least 4GB available RAM","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"statistical-test-speed-comparison","dir":"Articles","previous_headings":"Recommendations","what":"Statistical Test Speed Comparison","title":"Benchmarking peppwR","text":"Statistical test speed comparison (n_sim=500) Note: bootstrap_t rankprod tests slower due resampling procedures. large-scale analyses, wilcoxon bayes_t faster options.","code":"set.seed(123)  test_timing <- bench::mark(   wilcoxon = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                             effect_size = 2, n_per_group = 6,                             find = \"power\", test = \"wilcoxon\", n_sim = 500),   bootstrap_t = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                                effect_size = 2, n_per_group = 6,                                find = \"power\", test = \"bootstrap_t\", n_sim = 500),   bayes_t = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                            effect_size = 2, n_per_group = 6,                            find = \"power\", test = \"bayes_t\", n_sim = 500),   rankprod = power_analysis(\"gamma\", list(shape = 2, rate = 0.05),                             effect_size = 2, n_per_group = 6,                             find = \"power\", test = \"rankprod\", n_sim = 500),   iterations = 2,   check = FALSE )  test_df <- tibble::tibble(   test = c(\"wilcoxon\", \"bootstrap_t\", \"bayes_t\", \"rankprod\"),   time_s = as.numeric(test_timing$median),   relative = time_s / min(time_s) )  knitr::kable(   test_df,   col.names = c(\"Test\", \"Time (s)\", \"Relative Speed\"),   digits = 2,   caption = \"Statistical test speed comparison (n_sim=500)\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"missingness-aware-simulation-performance","dir":"Articles","previous_headings":"","what":"Missingness-Aware Simulation Performance","title":"Benchmarking peppwR","text":"include_missingness = TRUE, peppwR incorporates peptide-specific NA rates simulations. Let’s measure overhead: Missingness-aware simulation overhead overhead include_missingness = TRUE minimal - ’s primarily NA handling within simulation loop, fast.","code":"# Generate data with realistic missingness generate_test_data_with_na <- function(n_peptides, n_per_group = 4, na_rate = 0.15, seed = 42) {   set.seed(seed)    data <- generate_test_data(n_peptides, n_per_group, seed)    # Introduce MNAR pattern: low values more likely to be missing   threshold <- quantile(data$abundance, 0.3)   data$abundance <- ifelse(     data$abundance < threshold & runif(nrow(data)) < na_rate * 2,     NA,     data$abundance   )    # Also some random MCAR missingness   data$abundance <- ifelse(     runif(nrow(data)) < na_rate / 3,     NA,     data$abundance   )    data }  data_with_na <- generate_test_data_with_na(500, n_per_group = 4, na_rate = 0.15) fits_with_na <- fit_distributions(data_with_na, \"peptide_id\", \"condition\", \"abundance\",                                    distributions = \"continuous\") set.seed(123)  miss_results <- bench::mark(   `Without missingness` = power_analysis(fits_with_na, effect_size = 2, n_per_group = 6,                                          find = \"power\", n_sim = 200,                                          include_missingness = FALSE),   `With missingness` = power_analysis(fits_with_na, effect_size = 2, n_per_group = 6,                                       find = \"power\", n_sim = 200,                                       include_missingness = TRUE),   iterations = 2,   check = FALSE )  miss_df <- tibble::tibble(   mode = c(\"Without missingness\", \"With missingness\"),   time_s = as.numeric(miss_results$median) )  knitr::kable(   miss_df,   col.names = c(\"Mode\", \"Time (s)\"),   digits = 2,   caption = \"Missingness-aware simulation overhead\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"fdr-mode-performance","dir":"Articles","previous_headings":"","what":"FDR Mode Performance","title":"Benchmarking peppwR","text":"FDR-aware mode simulates entire peptidome experiments mixed null alternative peptides, applies BH correction. computationally intensive per-peptide mode. FDR mode vs per-peptide mode timing FDR mode expensive simulation iteration requires: 1. Assigning peptides null/alternative 2. Simulating peptides together 3. Applying BH correction across p-values","code":"set.seed(123)  fdr_results <- bench::mark(   `Per-peptide (no FDR)` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                           find = \"power\", n_sim = 100),   `FDR-adjusted` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                   find = \"power\", apply_fdr = TRUE,                                   prop_null = 0.9, n_sim = 100),   iterations = 2,   check = FALSE )  fdr_df <- tibble::tibble(   mode = c(\"Per-peptide (no FDR)\", \"FDR-adjusted\"),   time_s = as.numeric(fdr_results$median) )  knitr::kable(   fdr_df,   col.names = c(\"Mode\", \"Time (s)\"),   digits = 2,   caption = \"FDR mode vs per-peptide mode timing\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"fdr-scaling-with-peptide-count","dir":"Articles","previous_headings":"FDR Mode Performance","what":"FDR Scaling with Peptide Count","title":"Benchmarking peppwR","text":"FDR mode scaling peptide count (n_sim=50)","code":"set.seed(123)  fdr_scaling_results <- bench::mark(   `100 peptides` = power_analysis(fits_100, effect_size = 2, n_per_group = 6,                                   find = \"power\", apply_fdr = TRUE, n_sim = 50),   `500 peptides` = power_analysis(fits_500, effect_size = 2, n_per_group = 6,                                   find = \"power\", apply_fdr = TRUE, n_sim = 50),   `1000 peptides` = power_analysis(fits_1000, effect_size = 2, n_per_group = 6,                                    find = \"power\", apply_fdr = TRUE, n_sim = 50),   iterations = 1,   check = FALSE )  fdr_scale_df <- tibble::tibble(   peptides = c(100, 500, 1000),   time_s = as.numeric(fdr_scaling_results$median) )  knitr::kable(   fdr_scale_df,   col.names = c(\"Peptides\", \"Time (s)\"),   digits = 2,   caption = \"FDR mode scaling by peptide count (n_sim=50)\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"diagnostic-plot-generation-times","dir":"Articles","previous_headings":"","what":"Diagnostic Plot Generation Times","title":"Benchmarking peppwR","text":"Diagnostic plot generation times Power heatmap generation time Note: power heatmap expensive runs n_steps^2 × n_sim simulations. Use smaller grids fewer simulations exploratory work.","code":"set.seed(42)  plot_results <- bench::mark(   `Density overlay` = plot_density_overlay(fits_500, n_overlay = 6),   `QQ plots` = plot_qq(fits_500, n_plots = 6),   `Param distribution` = plot_param_distribution(fits_500),   iterations = 2,   check = FALSE )  plot_df <- tibble::tibble(   plot = c(\"Density overlay\", \"QQ plots\", \"Param distribution\"),   time_s = as.numeric(plot_results$median) )  knitr::kable(   plot_df,   col.names = c(\"Plot Type\", \"Time (s)\"),   digits = 3,   caption = \"Diagnostic plot generation times\" ) set.seed(123)  heatmap_results <- bench::mark(   `Power heatmap (5x5)` = plot_power_heatmap(     \"gamma\", list(shape = 2, rate = 0.05),     n_range = c(3, 12), effect_range = c(1.5, 3),     n_steps = 5, n_sim = 50   ),   iterations = 1,   check = FALSE )  knitr::kable(   tibble::tibble(     plot = \"Power heatmap (5x5 grid, n_sim=50)\",     time_s = as.numeric(heatmap_results$median)   ),   col.names = c(\"Plot Type\", \"Time (s)\"),   digits = 2,   caption = \"Power heatmap generation time\" )"},{"path":"https://teammaclean.github.io/peppwR/articles/benchmarking.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Benchmarking peppwR","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices datasets  utils     methods   base      #>  #> other attached packages: #> [1] bench_1.1.4  peppwR_0.1.0 #>  #> loaded via a namespace (and not attached): #>  [1] sass_0.4.10         generics_0.1.4      tidyr_1.3.2         #>  [4] renv_0.12.2         fGarch_4052.93      lattice_0.22-7      #>  [7] digest_0.6.39       magrittr_2.0.4      RColorBrewer_1.1-3  #> [10] evaluate_1.0.5      grid_4.5.2          fastmap_1.2.0       #> [13] jsonlite_2.0.0      Matrix_1.7-4        purrr_1.2.1         #> [16] scales_1.4.0        gbutils_0.5.1       codetools_0.2-20    #> [19] textshaping_1.0.4   jquerylib_0.1.4     Rdpack_2.6.5        #> [22] cli_3.6.5           timeSeries_4052.112 rlang_1.1.7         #> [25] rbibutils_2.4.1     intervals_0.15.5    withr_3.0.2         #> [28] cachem_1.1.0        yaml_2.3.12         cvar_0.6            #> [31] tools_4.5.2         dplyr_1.2.0         ggplot2_4.0.2       #> [34] profmem_0.7.0       assertthat_0.2.1    vctrs_0.7.1         #> [37] R6_2.6.1            lifecycle_1.0.5     fs_1.6.6            #> [40] univariateML_1.5.0  ragg_1.5.0          pkgconfig_2.0.3     #> [43] desc_1.4.3          gtable_0.3.6        pkgdown_2.2.0       #> [46] pillar_1.11.1       bslib_0.10.0        glue_1.8.0          #> [49] systemfonts_1.3.1   xfun_0.56           tibble_3.3.1        #> [52] tidyselect_1.2.1    knitr_1.51          farver_2.1.2        #> [55] spatial_7.3-18      htmltools_0.5.9     fBasics_4052.98     #> [58] labeling_0.4.3      rmarkdown_2.30      timeDate_4052.112   #> [61] compiler_4.5.2      S7_0.2.1"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"what-is-statistical-power","dir":"Articles","previous_headings":"Introduction","what":"What is Statistical Power?","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Statistical power probability detecting true effect one exists. proteomics experiments, translates : “phosphopeptide truly changes conditions, likely find statistically significant?” Power depends four interconnected factors: Effect size - large biological change? (e.g., 2-fold) Sample size - many biological replicates per group? Variability - noisy measurement? Significance threshold - alpha level using? (typically 0.05)","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"why-does-power-matter","dir":"Articles","previous_headings":"Introduction","what":"Why Does Power Matter?","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Phosphoproteomics experiments expensive time-consuming. -powered experiments waste resources failing detect real biological changes. -powered experiments waste resources using samples necessary. Power analysis helps researchers: experiment: Determine required sample size adequate power pilot: Assess effects can detected current data grant planning: Justify sample size requirements reviewers","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"the-peppwr-approach","dir":"Articles","previous_headings":"Introduction","what":"The peppwR Approach","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"peppwR uses simulation-based power analysis: Fit distributions pilot data capture realistic abundance patterns Simulate experiments drawing fitted distributions Apply statistical tests simulated data Estimate power proportion simulations significant results approach captures full complexity phosphoproteomics data, including heterogeneity across peptides.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"about-the-data","dir":"Articles","previous_headings":"","what":"About the Data","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"analysis uses Arabidopsis phosphoproteomics data time-course experiment:","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"data-preparation","dir":"Articles","previous_headings":"","what":"Data Preparation","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Distribution log2 abundance values across conditions. broad range right-skew typical phosphoproteomics data. abundance values span several orders magnitude, typical phosphoproteomics data. distributions appear similar timepoints global level, though individual peptides may show significant changes.","code":"library(peppwR) library(dplyr) library(ggplot2) library(tibble) # Load the DDA experiment data dda <- read.csv(\"../../sample_data/dda_data.csv\")  # Examine the structure glimpse(dda) ## Rows: 26,820 ## Columns: 7 ## $ protein_name      <chr> \"AT3G05900\", \"AT3G05900\", \"AT3G05900\", \"AT3G05900\", … ## $ genotype          <chr> \"Col-0\", \"Col-0\", \"Col-0\", \"Col-0\", \"Col-0\", \"Col-0\"… ## $ bio_rep           <int> 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3… ## $ tech_rep          <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ timepoints        <int> 0, 0, 0, 150, 150, 150, 300, 300, 300, 600, 600, 600… ## $ timepoints_values <dbl> 111486.89, 169993.66, 7241966.48, 174394.39, 2955899… ## $ new_annotation    <chr> \"YVVDEPSKDETT[+80]SESGSALCPEK\", \"YVVDEPSKDETT[+80]SE… # Filter to early (0) vs late (600) timepoints and format for peppwR pilot <- dda |>   filter(timepoints %in% c(0, 600)) |>   transmute(     peptide_id = new_annotation,     condition = paste0(\"t\", timepoints),     abundance = timepoints_values   )  # Summary statistics cat(\"Unique peptides:\", n_distinct(pilot$peptide_id), \"\\n\") ## Unique peptides: 2228 cat(\"Observations per condition:\\n\") ## Observations per condition: pilot |> count(condition) ##   condition    n ## 1        t0 6705 ## 2      t600 6705 # Exploratory visualization ggplot(pilot, aes(x = log2(abundance), fill = condition)) +   geom_density(alpha = 0.5) +   labs(     x = \"Log2 Abundance\",     y = \"Density\",     title = \"Phosphopeptide Abundance Distribution\"   ) +   theme_minimal()"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"why-fit-distributions","dir":"Articles","previous_headings":"Distribution Fitting","what":"Why Fit Distributions?","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"simulate realistic experiments, need parametric models capture statistical properties peptide’s abundance values. peppwR fits multiple candidate distributions (gamma, lognormal, inverse Gaussian, Pareto, skew normal, etc.) selects best fit peptide based AIC. Best-fit distribution counts across peptidome.","code":"# Fit distributions to each peptide fits <- fit_distributions(pilot, \"peptide_id\", \"condition\", \"abundance\")  # Summary of fitting results print(fits) ## peppwr_fits object ## ------------------ ## 4456 peptides fitted ##  ## Best fit distribution counts: ##   Gamma: 416 ##   Inverse Gaussian: 1 ##   Loggamma: 1 ##   Normal: 515 ##   Pareto: 3522 ##   Skew Normal: 1 # Visualize which distributions fit best plot(fits)"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"interpreting-distribution-fitting-results-a-cautionary-note","dir":"Articles","previous_headings":"Distribution Fitting","what":"Interpreting Distribution Fitting Results: A Cautionary Note","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Important: 6 observations per peptide (3 replicates x 2 conditions), distribution selection unreliable. may observe distributions like Pareto Skew Normal dominate “best fit” counts. artifact small sample size, statement true underlying distributions. biological replicates, expect gamma lognormal distributions fit better - typical distributions mass spectrometry abundance data based underlying measurement process. Key insight: specific distribution matters less enough data fit reliably. power analysis, proceed best available fits acknowledging limitation.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"parameter-distribution","dir":"Articles","previous_headings":"Distribution Fitting","what":"Parameter Distribution","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Distribution AIC values across peptides fitted distribution. Lower AIC indicates better fit.","code":"p <- plot_param_distribution(fits) print(p) # Count peptides per best-fit distribution for context cat(\"\\nPeptides per best-fit distribution:\\n\") ##  ## Peptides per best-fit distribution: tibble(distribution = fits$best) |>   count(distribution) |>   arrange(desc(n)) ## # A tibble: 6 × 2 ##   distribution         n ##   <chr>            <int> ## 1 Pareto            3522 ## 2 Normal             515 ## 3 Gamma              416 ## 4 Inverse Gaussian     1 ## 5 Loggamma             1 ## 6 Skew Normal          1"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"choosing-the-right-statistical-test","dir":"Articles","previous_headings":"Power Analysis","what":"Choosing the Right Statistical Test","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Critical first step: small samples (N=3), choice statistical test dramatically affects power. proceeding detailed analysis, must compare tests understand behavior. peppwR supports several tests: Let’s compare three tests N=3 2-fold effect: Power comparison across statistical tests (N=3, 2-fold effect)","code":"# Run all three tests (use n_sim = 100 for faster rendering) power_wilcox <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                 find = \"power\", test = \"wilcoxon\", n_sim = 100)  power_boot <- power_analysis(fits, effect_size = 2, n_per_group = 3,                               find = \"power\", test = \"bootstrap_t\", n_sim = 100)  power_bayes <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                find = \"power\", test = \"bayes_t\", n_sim = 100)  # Create comparison table comparison <- tibble(   Test = c(\"Wilcoxon rank-sum\", \"Bootstrap-t\", \"Bayes factor\"),   `Median Power` = c(     median(power_wilcox$simulations$peptide_power, na.rm = TRUE),     median(power_boot$simulations$peptide_power, na.rm = TRUE),     median(power_bayes$simulations$peptide_power, na.rm = TRUE)   ),   `% > 50% Power` = c(     mean(power_wilcox$simulations$peptide_power > 0.5, na.rm = TRUE) * 100,     mean(power_boot$simulations$peptide_power > 0.5, na.rm = TRUE) * 100,     mean(power_bayes$simulations$peptide_power > 0.5, na.rm = TRUE) * 100   ),   `% > 80% Power` = c(     mean(power_wilcox$simulations$peptide_power > 0.8, na.rm = TRUE) * 100,     mean(power_boot$simulations$peptide_power > 0.8, na.rm = TRUE) * 100,     mean(power_bayes$simulations$peptide_power > 0.8, na.rm = TRUE) * 100   ) )  knitr::kable(comparison, digits = 2,              caption = \"Power comparison across statistical tests (N=3, 2-fold effect)\")"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"understanding-the-test-comparison-results","dir":"Articles","previous_headings":"Power Analysis","what":"Understanding the Test Comparison Results","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"comparison table reveals important insights: Wilcoxon rank-sum conservative small samples. Non-parametric tests don’t make distributional assumptions, comes cost: need data achieve comparable power. Bootstrap-t uses resampling handle non-normality, potentially offering better power Wilcoxon. Bayes factor tests provide evidence effect. small N, Bayesian approaches can informative frequentist tests. Recommendation: remaining analyses document, use Bayes factor test since provides usable power estimates N=3.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"the-three-questions","dir":"Articles","previous_headings":"Power Analysis","what":"The Three Questions","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Power analysis can answer three related questions experimental design: Power: Given sample size effect size, power? Sample size: Given target power effect size, N need? Minimum detectable effect: Given sample size target power, ’s smallest effect can detect? questions mathematically related - fixing three parameters determines fourth.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"question-1-current-power-n3","dir":"Articles","previous_headings":"Power Analysis","what":"Question 1: Current Power (N=3)","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"3 biological replicates per group (experiment), power detect 2-fold change? Distribution power across peptides N=3 2-fold effect (Bayes factor test). bar represents proportion peptides achieving power level. N=3, power detect 2-fold change varies across peptides. Peptides lower variability higher power, noisy peptides remain -powered.","code":"# Using Bayes factor test based on our comparison results power_n3 <- power_analysis(fits, effect_size = 2, n_per_group = 3,                            find = \"power\", test = \"bayes_t\", n_sim = 100) print(power_n3) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Power: 51% ## Sample size: 3 per group ## Effect size: 2.00-fold ##  ## Significance level: 0.05 ## Statistical test: bayes_t plot(power_n3)"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"question-2-sample-size-for-target-power","dir":"Articles","previous_headings":"Power Analysis","what":"Question 2: Sample Size for Target Power","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"sample size need achieve 80% power detect 2-fold change peptides? Percentage peptides reaching 80% power sample size. curve shows diminishing returns N increases. curve directly answers “percentage peptides well-powered sample size N?” - useful experimental planning budget constraints limit replication.","code":"sample_size <- power_analysis(fits, effect_size = 2, target_power = 0.8,                               find = \"sample_size\", test = \"bayes_t\", n_sim = 100) print(sample_size) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Recommended sample size: N=15 per group ## Target power: 80% ## Effect size: 2.00-fold ##  ## Significance level: 0.05 ## Statistical test: bayes_t plot(sample_size)"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"question-3-minimum-detectable-effect","dir":"Articles","previous_headings":"Power Analysis","what":"Question 3: Minimum Detectable Effect","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"N=3 80% power target, ’s smallest effect can reliably detect? Understanding two thresholds: per-peptide mode, two distinct thresholds: target_power (set 0.8) - power level individual peptide must achieve proportion_threshold (default 0.5) - fraction peptides must reach target_power plot shows “% peptides reaching 80% power” y-axis. answer tells us: “effect size 50% peptides achieve 80% power?” Proportion peptides reaching 80% power effect size. default threshold 50% peptides (proportion_threshold = 0.5). N=3, large effects needed majority peptides well-powered. realistic sobering assessment -powered experiments can detect. require higher fraction peptides well-powered, increase proportion_threshold:","code":"min_effect <- power_analysis(fits, n_per_group = 3, target_power = 0.8,                              find = \"effect_size\", test = \"bayes_t\", n_sim = 100) print(min_effect) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Minimum detectable effect: 10.00-fold ## Sample size: 3 per group ## Target power: 80% ##  ## Significance level: 0.05 ## Statistical test: bayes_t plot(min_effect) # Require 80% of peptides to reach 80% power (stricter) power_analysis(fits, n_per_group = 3, target_power = 0.8,                find = \"effect_size\", proportion_threshold = 0.8, ...)"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"power-heatmap","dir":"Articles","previous_headings":"","what":"Power Heatmap","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"power heatmap visualizes power varies across combinations sample size effect size - useful identifying “sweet spot” experimental design.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"why-aggregate-mode-for-heatmaps","dir":"Articles","previous_headings":"Power Heatmap","what":"Why Aggregate Mode for Heatmaps?","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"plot_power_heatmap() function uses aggregate mode (single distribution) rather per-peptide mode : Computational cost: Per-peptide heatmaps require millions simulations Visualization: single heatmap interpretable 2000+ individual heatmaps Purpose: Heatmaps answer “’s general tradeoff?” “’s power peptide X?” make heatmap relevant data, derive representative parameters fitted distributions: Power function sample size effect size representative peptide. Colors indicate expected power. Individual peptides vary based specific variability.","code":"# Derive representative parameters from the data log_abundances <- log(pilot$abundance[pilot$abundance > 0]) derived_params <- list(   meanlog = median(log_abundances),   sdlog = mad(log_abundances, constant = 1)  # robust SD estimate )  cat(\"Using representative lognormal parameters:\\n\") ## Using representative lognormal parameters: cat(\"  meanlog =\", round(derived_params$meanlog, 2), \"\\n\") ##   meanlog = 13.72 cat(\"  sdlog =\", round(derived_params$sdlog, 2), \"\\n\") ##   sdlog = 1.41 # Generate heatmap with data-derived parameters plot_power_heatmap(   distribution = \"lnorm\",   params = derived_params,   n_range = c(3, 12),   effect_range = c(1.2, 3),   test = \"wilcoxon\"  # heatmap uses aggregate mode )"},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"interpreting-the-heatmap","dir":"Articles","previous_headings":"Power Heatmap","what":"Interpreting the Heatmap","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"heatmap shows power representative peptide typical abundance characteristics. Individual peptides vary: Low-variability peptides higher power shown High-variability peptides lower power shown Use per-peptide find = \"power\" results understand distribution across peptides heatmap shows: Lower-left corner (small N, small effect): Low power - avoid region Upper-right corner (large N, large effect): High power potentially wasteful Diagonal transition zone: practical planning region tradeoffs matter","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"key-findings","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Key Findings","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"Distribution fitting: 6 observations per peptide, distribution selection unreliable. observed “best fit” distributions artifacts small sample size, true underlying distributions. Test selection matters: Wilcoxon rank-sum may limited power N=3 due conservative nature. Bayes factor tests can provide informative power estimates small samples. Current power (N=3): 3 replicates Bayes factor test, power detect 2-fold change varies across peptides based individual variability. Sample size requirements: Achieving consistently high power (80%+) across peptides requires N=3 biological replicates. Minimum detectable effect: N=3, relatively large fold changes can reliably detected 80% power peptides.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"practical-recommendations","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Practical Recommendations","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"future experiments: Consider N=6 biological replicates detecting smaller fold changes (<2-fold) important. current data interpretation: Results showing non-significance may reflect insufficient power rather absence biological effect. cautious concluding “difference.” Test selection: small samples, consider Bayes factor tests may informative traditional frequentist tests. Effect size expectations: Set realistic expectations - detecting subtle changes requires adequate replication.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"caveats","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Caveats","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"analysis uses single genotype (Col-0) specific timepoint comparison (0 vs 600) Distribution fitting limited small sample size (6 observations per peptide) Power estimates assume fitted distributions accurately represent underlying biology Technical variability (modeled ) may reduce effective power Real experimental factors (batch effects, sample quality) captured","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/dda-time-course-power.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Power Analysis for Time-Course Phosphoproteomics (DDA)","text":"","code":"sessionInfo() ## R version 4.5.2 (2025-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices datasets  utils     methods   base      ##  ## other attached packages: ## [1] tibble_3.3.1  ggplot2_4.0.2 dplyr_1.2.0   peppwR_0.1.0  ##  ## loaded via a namespace (and not attached): ##  [1] utf8_1.2.6          sass_0.4.10         generics_0.1.4      ##  [4] tidyr_1.3.2         renv_0.12.2         lattice_0.22-7      ##  [7] fGarch_4052.93      digest_0.6.39       magrittr_2.0.4      ## [10] evaluate_1.0.5      grid_4.5.2          RColorBrewer_1.1-3  ## [13] fastmap_1.2.0       Matrix_1.7-4        jsonlite_2.0.0      ## [16] purrr_1.2.1         scales_1.4.0        gbutils_0.5.1       ## [19] textshaping_1.0.4   jquerylib_0.1.4     Rdpack_2.6.5        ## [22] cli_3.6.5           timeSeries_4052.112 rlang_1.1.7         ## [25] rbibutils_2.4.1     intervals_0.15.5    withr_3.0.2         ## [28] cachem_1.1.0        yaml_2.3.12         cvar_0.6            ## [31] tools_4.5.2         assertthat_0.2.1    vctrs_0.7.1         ## [34] R6_2.6.1            lifecycle_1.0.5     fs_1.6.6            ## [37] univariateML_1.5.0  ragg_1.5.0          pkgconfig_2.0.3     ## [40] desc_1.4.3          pkgdown_2.2.0       pillar_1.11.1       ## [43] bslib_0.10.0        gtable_0.3.6        glue_1.8.0          ## [46] systemfonts_1.3.1   xfun_0.56           tidyselect_1.2.1    ## [49] knitr_1.51          farver_2.1.2        spatial_7.3-18      ## [52] htmltools_0.5.9     fBasics_4052.98     rmarkdown_2.30      ## [55] labeling_0.4.3      timeDate_4052.112   compiler_4.5.2      ## [58] S7_0.2.1"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with peppwR","text":"peppwR helps researchers answer power analysis questions phosphoproteomics experiments: Sample size: “sample size need 80% power detect 2-fold change?” Power: “N=6 per group, ’s power detect 2-fold change?” Effect size: “N=6 80% power, ’s minimum detectable effect?” vignette demonstrates minimal workflow get zero power estimates.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Getting Started with peppwR","text":"","code":"# From GitHub devtools::install_github(\"danmaclean/peppwR\")"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Getting Started with peppwR","text":"","code":"library(peppwR)"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"generate-synthetic-pilot-data","dir":"Articles","previous_headings":"","what":"Generate Synthetic Pilot Data","title":"Getting Started with peppwR","text":"Let’s create realistic phosphopeptide abundance data: 100 peptides, 2 conditions (control/treatment), 4 replicates . ’ll use gamma distributions typical proteomics data.","code":"set.seed(42)  # Generate peptide-level parameters n_peptides <- 100 n_per_group <- 4  peptide_params <- tibble::tibble(   peptide_id = paste0(\"pep_\", sprintf(\"%04d\", 1:n_peptides)),   # Shape parameter: 1.5-5 (lower = more skewed)   shape = runif(n_peptides, 1.5, 5),   # Rate parameter: scaled to give realistic abundances   rate = runif(n_peptides, 0.01, 0.1) )  # Generate observations for each peptide pilot_data <- peptide_params |>   dplyr::rowwise() |>   dplyr::mutate(     data = list(tibble::tibble(       condition = rep(c(\"control\", \"treatment\"), each = n_per_group),       replicate = rep(1:n_per_group, 2),       abundance = rgamma(n_per_group * 2, shape = shape, rate = rate)     ))   ) |>   dplyr::ungroup() |>   dplyr::select(peptide_id, data) |>   tidyr::unnest(data)  # Preview the data head(pilot_data, 12) #> # A tibble: 12 × 4 #>    peptide_id condition replicate abundance #>    <chr>      <chr>         <int>     <dbl> #>  1 pep_0001   control           1     106.  #>  2 pep_0001   control           2      99.7 #>  3 pep_0001   control           3      36.1 #>  4 pep_0001   control           4      62.1 #>  5 pep_0001   treatment         1      66.6 #>  6 pep_0001   treatment         2      50.9 #>  7 pep_0001   treatment         3      97.6 #>  8 pep_0001   treatment         4      52.2 #>  9 pep_0002   control           1     143.  #> 10 pep_0002   control           2     295.  #> 11 pep_0002   control           3     216.  #> 12 pep_0002   control           4      89.0"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"fit-distributions","dir":"Articles","previous_headings":"","what":"Fit Distributions","title":"Getting Started with peppwR","text":"Use fit_distributions() determine statistical distributions best describe peptide abundance data. distributions parameter controls distributions fitted: - \"continuous\" (default) - gamma, normal, lognormal, etc. abundance data - \"counts\" - includes negative binomial count-based quantification - \"\" - tries distributions auto-detection output shows many peptides best fit distribution. helps understand statistical properties data.","code":"fits <- fit_distributions(   pilot_data,   id = \"peptide_id\",   group = \"condition\",   value = \"abundance\",   distributions = \"continuous\" ) #> Loading required namespace: intervals  print(fits) #> peppwr_fits object #> ------------------ #> 200 peptides fitted #>  #> Best fit distribution counts: #>   Gamma: 13 #>   Normal: 22 #>   Pareto: 124 #>   Skew Normal: 41"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"visualize-distribution-fits","dir":"Articles","previous_headings":"Fit Distributions","what":"Visualize Distribution Fits","title":"Getting Started with peppwR","text":"plot shows count best-fit distributions two metrics: - AIC (Akaike Information Criterion): Balances fit quality model complexity - LogLikelihood: Pure goodness--fit measure metrics agree, can confident distribution choice.","code":"plot(fits)"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"assess-fit-quality","dir":"Articles","previous_headings":"","what":"Assess Fit Quality","title":"Getting Started with peppwR","text":"larger pilot datasets (n≥15 per group), can visually assess fit quality using diagnostic plots. peppwR provides two options: Density overlay - overlays fitted density curves observed histograms: QQ plots - compare observed vs theoretical quantiles: small pilot data (n=4 per group), plots informative - simply points per peptide meaningful visual assessment. See vignette(\"power-analysis-workflow\") examples larger datasets. fits look poor, consider: - Using different candidate distributions - Checking outliers data quality issues - Using on_fit_failure = \"empirical\" power analysis bootstrap raw data","code":"# Visual check: does the fitted distribution match the data? plot_density_overlay(fits, n_overlay = 4) # Goodness-of-fit assessment via QQ plots plot_qq(fits, n_plots = 4)"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"a-note-on-sample-size-and-distribution-detection","dir":"Articles","previous_headings":"","what":"A Note on Sample Size and Distribution Detection","title":"Getting Started with peppwR","text":"small pilot datasets (n=4 per group = 8 observations per peptide), “best” distribution may match true underlying distribution. synthetic data generated Gamma distributions, small samples may see Pareto Skew Normal selected “best.” Let’s verify larger samples, correct distribution identified: 30 samples per group, Gamma distribution correctly identified best fit. Takeaway: small pilot studies, interpret “best fit” “best among candidates given limited data” rather definitive truth. fitted parameters still useful power simulation regardless distribution family selected.","code":"set.seed(42)  # Generate data with larger sample size - 30 per group large_n_data <- tibble::tibble(   peptide_id = \"test_peptide\",   condition = rep(c(\"control\", \"treatment\"), each = 30),   replicate = rep(1:30, 2),   abundance = rgamma(60, shape = 3, rate = 0.05)  # True distribution: Gamma )  large_fits <- fit_distributions(   large_n_data,   id = \"peptide_id\",   group = \"condition\",   value = \"abundance\",   distributions = \"continuous\" )  print(large_fits) #> peppwr_fits object #> ------------------ #> 2 peptides fitted #>  #> Best fit distribution counts: #>   Gamma: 2"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"power-analysis---aggregate-mode","dir":"Articles","previous_headings":"","what":"Power Analysis - Aggregate Mode","title":"Getting Started with peppwR","text":"don’t pilot data, want quick ballpark estimate, use aggregate mode. specify assumed distribution parameters.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"finding-required-sample-size","dir":"Articles","previous_headings":"Power Analysis - Aggregate Mode","what":"Finding Required Sample Size","title":"Getting Started with peppwR","text":"“many samples need per group achieve 80% power detecting 2-fold change?”  plot shows power curve target power recommended sample size highlighted.","code":"result_n <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 1000 )  print(result_n) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Recommended sample size: N=25 per group #> Target power: 80% #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: wilcoxon plot(result_n)"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"finding-power-at-fixed-n","dir":"Articles","previous_headings":"Power Analysis - Aggregate Mode","what":"Finding Power at Fixed N","title":"Getting Started with peppwR","text":"“’s power detect 2-fold change N=6 per group?”","code":"result_power <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 1000 )  print(result_power) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 24% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: wilcoxon"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"power-analysis---per-peptide-mode","dir":"Articles","previous_headings":"","what":"Power Analysis - Per-Peptide Mode","title":"Getting Started with peppwR","text":"pilot data, use per-peptide mode accurate, peptide-specific power estimates. mode: 1. Uses fitted distribution peptide 2. Simulates power individually 3. Reports proportion peptidome reaches target power  plot shows percentage peptides achieve target power sample size. 50% line indicates majority peptides well-powered.","code":"result_pp <- power_analysis(   fits,   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  print(result_pp) #> peppwr_power analysis #> --------------------- #> Mode: per_peptide #>  #> Recommended sample size: N=12 per group #> Target power: 80% #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: wilcoxon plot(result_pp)"},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"interpreting-per-peptide-results","dir":"Articles","previous_headings":"Power Analysis - Per-Peptide Mode","what":"Interpreting Per-Peptide Results","title":"Getting Started with peppwR","text":"Unlike aggregate mode, per-peptide mode acknowledges peptides behave . peptides may require samples due higher variance, others achieve target power fewer samples. “% peptides target power” metric helps understand: - N peptides become well-powered? - fraction peptides remain underpowered even larger samples?","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/getting-started.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Getting Started with peppwR","text":"Power Analysis Workflow: See vignette(\"power-analysis-workflow\") detailed guidance modes, three power questions, statistical test options. Benchmarking: See vignette(\"benchmarking\") performance characteristics large datasets.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Power Analysis Workflow","text":"peppwR addresses three fundamental power analysis questions: Sample size: “sample size need achieve target power?” Power: “power given sample size?” Effect size: “’s minimum detectable effect given power sample size?” package offers two modes analysis:","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"when-to-use-aggregate-mode","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"When to Use Aggregate Mode","title":"Power Analysis Workflow","text":"Planning new experiment without pilot data Quick ballpark estimates needed Comparing different experimental scenarios Teaching demonstration purposes","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"choosing-distribution-parameters","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"Choosing Distribution Parameters","title":"Power Analysis Workflow","text":"phosphoproteomics, gamma distributions common. Typical parameters: Conservative estimates use lower shape (skewed, higher variance), optimistic estimates use higher shape (symmetric, lower variance).","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"finding-sample-size","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"Finding Sample Size","title":"Power Analysis Workflow","text":"“many samples per group need 80% power detect 2-fold change?”  power curve shows power increases sample size. recommended N smallest value achieving target.","code":"set.seed(123)  result <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 1000 )  print(result) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Recommended sample size: N=25 per group #> Target power: 80% #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: wilcoxon plot(result)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"finding-power","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"Finding Power","title":"Power Analysis Workflow","text":"“N=6 per group, ’s power detect 2-fold change?”","code":"set.seed(123)  result <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 1000 )  print(result) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 24% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: wilcoxon"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"finding-minimum-detectable-effect","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"Finding Minimum Detectable Effect","title":"Power Analysis Workflow","text":"“N=6 80% target power, ’s smallest effect can reliably detect?”","code":"set.seed(123)  result <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   n_per_group = 6,   target_power = 0.8,   find = \"effect_size\",   n_sim = 1000 )  print(result) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Minimum detectable effect: 5.00-fold #> Sample size: 6 per group #> Target power: 80% #>  #> Significance level: 0.05 #> Statistical test: wilcoxon plot(result)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"sensitivity-to-parameter-choices","dir":"Articles","previous_headings":"Aggregate Mode Deep Dive","what":"Sensitivity to Parameter Choices","title":"Power Analysis Workflow","text":"Let’s see results change different distribution assumptions: unsure, use conservative estimates avoid underpowered experiments.","code":"set.seed(123)  # Conservative (high variance) conservative <- power_analysis(   \"gamma\",   params = list(shape = 1.5, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  # Moderate moderate <- power_analysis(   \"gamma\",   params = list(shape = 2.5, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  # Optimistic (low variance) optimistic <- power_analysis(   \"gamma\",   params = list(shape = 4, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  cat(\"Conservative (shape=1.5): N =\", conservative$answer, \"per group\\n\") #> Conservative (shape=1.5): N = 30 per group cat(\"Moderate (shape=2.5):     N =\", moderate$answer, \"per group\\n\") #> Moderate (shape=2.5):     N = 20 per group cat(\"Optimistic (shape=4):     N =\", optimistic$answer, \"per group\\n\") #> Optimistic (shape=4):     N = 12 per group"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"when-to-use-per-peptide-mode","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"When to Use Per-Peptide Mode","title":"Power Analysis Workflow","text":"pilot data similar experiments Peptide heterogeneity expected want realistic power estimates across peptidome Planning follow-studies","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"step-1-distribution-fitting","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"Step 1: Distribution Fitting","title":"Power Analysis Workflow","text":"First, fit distributions pilot data: use distributions = \"continuous\" abundance data. Use \"counts\" count-based quantification (e.g., spectral counts). Note distribution detection: n=4 per group (8 observations total), distribution selection uncertainty. may see distributions like Pareto Skew Normal selected even true underlying distribution Gamma. normal - fitted parameters still useful power simulation. larger samples (n≥15 per group), correct distribution family reliably identified.","code":"set.seed(42)  # Generate heterogeneous pilot data n_peptides <- 100 n_per_group <- 4  peptide_params <- tibble::tibble(   peptide_id = paste0(\"pep_\", sprintf(\"%04d\", 1:n_peptides)),   shape = runif(n_peptides, 1.5, 5),   rate = runif(n_peptides, 0.01, 0.1) )  pilot_data <- peptide_params |>   dplyr::rowwise() |>   dplyr::mutate(     data = list(tibble::tibble(       condition = rep(c(\"control\", \"treatment\"), each = n_per_group),       replicate = rep(1:n_per_group, 2),       abundance = rgamma(n_per_group * 2, shape = shape, rate = rate)     ))   ) |>   dplyr::ungroup() |>   dplyr::select(peptide_id, data) |>   tidyr::unnest(data) fits <- fit_distributions(   pilot_data,   id = \"peptide_id\",   group = \"condition\",   value = \"abundance\",   distributions = \"continuous\" ) #> Loading required namespace: intervals  print(fits) #> peppwr_fits object #> ------------------ #> 200 peptides fitted #>  #> Best fit distribution counts: #>   Gamma: 13 #>   Normal: 22 #>   Pareto: 124 #>   Skew Normal: 41"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"understanding-fit-results","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"Understanding Fit Results","title":"Power Analysis Workflow","text":"print output shows: - Total peptides fitted - Distribution best-fit models - fit failures summary provides detailed statistics including AIC ranges median values.","code":"summary(fits) #> Summary of peppwr_fits #> ====================== #>  #> Peptides fitted: 200 #> Failed fits: 0 (0.0%) #>  #> Best distribution counts: #>   Gamma: 13 #>   Normal: 22 #>   Pareto: 124 #>   Skew Normal: 41 #>  #> Fit statistics: #>   AIC range: [17.6, Inf] #>   AIC median: 40.5 #>   LogLik range: [-Inf, -5.9] #>   LogLik median: -18.1"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"step-2-per-peptide-power-analysis","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"Step 2: Per-Peptide Power Analysis","title":"Power Analysis Workflow","text":"Now use fits power analysis:  histogram shows distribution power across peptides. Note power varies substantially - peptides achieve near 100% power others remain underpowered.","code":"set.seed(123)  result_pp <- power_analysis(   fits,   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 500 )  print(result_pp) #> peppwr_power analysis #> --------------------- #> Mode: per_peptide #>  #> Power: 55% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: wilcoxon plot(result_pp)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"finding-sample-size-per-peptide","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"Finding Sample Size (Per-Peptide)","title":"Power Analysis Workflow","text":"“sample size gives 80% power peptides?”  “peptide threshold curve” shows proportion peptides achieve target power sample size. 50% line indicates majority peptides become well-powered.","code":"set.seed(123)  result_n <- power_analysis(   fits,   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  print(result_n) #> peppwr_power analysis #> --------------------- #> Mode: per_peptide #>  #> Recommended sample size: N=12 per group #> Target power: 80% #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: wilcoxon plot(result_n)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"interpreting-per-peptide-results","dir":"Articles","previous_headings":"Per-Peptide Mode Deep Dive","what":"Interpreting Per-Peptide Results","title":"Power Analysis Workflow","text":"Key insights per-peptide analysis: Heterogeneity: Power varies across peptides due different underlying distributions Majority rule: recommended N aims power majority (50%+) peptides Underpowered fraction: peptides may never achieve target power practical sample sizes","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"comparing-the-two-modes","dir":"Articles","previous_headings":"","what":"Comparing the Two Modes","title":"Power Analysis Workflow","text":"Let’s run modes data:","code":"set.seed(123)  # Aggregate mode with \"typical\" parameters agg_result <- power_analysis(   \"gamma\",   params = list(shape = 2.5, rate = 0.05),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  # Per-peptide mode pp_result <- power_analysis(   fits,   effect_size = 2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  cat(\"Aggregate mode:   N =\", agg_result$answer, \"per group\\n\") #> Aggregate mode:   N = 20 per group cat(\"Per-peptide mode: N =\", pp_result$answer, \"per group\\n\") #> Per-peptide mode: N = 12 per group"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"when-results-disagree","dir":"Articles","previous_headings":"Comparing the Two Modes","what":"When Results Disagree","title":"Power Analysis Workflow","text":"Per-peptide > Aggregate: peptidome heterogeneous assumed Aggregate > Per-peptide: assumed parameters conservative Large disagreement: Reconsider aggregate assumptions Recommendation: pilot data available, trust per-peptide results.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"statistical-test-options","dir":"Articles","previous_headings":"","what":"Statistical Test Options","title":"Power Analysis Workflow","text":"peppwR supports multiple statistical tests:","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"default-wilcoxon-test","dir":"Articles","previous_headings":"Statistical Test Options","what":"Default: Wilcoxon Test","title":"Power Analysis Workflow","text":"Wilcoxon rank-sum test default : - Makes distributional assumptions - robust outliers - Works well small samples typical proteomics","code":"set.seed(123)  result_wilcox <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   test = \"wilcoxon\",   n_sim = 500 )  print(result_wilcox) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 24% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: wilcoxon"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"bootstrap-t-test","dir":"Articles","previous_headings":"Statistical Test Options","what":"Bootstrap-t Test","title":"Power Analysis Workflow","text":"small samples non-normal data:","code":"set.seed(123)  result_boot <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   test = \"bootstrap_t\",   n_sim = 500 )  print(result_boot) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 28% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: bootstrap_t"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"bayes-factor-test","dir":"Articles","previous_headings":"Statistical Test Options","what":"Bayes Factor Test","title":"Power Analysis Workflow","text":"Bayes factor test provides evidence strength rather p-value. result considered “significant” BF > 3 (substantial evidence).","code":"set.seed(123)  result_bayes <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   test = \"bayes_t\",   n_sim = 500 )  print(result_bayes) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 58% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: bayes_t"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"rank-products-test","dir":"Articles","previous_headings":"Statistical Test Options","what":"Rank Products Test","title":"Power Analysis Workflow","text":"Designed specifically omics experiments:","code":"set.seed(123)  result_rp <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   test = \"rankprod\",   n_sim = 500 )  print(result_rp) #> peppwr_power analysis #> --------------------- #> Mode: aggregate #>  #> Power: 31% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: rankprod"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"diagnostic-plots","dir":"Articles","previous_headings":"","what":"Diagnostic Plots","title":"Power Analysis Workflow","text":"peppwR provides several diagnostic plots assess fit quality explore power landscapes.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"assessing-fit-quality","dir":"Articles","previous_headings":"Diagnostic Plots","what":"Assessing Fit Quality","title":"Power Analysis Workflow","text":"fitting distributions, verify fits reasonable:  density overlay shows observed histogram (blue) fitted distribution curve (red). Good fits show curve closely following histogram shape.  QQ plot, points fall along diagonal line. Systematic deviations indicate poor fit: - S-shaped curve: Distribution wrong tail behavior - Points line right: Heavy right tail data - Points line left: Heavy left tail data","code":"set.seed(42)  # For reproducible peptide selection  # Histogram with fitted density overlay plot_density_overlay(fits, n_overlay = 6) # QQ plots for goodness-of-fit plot_qq(fits, n_plots = 6)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"distribution-of-fit-statistics","dir":"Articles","previous_headings":"Diagnostic Plots","what":"Distribution of Fit Statistics","title":"Power Analysis Workflow","text":"shows AIC values distributed across peptides, grouped best-fitting distribution.","code":"# AIC distribution across the peptidome by best-fit distribution plot_param_distribution(fits)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"exploring-power-landscapes","dir":"Articles","previous_headings":"Diagnostic Plots","what":"Exploring Power Landscapes","title":"Power Analysis Workflow","text":"planning purposes, can visualize power varies across sample sizes effect sizes:  heatmap provides quick lookup table power different experimental designs.","code":"# Power heatmap: sample size vs effect size grid plot_power_heatmap(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.05),   n_range = c(3, 12),   effect_range = c(1.5, 3),   n_steps = 5,   n_sim = 200 ) set.seed(123)  # First create a result to use result_for_plot <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 500 )  # Power sensitivity at fixed sample size plot_power_vs_effect(result_for_plot, effect_range = c(1.2, 4), n_sim = 200)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"handling-missing-data","dir":"Articles","previous_headings":"","what":"Handling Missing Data","title":"Power Analysis Workflow","text":"Proteomics data often contains missing values, particularly low-abundance peptides near detection limit. peppwR tracks models missingness provide realistic power estimates.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"understanding-missingness","dir":"Articles","previous_headings":"Handling Missing Data","what":"Understanding Missingness","title":"Power Analysis Workflow","text":"fit_distributions() function automatically computes missingness statistics peptide:","code":"# Fits object includes missingness statistics print(fits) #> peppwr_fits object #> ------------------ #> 200 peptides fitted #>  #> Best fit distribution counts: #>   Gamma: 13 #>   Normal: 22 #>   Pareto: 124 #>   Skew Normal: 41  # Detailed missingness summary summary(fits)$missingness #> $total_missing #> [1] 0 #>  #> $total_values #> [1] 800 #>  #> $mean_na_rate #> [1] 0 #>  #> $median_na_rate #> [1] 0 #>  #> $max_na_rate #> [1] 0 #>  #> $n_peptides_with_na #> [1] 0 #>  #> $mean_mnar_score #> [1] NaN #>  #> $n_potential_mnar #> [1] 0"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"visualizing-missingness-patterns","dir":"Articles","previous_headings":"Handling Missing Data","what":"Visualizing Missingness Patterns","title":"Power Analysis Workflow","text":"plot shows three panels: Top: Distribution NA rates across peptides Middle: MNAR score histogram - scores 2 (red line) suggest systematic missingness Bottom: Mean abundance vs NA rate, colored MNAR score. negative trend (low abundance → high NA rate) hallmark MNAR proteomics","code":"# Visualize NA rate and MNAR score distributions plot_missingness(fits_na)"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"mnar-detection","dir":"Articles","previous_headings":"Handling Missing Data","what":"MNAR Detection","title":"Power Analysis Workflow","text":"MNAR (Missing Random) occurs probability value missing depends value . proteomics, typically happens low-abundance peptides fall detection limit. peppwR detects MNAR patterns comparing mean rank observed values expected random (MCAR) missingness. positive MNAR score indicates observed values tend higher expected - suggesting low values preferentially missing. identify specific peptides showing MNAR evidence:","code":"# Get peptides with MNAR score > 2 mnar_peptides <- get_mnar_peptides(fits_na, threshold = 2) nrow(mnar_peptides) #> [1] 0  # View top MNAR candidates (if any) head(mnar_peptides) #> # A tibble: 0 × 5 #> # ℹ 5 variables: peptide_id <chr>, condition <chr>, na_rate <dbl>, #> #   mnar_score <dbl>, mean_abundance <dbl>"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"incorporating-missingness-into-simulations","dir":"Articles","previous_headings":"Handling Missing Data","what":"Incorporating Missingness into Simulations","title":"Power Analysis Workflow","text":"realistic power estimates, can incorporate peptide-specific NA rates: include_missingness = TRUE, simulations incorporate peptide’s observed NA rate MNAR pattern, providing power estimates reflect ’d actually observe experiment.","code":"set.seed(123)  # Power analysis accounting for expected NA rates result_na <- power_analysis(   fits_na,   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 500,   include_missingness = TRUE )  print(result_na) #> peppwr_power analysis #> --------------------- #> Mode: per_peptide #>  #> Power: 51% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: wilcoxon"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"fdr-aware-power-analysis","dir":"Articles","previous_headings":"","what":"FDR-Aware Power Analysis","title":"Power Analysis Workflow","text":"Standard power analysis computes per-peptide power nominal alpha (e.g., 0.05). However, thousands peptides, ’ll apply multiple testing correction - affects effective power.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"the-multiple-testing-problem","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"The Multiple Testing Problem","title":"Power Analysis Workflow","text":"testing thousands peptides: - α = 0.05, expect 50 false positives per 1000 true nulls - FDR correction (e.g., Benjamini-Hochberg) controls false discovery rate - makes harder detect true effects","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"running-fdr-adjusted-analysis","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Running FDR-Adjusted Analysis","title":"Power Analysis Workflow","text":"apply_fdr mode simulates entire experiments mixture null alternative peptides, applies Benjamini-Hochberg correction computing power.","code":"set.seed(123)  result_fdr <- power_analysis(   fits,   effect_size = 2,   n_per_group = 6,   find = \"power\",   apply_fdr = TRUE,   prop_null = 0.9,       # 90% of peptides are true nulls   fdr_threshold = 0.05,  # Target 5% FDR   n_sim = 200 )  print(result_fdr) #> peppwr_power analysis #> --------------------- #> Mode: per_peptide #>  #> Power: 5% #> Sample size: 6 per group #> Effect size: 2.00-fold #>  #> Significance level: 0.05 #> Statistical test: wilcoxon #>  #> FDR-adjusted analysis (Benjamini-Hochberg) #> Proportion true nulls: 90% #> FDR threshold: 5%"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"understanding-prop_null","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Understanding prop_null","title":"Power Analysis Workflow","text":"prop_null parameter specifies proportion peptides expect effect: - prop_null = 0.9: 10% peptides show differential abundance - prop_null = 0.95: 5% change (conservative) - prop_null = 0.8: 20% change (liberal) Higher prop_null makes FDR correction stringent, reducing power.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"fdr-vs-uncorrected-power","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"FDR vs Uncorrected Power","title":"Power Analysis Workflow","text":"FDR-adjusted power typically lower BH correction requires stronger evidence call discoveries. Use FDR mode want know many true positives ’ll actually detect correction.","code":"set.seed(123)  # Uncorrected (per-peptide) power result_uncorr <- power_analysis(   fits,   effect_size = 2,   n_per_group = 6,   find = \"power\",   n_sim = 200 )  cat(\"Uncorrected power: \", round(result_uncorr$answer * 100), \"%\\n\", sep = \"\") #> Uncorrected power: 55% cat(\"FDR-adjusted power:\", round(result_fdr$answer * 100), \"%\\n\", sep = \"\") #> FDR-adjusted power:5%"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"fit-failures","dir":"Articles","previous_headings":"Handling Edge Cases","what":"Fit Failures","title":"Power Analysis Workflow","text":"distributions fail fit peptides, three options: Recommendations: - Start \"exclude\" see many peptides fail - Use \"lognormal\" fit failures common enough data points - Use \"empirical\" want purely data-driven simulation without distribution assumptions","code":"set.seed(123)  # Option 1: Exclude failed fits (default) result_exclude <- power_analysis(fits, effect_size = 2, n_per_group = 6,                                  find = \"power\", on_fit_failure = \"exclude\", n_sim = 200)  # Option 2: Use lognormal fallback result_lognorm <- power_analysis(fits, effect_size = 2, n_per_group = 6,                                  find = \"power\", on_fit_failure = \"lognormal\", n_sim = 200)  # Option 3: Bootstrap from empirical data result_empirical <- power_analysis(fits, effect_size = 2, n_per_group = 6,                                    find = \"power\", on_fit_failure = \"empirical\", n_sim = 200)  cat(\"Exclude failures:    \", round(result_exclude$answer * 100), \"% power\\n\", sep = \"\") #> Exclude failures:    55% power cat(\"Lognormal fallback:  \", round(result_lognorm$answer * 100), \"% power\\n\", sep = \"\") #> Lognormal fallback:  55% power cat(\"Empirical bootstrap: \", round(result_empirical$answer * 100), \"% power\\n\", sep = \"\") #> Empirical bootstrap: 55% power"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"very-small-pilot-datasets","dir":"Articles","previous_headings":"Handling Edge Cases","what":"Very Small Pilot Datasets","title":"Power Analysis Workflow","text":"<3 replicates per group: - Distribution fitting may unreliable - Consider aggregate mode conservative parameters - Increase n_sim stable estimates","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"extreme-effect-sizes","dir":"Articles","previous_headings":"Handling Edge Cases","what":"Extreme Effect Sizes","title":"Power Analysis Workflow","text":"large effects (>5-fold) typically achieve high power minimal samples. small effects (<1.2-fold) may require impractically large samples.","code":"set.seed(123)  # Large effect large <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 5,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  # Small effect small <- power_analysis(   \"gamma\",   params = list(shape = 2, rate = 0.05),   effect_size = 1.2,   target_power = 0.8,   find = \"sample_size\",   n_sim = 500 )  cat(\"5-fold change:   N =\", large$answer, \"per group\\n\") #> 5-fold change:   N = 6 per group cat(\"1.2-fold change: N =\", small$answer, \"per group\\n\") #> 1.2-fold change: N = 50 per group"},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Power Analysis Workflow","text":"Start aggregate mode quick estimates planning Use per-peptide mode pilot data available accurate estimates Consider heterogeneity - peptides behave Choose appropriate tests - Wilcoxon safe default conservative - underpowered experiments waste resources","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/power-analysis-workflow.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Power Analysis Workflow","text":"Getting Started: See vignette(\"getting-started\") minimal workflow Benchmarking: See vignette(\"benchmarking\") performance large datasets","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"what-makes-targeted-proteomics-different","dir":"Articles","previous_headings":"Introduction","what":"What Makes Targeted Proteomics Different?","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Mass spectrometry-based proteomics operates two fundamentally different modes: Discovery proteomics (DDA) casts wide net: Measures thousands proteins/peptides Identifies whatever abundant enough detect Great hypothesis generation High multiple testing burden Targeted proteomics (PRM/SRM) takes aim specific targets: Measures pre-defined panel peptides Higher sensitivity reproducibility Better hypothesis testing Lower multiple testing burden document analyzes PRM dataset, demonstrating peppwR handles unique challenges targeted proteomics, including missing data FDR considerations.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"the-missing-data-challenge","dir":"Articles","previous_headings":"Introduction","what":"The Missing Data Challenge","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Even targeted methods, missing values ubiquitous mass spectrometry. missing data created equal: MCAR (Missing Completely Random) Values missing due random technical failures relationship abundance Reduces sample size doesn’t bias results MNAR (Missing Random) Low-abundance peptides systematically missing detection limit = measurement Can bias abundance estimates upward Common mass spectrometry peppwR tracks rate missingness evidence MNAR patterns, enabling realistic power estimates.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"goals-of-this-analysis","dir":"Articles","previous_headings":"Introduction","what":"Goals of This Analysis","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Characterize missingness patterns data Identify peptides MNAR evidence Compare statistical tests small sample sizes Determine realistic sample size requirements Understand FDR impact power","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"about-the-data","dir":"Articles","previous_headings":"","what":"About the Data","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"analysis uses fungal phosphoproteomics data targeted PRM experiment:","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"data-preparation","dir":"Articles","previous_headings":"","what":"Data Preparation","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"","code":"library(peppwR) library(dplyr) library(ggplot2) library(tibble) # Load the PRM experiment data prm <- read.csv(\"../../sample_data/prm_data.csv\")  # Examine the structure glimpse(prm) ## Rows: 20,520 ## Columns: 7 ## $ molecule_list_name        <chr> \"gi|145601729|ref|XP_363034.2|\", \"gi|1456017… ## $ peptide_modified_sequence <chr> \"KLS[+80]ASGS[+80]PGSVNLGR\", \"KLS[+80]ASGS[+… ## $ genotype                  <chr> \"Guy11\", \"Guy11\", \"Guy11\", \"Guy11\", \"Guy11\",… ## $ timepoint                 <dbl> 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0,… ## $ bio_rep                   <int> 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2,… ## $ tech_rep                  <int> 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,… ## $ total_area                <dbl> 1.031275e-03, 1.130267e-03, 5.243216e-04, 2.… # Check for missing values in raw data cat(\"Total observations:\", nrow(prm), \"\\n\") ## Total observations: 20520 cat(\"Missing values:\", sum(is.na(prm$total_area)), \"\\n\") ## Missing values: 3547 cat(\"Missing rate:\", round(mean(is.na(prm$total_area)) * 100, 1), \"%\\n\") ## Missing rate: 17.3 %"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"why-average-technical-replicates","dir":"Articles","previous_headings":"Data Preparation","what":"Why Average Technical Replicates?","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Technical replicates measure biological sample multiple times. capture measurement variability, biological variability. power analysis, biological replicates true unit replication - represent independent observations biological phenomenon ’re studying. average technical replicates get one value per biological replicate.","code":"# Filter to early (0) vs late (6) timepoints # Average technical replicates within each biological replicate pilot <- prm |>   filter(timepoint %in% c(0, 6)) |>   group_by(peptide_modified_sequence, genotype, timepoint, bio_rep) |>   summarise(abundance = mean(total_area, na.rm = TRUE), .groups = \"drop\") |>   transmute(     peptide_id = peptide_modified_sequence,     condition = paste0(\"t\", timepoint),     abundance = abundance   )  # Summary statistics cat(\"Unique peptides:\", n_distinct(pilot$peptide_id), \"\\n\") ## Unique peptides: 285 cat(\"Observations per condition:\\n\") ## Observations per condition: pilot |> count(condition) ## # A tibble: 2 × 2 ##   condition     n ##   <chr>     <int> ## 1 t0         1710 ## 2 t6         1710 # Check missingness after averaging technical replicates # (NaN results when both tech reps are NA) pilot <- pilot |>   mutate(abundance = ifelse(is.nan(abundance), NA, abundance))  cat(\"Missing after averaging tech reps:\", sum(is.na(pilot$abundance)), \"\\n\") ## Missing after averaging tech reps: 429 cat(\"Missing rate:\", round(mean(is.na(pilot$abundance)) * 100, 1), \"%\\n\") ## Missing rate: 12.5 %"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"examining-the-extent-of-missingness","dir":"Articles","previous_headings":"Missingness Analysis","what":"Examining the Extent of Missingness","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"diving power analysis, need understand missing data. peppwR automatically computes missingness statistics distribution fitting.","code":"# Fit distributions - missingness is tracked automatically fits <- fit_distributions(pilot, \"peptide_id\", \"condition\", \"abundance\")  # Summary includes missingness information print(fits) ## peppwr_fits object ## ------------------ ## 570 peptides fitted ##  ## Best fit distribution counts: ##   Gamma: 103 ##   Inverse Gaussian: 36 ##   InvGamma: 2 ##   Lognormal: 5 ##   Normal: 90 ##   Pareto: 273 ##   Skew Normal: 61 ##  ## Missingness: 429/3420 values NA (12.5%) ## Peptides with missing data: 180 ##   MNAR pattern: 0 of 180 peptides with missing data (score > 2)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"visualizing-missingness-patterns","dir":"Articles","previous_headings":"Missingness Analysis","what":"Visualizing Missingness Patterns","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"plot_missingness() function provides three complementary views: NA Rate Distribution: fraction observations missing peptide? MNAR Score Distribution: evidence missingness correlates abundance? Abundance vs NA Rate: low-abundance peptides missing values? Missingness patterns across PRM peptidome. Left: Distribution NA rates. Middle: MNAR scores (z-statistic; values > 2 suggest informative missingness). Right: Relationship mean abundance NA rate.","code":"plot_missingness(fits)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"interpreting-mnar-scores","dir":"Articles","previous_headings":"Missingness Analysis","what":"Interpreting MNAR Scores","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"MNAR score z-statistic testing whether missing observations systematically different (lower) abundance observed values. Higher scores indicate stronger evidence informative missingness.","code":"# Identify peptides with strong MNAR evidence mnar_peptides <- get_mnar_peptides(fits, threshold = 2)  cat(\"Peptides with MNAR evidence (z > 2):\", nrow(mnar_peptides), \"\\n\") ## Peptides with MNAR evidence (z > 2): 0 if (nrow(mnar_peptides) > 0) {   cat(\"\\nTop MNAR peptides:\\n\")   print(head(mnar_peptides, 10)) }"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"what-to-do-with-mnar-peptides","dir":"Articles","previous_headings":"Missingness Analysis","what":"What to Do with MNAR Peptides","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Peptides high MNAR scores require careful handling: abundance estimates may biased upward (low values missing) Power calculations may optimistic Consider robust statistical methods Report separately publications","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"distribution-fitting-results","dir":"Articles","previous_headings":"","what":"Distribution Fitting Results","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Best-fit distribution counts PRM data.","code":"plot(fits)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"interpreting-distribution-fitting-a-cautionary-note","dir":"Articles","previous_headings":"Distribution Fitting Results","what":"Interpreting Distribution Fitting: A Cautionary Note","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Important: Like DDA dataset, see certain distributions may dominate “best fit” counts. artifact small sample size (6 observations per peptide averaged across tech reps), statement true underlying distributions. biological replicates, expect gamma lognormal distributions fit better - typical distributions mass spectrometry abundance data.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"parameter-distribution","dir":"Articles","previous_headings":"Distribution Fitting Results","what":"Parameter Distribution","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Distribution AIC values across peptides fitted distribution.","code":"p <- plot_param_distribution(fits) print(p) # Count peptides per best-fit distribution cat(\"\\nPeptides per best-fit distribution:\\n\") ##  ## Peptides per best-fit distribution: tibble(distribution = fits$best) |>   count(distribution) |>   arrange(desc(n)) ## # A tibble: 7 × 2 ##   distribution         n ##   <chr>            <int> ## 1 Pareto             273 ## 2 Gamma              103 ## 3 Normal              90 ## 4 Skew Normal         61 ## 5 Inverse Gaussian    36 ## 6 Lognormal            5 ## 7 InvGamma             2"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"choosing-the-right-statistical-test","dir":"Articles","previous_headings":"Power Analysis","what":"Choosing the Right Statistical Test","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Critical first step: small samples (N=3), test choice dramatically affects power. committing detailed analyses, compare available tests. Power comparison across statistical tests (N=3, 2-fold effect)","code":"# Run all three tests (use n_sim = 100 for faster rendering) power_wilcox <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                 find = \"power\", test = \"wilcoxon\", n_sim = 100)  power_boot <- power_analysis(fits, effect_size = 2, n_per_group = 3,                               find = \"power\", test = \"bootstrap_t\", n_sim = 100)  power_bayes <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                find = \"power\", test = \"bayes_t\", n_sim = 100)  # Create comparison table comparison <- tibble(   Test = c(\"Wilcoxon rank-sum\", \"Bootstrap-t\", \"Bayes factor\"),   `Median Power` = c(     median(power_wilcox$simulations$peptide_power, na.rm = TRUE),     median(power_boot$simulations$peptide_power, na.rm = TRUE),     median(power_bayes$simulations$peptide_power, na.rm = TRUE)   ),   `% > 50% Power` = c(     mean(power_wilcox$simulations$peptide_power > 0.5, na.rm = TRUE) * 100,     mean(power_boot$simulations$peptide_power > 0.5, na.rm = TRUE) * 100,     mean(power_bayes$simulations$peptide_power > 0.5, na.rm = TRUE) * 100   ),   `% > 80% Power` = c(     mean(power_wilcox$simulations$peptide_power > 0.8, na.rm = TRUE) * 100,     mean(power_boot$simulations$peptide_power > 0.8, na.rm = TRUE) * 100,     mean(power_bayes$simulations$peptide_power > 0.8, na.rm = TRUE) * 100   ) )  knitr::kable(comparison, digits = 2,              caption = \"Power comparison across statistical tests (N=3, 2-fold effect)\")"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"understanding-the-test-comparison-results","dir":"Articles","previous_headings":"Power Analysis","what":"Understanding the Test Comparison Results","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"table shows different tests perform small sample sizes: Wilcoxon rank-sum conservative - non-parametric tests trade statistical assumptions larger sample size requirements. Bootstrap-t uses resampling handle non-normality, potentially offering intermediate power. Bayes factor tests quantify evidence effect, often performing better small N. remaining analyses: use Bayes factor test since provides usable power estimates N=3.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"the-three-questions","dir":"Articles","previous_headings":"Power Analysis","what":"The Three Questions","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Power analysis can answer three related questions: Power: Given N effect size, power ? Sample size: Given target power effect size, N need? Minimum detectable effect: Given N target power, effect can detect?","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"question-1-what-power-do-we-have","dir":"Articles","previous_headings":"Power Analysis","what":"Question 1: What Power Do We Have?","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"3 biological replicates 2-fold effect, power achieve? Distribution power across peptides N=3 2-fold effect (Bayes factor test).","code":"# Using Bayes factor test based on comparison results power_current <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                  find = \"power\", test = \"bayes_t\", n_sim = 100) print(power_current) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Power: 60% ## Sample size: 3 per group ## Effect size: 2.00-fold ##  ## Significance level: 0.05 ## Statistical test: bayes_t plot(power_current)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"question-2-what-sample-size-do-we-need","dir":"Articles","previous_headings":"Power Analysis","what":"Question 2: What Sample Size Do We Need?","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"N achieve 80% power detect 2-fold change? Percentage peptides achieving 80% power sample size.","code":"sample_size <- power_analysis(fits, effect_size = 2, target_power = 0.8,                               find = \"sample_size\", test = \"bayes_t\", n_sim = 100) print(sample_size) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Recommended sample size: N=10 per group ## Target power: 80% ## Effect size: 2.00-fold ##  ## Significance level: 0.05 ## Statistical test: bayes_t plot(sample_size)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"question-3-whats-the-minimum-detectable-effect","dir":"Articles","previous_headings":"Power Analysis","what":"Question 3: What’s the Minimum Detectable Effect?","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"N=3, ’s smallest effect can reliably detect? Understanding two thresholds: per-peptide mode, two distinct thresholds: target_power (set 0.8) - power level individual peptide must achieve proportion_threshold (default 0.5) - fraction peptides must reach target_power plot shows “% peptides reaching 80% power” y-axis. answer tells us: “effect size 50% peptides achieve 80% power?” Proportion peptides reaching 80% power effect size. default threshold 50% peptides. tells us effect sizes realistically detectable current sample sizes. require peptides well-powered, increase proportion_threshold.","code":"min_effect <- power_analysis(fits, n_per_group = 3, target_power = 0.8,                              find = \"effect_size\", test = \"bayes_t\", n_sim = 100) print(min_effect) ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Minimum detectable effect: 5.00-fold ## Sample size: 3 per group ## Target power: 80% ##  ## Significance level: 0.05 ## Statistical test: bayes_t plot(min_effect)"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"impact-of-missingness-on-power","dir":"Articles","previous_headings":"Power Analysis","what":"Impact of Missingness on Power","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"accounting missingness affect power estimates? Accounting missingness typically reduces power estimates - realistic cost missing data experiment’s ability detect effects.","code":"# Power without accounting for missingness (optimistic) power_no_miss <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                  find = \"power\", test = \"bayes_t\",                                  include_missingness = FALSE, n_sim = 100)  # Power accounting for missingness (realistic) power_with_miss <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                    find = \"power\", test = \"bayes_t\",                                    include_missingness = TRUE, n_sim = 100)  cat(\"Median power WITHOUT missingness:\",     round(median(power_no_miss$simulations$peptide_power, na.rm = TRUE), 3), \"\\n\") ## Median power WITHOUT missingness: 0.57 cat(\"Median power WITH missingness:   \",     round(median(power_with_miss$simulations$peptide_power, na.rm = TRUE), 3), \"\\n\") ## Median power WITH missingness:    0.56"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"why-fdr-matters","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Why FDR Matters","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"285 peptides tested, multiple testing concern. use alpha = 0.05 test, expect ~14 false positives chance alone (285 x 0.05 = 14.25). FDR (False Discovery Rate) control methods like Benjamini-Hochberg adjust p-values control expected proportion false discoveries. stringent nominal testing reduces power.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"understanding-prop_null","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Understanding prop_null","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"prop_null parameter specifies assumed proportion true null hypotheses - peptides real effect. affects FDR correction stringency: targeted proteomics, typically select peptides expected change, prop_null might lower discovery experiments.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"standard-vs-fdr-corrected-power","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Standard vs FDR-Corrected Power","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"","code":"# Standard power (nominal alpha = 0.05) power_nominal <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                 find = \"power\", test = \"bayes_t\",                                 apply_fdr = FALSE, n_sim = 100)  # FDR-aware power (BH correction) # prop_null = 0.8 means we assume 80% of peptides have no true effect power_fdr <- power_analysis(fits, effect_size = 2, n_per_group = 3,                             find = \"power\", test = \"bayes_t\",                             apply_fdr = TRUE, prop_null = 0.8,                             fdr_threshold = 0.05, n_sim = 100) # Extract power values safely nominal_power <- power_nominal$simulations$peptide_power fdr_power <- power_fdr$simulations$peptide_power  cat(\"Nominal power (no FDR correction):\\n\") ## Nominal power (no FDR correction): if (is.numeric(nominal_power) && length(nominal_power) > 0) {   cat(\"  Median power:\", round(median(nominal_power, na.rm = TRUE), 3), \"\\n\")   cat(\"  % peptides > 80% power:\", round(mean(nominal_power > 0.8, na.rm = TRUE) * 100, 1), \"%\\n\") } else {   print(power_nominal) } ##   Median power: 0.58  ##   % peptides > 80% power: 17.2 % cat(\"\\nFDR-aware power (BH correction, 80% true nulls):\\n\") ##  ## FDR-aware power (BH correction, 80% true nulls): if (is.numeric(fdr_power) && length(fdr_power) > 0) {   cat(\"  Median power:\", round(median(fdr_power, na.rm = TRUE), 3), \"\\n\")   cat(\"  % peptides > 80% power:\", round(mean(fdr_power > 0.8, na.rm = TRUE) * 100, 1), \"%\\n\") } else {   print(power_fdr) } ## peppwr_power analysis ## --------------------- ## Mode: per_peptide ##  ## Power: 8% ## Sample size: 3 per group ## Effect size: 2.00-fold ##  ## Significance level: 0.05 ## Statistical test: bayes_t ##  ## FDR-adjusted analysis (Benjamini-Hochberg) ## Proportion true nulls: 80% ## FDR threshold: 5%"},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"understanding-the-fdr-impact","dir":"Articles","previous_headings":"FDR-Aware Power Analysis","what":"Understanding the FDR Impact","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"FDR correction reduces power : evidence required: Adjusted p-values larger, requiring stronger effects reach significance Depends number tests: peptides = stringent correction Depends true effect proportion: peptides true effects (prop_null low), FDR correction less severe targeted panel 285 peptides, FDR impact modest discovery proteomics thousands tests.","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"key-findings","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Key Findings","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"Missingness patterns: PRM dataset ~17% missing values. peptides may show evidence MNAR (informative missingness), low-abundance values preferentially missing. Distribution fitting: 6 observations per peptide (averaging tech reps), distribution selection unreliable. small sample size artifact, reflection true underlying distributions. Test selection: Different statistical tests show varying power small N. Bayes factor tests can provide informative estimates conservative non-parametric tests samples limited. Missingness impact: Accounting missing data reduces power estimates - reflects real cost missingness. FDR impact: 285 peptides, FDR correction modestly reduces power compared nominal testing.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"practical-recommendations","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Practical Recommendations","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"future experiments: Consider N=6 biological replicates reliable detection 2-fold changes. current data: Set realistic expectations detectable effect sizes. Subtle changes may detectable N=3. Test selection: small samples, Bayes factor tests may informative traditional frequentist approaches. MNAR peptides: Report peptides high MNAR scores separately interpret results cautiously.","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"targeted-vs-discovery-considerations","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Targeted vs Discovery Considerations","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"PRM dataset (285 peptides) advantages discovery proteomics: Lower multiple testing burden: Fewer tests = less severe FDR correction Focused power: Resources concentrated peptides interest Better reproducibility: Targeted methods lower technical variability However: discovery: Can’t detect unexpected changes Panel bias: Limited pre-selected targets","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"caveats","dir":"Articles","previous_headings":"Summary and Recommendations","what":"Caveats","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"analysis combines genotypes; genotype-specific analyses may differ Technical replicate averaging reduces noise masks technical variability MNAR models approximations; true missing data mechanisms may complex prop_null parameter requires assumptions true effect rates Distribution fitting limited small sample size","code":""},{"path":"https://teammaclean.github.io/peppwR/articles/prm-genotype-power.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Power Analysis for Targeted Proteomics with Missing Data (PRM)","text":"","code":"sessionInfo() ## R version 4.5.2 (2025-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices datasets  utils     methods   base      ##  ## other attached packages: ## [1] tibble_3.3.1  ggplot2_4.0.2 dplyr_1.2.0   peppwR_0.1.0  ##  ## loaded via a namespace (and not attached): ##  [1] sass_0.4.10         utf8_1.2.6          generics_0.1.4      ##  [4] tidyr_1.3.2         renv_0.12.2         lattice_0.22-7      ##  [7] fGarch_4052.93      digest_0.6.39       magrittr_2.0.4      ## [10] evaluate_1.0.5      grid_4.5.2          RColorBrewer_1.1-3  ## [13] fastmap_1.2.0       Matrix_1.7-4        jsonlite_2.0.0      ## [16] mgcv_1.9-3          purrr_1.2.1         scales_1.4.0        ## [19] gbutils_0.5.1       textshaping_1.0.4   jquerylib_0.1.4     ## [22] Rdpack_2.6.5        cli_3.6.5           timeSeries_4052.112 ## [25] rlang_1.1.7         rbibutils_2.4.1     splines_4.5.2       ## [28] cowplot_1.2.0       intervals_0.15.5    withr_3.0.2         ## [31] cachem_1.1.0        yaml_2.3.12         cvar_0.6            ## [34] tools_4.5.2         assertthat_0.2.1    vctrs_0.7.1         ## [37] R6_2.6.1            lifecycle_1.0.5     fs_1.6.6            ## [40] univariateML_1.5.0  ragg_1.5.0          pkgconfig_2.0.3     ## [43] desc_1.4.3          pkgdown_2.2.0       pillar_1.11.1       ## [46] bslib_0.10.0        gtable_0.3.6        glue_1.8.0          ## [49] systemfonts_1.3.1   xfun_0.56           tidyselect_1.2.1    ## [52] knitr_1.51          farver_2.1.2        spatial_7.3-18      ## [55] nlme_3.1-168        htmltools_0.5.9     fBasics_4052.98     ## [58] labeling_0.4.3      rmarkdown_2.30      timeDate_4052.112   ## [61] compiler_4.5.2      S7_0.2.1"},{"path":"https://teammaclean.github.io/peppwR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dan MacLean. Author, maintainer.","code":""},{"path":"https://teammaclean.github.io/peppwR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"MacLean D (2026). peppwR: Power Analysis Phosphopeptide Abundance Hypothesis Test. R package version 0.1.0, https://teammaclean.github.io/peppwR/.","code":"@Manual{,   title = {peppwR: Power Analysis For Phosphopeptide Abundance Hypothesis Test},   author = {Dan MacLean},   year = {2026},   note = {R package version 0.1.0},   url = {https://teammaclean.github.io/peppwR/}, }"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Create two static analysis documents demonstrating peppwR real phosphoproteomics data. pre-rendered examples (vignettes) stored inst/examples/ committed HTML output. Key changes v2: - Fixed incorrect assumptions results - text must match rendered figures - Wilcoxon test essentially zero power N=3 2-fold effect - restructure discover early - Use Bayes factor test primary test comparison reveals Wilcoxon’s limitations - Distribution fitting shows Pareto/Skew Normal dominance (artifact small sample size) - explain - Remove/rework minimum detectable effect section (empty plots Wilcoxon) - Improve PRM pedagogical tone match DDA document","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"distribution-fitting-results","dir":"","previous_headings":"Critical Learnings from v2 Rendering","what":"Distribution Fitting Results","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Observed: Pareto Skew Normal best fits, lognormal/gamma Reason: N=3 per condition (6 observations per peptide), ’s insufficient data reliable distribution selection. Gamma/lognormal expected data. Action: Explain artifact small sample size, statement true underlying distributions","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"wilcoxon-test-power","dir":"","previous_headings":"Critical Learnings from v2 Rendering","what":"Wilcoxon Test Power","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Observed: Essentially zero power N=3 2-fold effect Reason: Non-parametric tests like Wilcoxon conservative need larger samples Action: Compare tests EARLY analysis discover , switch Bayes factor","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"minimum-detectable-effect","dir":"","previous_headings":"Critical Learnings from v2 Rendering","what":"Minimum Detectable Effect","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Observed: Empty plots showing nothing detectable even 0% power threshold Reason: Wilcoxon power, MDE analysis meaningless Action: Either remove section run Bayes factor test","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"power-analysis-plots","dir":"","previous_headings":"Critical Learnings from v2 Rendering","what":"Power Analysis Plots","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Observed: Empty histograms showing peptides achieve power Action: discovering Wilcoxon’s limitations, redo Bayes factor show meaningful results","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"dda-data-sample_datadda_datacsv","dir":"","previous_headings":"Data Summary","what":"DDA Data (sample_data/dda_data.csv)","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Source: Arabidopsis phosphoproteomics Peptides: 2,228 unique phosphopeptides Comparison: Timepoint 0 vs 600 (earliest vs latest) Replicates: 3 biological replicates per timepoint (6 observations per peptide total) Missing: 0% Key columns: new_annotation (peptide ID), genotype, bio_rep, timepoints, timepoints_values (abundance)","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"prm-data-sample_dataprm_datacsv","dir":"","previous_headings":"Data Summary","what":"PRM Data (sample_data/prm_data.csv)","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Source: Fungal phosphoproteomics (rice blast) Peptides: 285 unique phosphopeptides Comparison: Timepoint 0 vs 6 (earliest vs latest) Replicates: 3 bio × 2 tech per condition Missing: 17% (good missingness demo) Key columns: peptide_modified_sequence (peptide ID), genotype, timepoint, bio_rep, tech_rep, total_area (abundance)","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"document-1-dda-time-course-power-analysis","dir":"","previous_headings":"","what":"Document 1: DDA Time-Course Power Analysis","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"File: inst/examples/dda-time-course-power.Rmd","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"revised-outline","dir":"","previous_headings":"Document 1: DDA Time-Course Power Analysis","what":"Revised Outline","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Present results clear table: Key finding: Wilcoxon essentially zero power N=3. expected - non-parametric tests conservative need larger samples. Bayes factor test provides usable power estimates. remaining analyses, use Bayes factor test.","code":"# Power Analysis for Time-Course Phosphoproteomics (DDA)  ## Introduction - What is statistical power and why does it matter? - The challenge: phosphoproteomics experiments are expensive, sample sizes are small - Goal: Determine what effects we can detect and plan future experiments - Overview of the peppwR approach: fit distributions → simulate experiments → estimate power  ## About the Data - Arabidopsis phosphoproteomics time-course experiment - DDA (Data-Dependent Acquisition) mass spectrometry - Comparing early (t=0) vs late (t=600) timepoints - 3 biological replicates per condition (important limitation!) - 2,228 phosphopeptides quantified  ## Data Preparation - Load and filter data - Reshape for peppwR (peptide_id, condition, abundance) - Quick EDA: abundance distribution across conditions  ## Distribution Fitting - Why fit distributions? (To simulate realistic experiments) - Run fit_distributions() - **Interpret results honestly**: Pareto and Skew Normal dominate - **Explain why**: With only 6 observations per peptide, distribution selection is unreliable - This is an artifact of small sample size, not the \"true\" underlying distributions - With more replicates, gamma/lognormal would likely fit better - plot_param_distribution() with sample size context  ## Power Analysis  ### Choosing the Right Statistical Test  **IMPORTANT: Start with test comparison before doing other analyses**  With small samples (N=3), the choice of statistical test dramatically affects power:  | Test | Type | Characteristics | |------|------|-----------------| | Wilcoxon rank-sum | Non-parametric | Conservative, needs larger N | | Bootstrap-t | Resampling | Handles non-normality | | Bayes factor | Bayesian | More powerful at small N |  Compare all three tests at N=3 with 2-fold effect:  ```r # Run all three tests power_wilcox <- power_analysis(fits, effect_size = 2, n_per_group = 3, test = \"wilcoxon\") power_boot <- power_analysis(fits, effect_size = 2, n_per_group = 3, test = \"bootstrap_t\") power_bayes <- power_analysis(fits, effect_size = 2, n_per_group = 3, test = \"bayes_t\")"},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"the-three-questions-using-bayes-factor","dir":"","previous_headings":"Document 1: DDA Time-Course Power Analysis","what":"The Three Questions (Using Bayes Factor)","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Power analysis can answer three related questions: 1. Given sample size effect size → power? 2. Given target power effect size → sample size need? 3. Given sample size target power → ’s minimum detectable effect?","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"question-1-current-power-n3-bayes-factor","dir":"","previous_headings":"Document 1: DDA Time-Course Power Analysis","what":"Question 1: Current Power (N=3, Bayes Factor)","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"3 replicates, power detect 2-fold change? Show actual distribution power across peptides Interpret: “X% peptides achieve >80% power”","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"question-2-sample-size-for-target-power","dir":"","previous_headings":"Document 1: DDA Time-Course Power Analysis","what":"Question 2: Sample Size for Target Power","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"N need 80% power 2-fold change? (use realistic effect) Understanding power curve Show % peptides reaching target N","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"question-3-minimum-detectable-effect","dir":"","previous_headings":"Document 1: DDA Time-Course Power Analysis","what":"Question 3: Minimum Detectable Effect","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"KNOWN ISSUE: find = \"effect_size\" YET IMPLEMENTED per-peptide mode. See CLAUDE.md “Known Issues” section details fix plan. Current workaround options: 1. Remove section per-peptide examples implemented 2. Use aggregate mode representative parameters derived fits: ```r # Derive representative lognormal params fitted data # (peptides approximately lognormal log scale) log_abundances <- log(pilotabundance[pilotabundance[pilotabundance > 0]) representative_params <- list( meanlog = median(log_abundances), sdlog = sd(log_abundances) ) # Run MDE aggregate mode min_effect <- power_analysis( distribution = “lnorm”, params = representative_params, n_per_group = 3, target_power = 0.8, find = “effect_size”, test = “bayes_t”, n_sim = 100 ) ``` 3. Wait v2.2 implementation per-peptide MDE Recommendation: now, remove Question 3 per-peptide examples use aggregate mode clear explanation represents “typical” peptide, full peptidome distribution.","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"why-aggregate-mode-for-heatmaps","dir":"","previous_headings":"Power Heatmap","what":"Why Aggregate Mode for Heatmaps?","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"plot_power_heatmap() function uses aggregate mode (single distribution) rather per-peptide mode : Computational cost: Per-peptide heatmaps require n_peptides × n_values × effect_values × n_sim simulations (e.g., 2228 × 10 × 10 × 100 = 22M simulations) Visualization: single heatmap interpretable 2000+ individual heatmaps Purpose: Heatmaps answer “’s general tradeoff?” “’s power peptide X?”","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"deriving-representative-parameters","dir":"","previous_headings":"Power Heatmap","what":"Deriving Representative Parameters","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"make heatmap relevant data, derive parameters fitted distributions:","code":"# Option 1: Use median log-abundance parameters log_abundances <- log(pilot$abundance[pilot$abundance > 0]) params <- list(   meanlog = median(log_abundances),   sdlog = mad(log_abundances, constant = 1)  # robust SD estimate )  # Option 2: For gamma-like data, use moment matching abundances <- pilot$abundance[pilot$abundance > 0] m <- mean(abundances) v <- var(abundances) params <- list(   shape = m^2 / v,   rate = m / v )"},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"heatmap-code-with-explanation","dir":"","previous_headings":"Power Heatmap","what":"Heatmap Code with Explanation","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"","code":"# Derive representative parameters from the data log_abundances <- log(pilot$abundance[pilot$abundance > 0]) derived_params <- list(   meanlog = median(log_abundances),   sdlog = mad(log_abundances, constant = 1) )  cat(\"Using representative lognormal parameters:\\n\") cat(\"  meanlog =\", round(derived_params$meanlog, 2), \"\\n\") cat(\"  sdlog =\", round(derived_params$sdlog, 2), \"\\n\")  # Generate heatmap plot_power_heatmap(   distribution = \"lnorm\",   params = derived_params,   n_range = c(3, 12),   effect_range = c(1.5, 4),   test = \"wilcoxon\"  # heatmap uses aggregate mode )"},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"interpreting-the-heatmap","dir":"","previous_headings":"Power Heatmap","what":"Interpreting the Heatmap","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"heatmap shows power representative peptide typical abundance characteristics. Individual peptides vary: - Low-variability peptides higher power shown - High-variability peptides lower power shown - Use per-peptide find = \"power\" results understand distribution across peptides","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"summary-and-recommendations","dir":"","previous_headings":"","what":"Summary and Recommendations","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Distribution fitting unreliable N=3 (Pareto/Skew Normal artifact) Wilcoxon test power N=3 - use Bayes factor instead Actual power estimates Bayes factor Minimum sample size reliable detection Effect sizes detectable Caveats limitations","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"session-info","dir":"","previous_headings":"","what":"Session Info","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"","code":"### Key Code Changes  ```r # Test comparison - do this FIRST power_wilcox <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                 find = \"power\", test = \"wilcoxon\", n_sim = 100) power_boot <- power_analysis(fits, effect_size = 2, n_per_group = 3,                               find = \"power\", test = \"bootstrap_t\", n_sim = 100) power_bayes <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                find = \"power\", test = \"bayes_t\", n_sim = 100)  # Create comparison table comparison <- tibble::tibble(   Test = c(\"Wilcoxon rank-sum\", \"Bootstrap-t\", \"Bayes factor\"),   `Median Power` = c(     median(power_wilcox$simulations$peptide_power, na.rm = TRUE),     median(power_boot$simulations$peptide_power, na.rm = TRUE),     median(power_bayes$simulations$peptide_power, na.rm = TRUE)   ),   `% > 50% Power` = c(     mean(power_wilcox$simulations$peptide_power > 0.5, na.rm = TRUE) * 100,     mean(power_boot$simulations$peptide_power > 0.5, na.rm = TRUE) * 100,     mean(power_bayes$simulations$peptide_power > 0.5, na.rm = TRUE) * 100   ),   `% > 80% Power` = c(     mean(power_wilcox$simulations$peptide_power > 0.8, na.rm = TRUE) * 100,     mean(power_boot$simulations$peptide_power > 0.8, na.rm = TRUE) * 100,     mean(power_bayes$simulations$peptide_power > 0.8, na.rm = TRUE) * 100   ) ) knitr::kable(comparison, digits = 2)  # Subsequent analyses use Bayes factor power_n3 <- power_analysis(fits, effect_size = 2, n_per_group = 3,                            find = \"power\", test = \"bayes_t\", n_sim = 100)  sample_size <- power_analysis(fits, effect_size = 2, target_power = 0.8,                               find = \"sample_size\", test = \"bayes_t\", n_sim = 100)  # Power heatmap - derive representative parameters from data log_abundances <- log(pilot$abundance[pilot$abundance > 0]) derived_params <- list(   meanlog = median(log_abundances),   sdlog = mad(log_abundances, constant = 1) )  plot_power_heatmap(   distribution = \"lnorm\",   params = derived_params,   n_range = c(3, 12),   effect_range = c(1.5, 4),   test = \"wilcoxon\"  # heatmap uses aggregate mode )"},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"document-2-prm-analysis-with-missing-data","dir":"","previous_headings":"","what":"Document 2: PRM Analysis with Missing Data","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"File: inst/examples/prm-genotype-power.Rmd","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"revised-outline-improved-pedagogy","dir":"","previous_headings":"Document 2: PRM Analysis with Missing Data","what":"Revised Outline (Improved Pedagogy)","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"","code":"# Power Analysis for Targeted Proteomics with Missing Data (PRM)  ## Introduction  ### What Makes Targeted Proteomics Different?  Mass spectrometry-based proteomics operates in two fundamentally different modes:  **Discovery proteomics (DDA)** casts a wide net: - Measures thousands of proteins/peptides - Identifies whatever is abundant enough to detect - Great for hypothesis generation - High multiple testing burden  **Targeted proteomics (PRM/SRM)** takes aim at specific targets: - Measures a pre-defined panel of peptides - Higher sensitivity and reproducibility - Better for hypothesis testing - Lower multiple testing burden  This document analyzes a PRM dataset, demonstrating how peppwR handles the unique challenges of targeted proteomics.  ### The Missing Data Challenge  Even with targeted methods, missing values are ubiquitous in mass spectrometry. But not all missing data is created equal:  **MCAR (Missing Completely At Random)** - Values missing due to random technical failures - No relationship to abundance - Reduces sample size but doesn't bias results  **MNAR (Missing Not At Random)** - Low-abundance peptides systematically missing - Below detection limit = no measurement - Can bias abundance estimates upward - Common in mass spectrometry  peppwR tracks both the rate of missingness AND evidence for MNAR patterns, enabling more realistic power estimates.  ### Goals of This Analysis  1. Characterize missingness patterns in the data 2. Identify peptides with MNAR evidence 3. Compare power with/without accounting for missingness 4. Determine realistic sample size requirements 5. Understand FDR impact on power  ## About the Data  This analysis uses fungal phosphoproteomics data from a targeted PRM experiment:  | Property | Value | |----------|-------| | Organism | *Magnaporthe oryzae* (rice blast fungus) | | Method | PRM (Parallel Reaction Monitoring) | | Comparison | Early (t=0) vs late (t=6) timepoints | | Biological replicates | 3 per condition | | Technical replicates | 2 per biological replicate | | Peptides | 285 phosphopeptides | | Missing data | ~17% |  ## Data Preparation  [Same as before but with better explanatory text]  ### Why Average Technical Replicates?  Technical replicates measure the same biological sample multiple times. They capture *measurement* variability, not *biological* variability.  For power analysis, biological replicates are the true unit of replication - they represent independent observations of the biological phenomenon we're studying. We average technical replicates to get one value per biological replicate.  ## Missingness Analysis  ### Examining the Extent of Missingness  Before diving into power analysis, we need to understand our missing data:  ```r fits <- fit_distributions(pilot, \"peptide_id\", \"condition\", \"abundance\") print(fits)  # Shows missingness summary"},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"visualizing-missingness-patterns","dir":"","previous_headings":"Document 2: PRM Analysis with Missing Data","what":"Visualizing Missingness Patterns","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"plot_missingness() function provides three complementary views: NA Rate Distribution: fraction observations missing peptide? MNAR Score Distribution: evidence missingness correlates abundance? Abundance vs NA Rate: low-abundance peptides missing values?","code":"plot_missingness(fits)"},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"interpreting-mnar-scores","dir":"","previous_headings":"Document 2: PRM Analysis with Missing Data","what":"Interpreting MNAR Scores","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"MNAR score z-statistic testing whether missing observations systematically different (lower) abundance observed values.","code":"mnar_peptides <- get_mnar_peptides(fits, threshold = 2)"},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"what-to-do-with-mnar-peptides","dir":"","previous_headings":"Document 2: PRM Analysis with Missing Data","what":"What to Do with MNAR Peptides","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Peptides high MNAR scores require careful handling: - abundance estimates may biased upward - Power calculations may optimistic - Consider robust statistical methods - Report separately publications","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"why-fit-distributions","dir":"","previous_headings":"Distribution Fitting","what":"Why Fit Distributions?","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"[pedagogical content DDA document]","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"results-a-cautionary-note-on-small-samples","dir":"","previous_headings":"Distribution Fitting","what":"Results: A Cautionary Note on Small Samples","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Important: Like DDA dataset, see Pareto Skew Normal dominant best-fit distributions. artifact small sample size (6 observations per peptide averaged across tech reps), statement true underlying distributions. biological replicates, expect gamma lognormal distributions fit better - typical distributions mass spectrometry abundance data.","code":"plot(fits)"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"choosing-the-right-statistical-test","dir":"","previous_headings":"Power Analysis","what":"Choosing the Right Statistical Test","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Critical first step: Compare statistical tests committing one. small samples (N=3), test choice dramatically affects power: [Present table like DDA document] Key finding: [Describe actual results - likely Wilcoxon power, Bayes factor best] remaining analyses, use Bayes factor test.","code":"power_wilcox <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                 test = \"wilcoxon\", n_sim = 100) power_boot <- power_analysis(fits, effect_size = 2, n_per_group = 3,                               test = \"bootstrap_t\", n_sim = 100) power_bayes <- power_analysis(fits, effect_size = 2, n_per_group = 3,                                test = \"bayes_t\", n_sim = 100)"},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"what-effect-size-can-we-detect","dir":"","previous_headings":"Power Analysis","what":"What Effect Size Can We Detect?","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"asking “’s power 2-fold?”, ask “effect size detectable?” informs whether 2-fold threshold realistic need consider larger effects.","code":"# First, understand what's detectable min_effect <- power_analysis(fits, n_per_group = 3, target_power = 0.8,                              find = \"effect_size\", test = \"bayes_t\", n_sim = 100)"},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"power-at-realistic-effect-sizes","dir":"","previous_headings":"Power Analysis","what":"Power at Realistic Effect Sizes","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"[Use effect size informed min_effect analysis]","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"impact-of-missingness-on-power","dir":"","previous_headings":"Power Analysis","what":"Impact of Missingness on Power","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Compare power estimates without accounting missingness: Missingness reduces effective sample size. difference estimates shows “cost” missing data.","code":"power_no_miss <- power_analysis(fits, effect_size = X, n_per_group = 3,                                  test = \"bayes_t\", include_missingness = FALSE) power_with_miss <- power_analysis(fits, effect_size = X, n_per_group = 3,                                    test = \"bayes_t\", include_missingness = TRUE)"},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"fdr-aware-power","dir":"","previous_headings":"Power Analysis","what":"FDR-Aware Power","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"285 peptides, multiple testing correction matters: Understanding prop_null: parameter specifies assumed proportion true null hypotheses. prop_null = 0.8, assume 80% peptides true effect. affects stringent FDR correction .","code":"power_fdr <- power_analysis(fits, effect_size = X, n_per_group = 3,                             test = \"bayes_t\", apply_fdr = TRUE,                             prop_null = 0.8, n_sim = 100)"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"key-findings","dir":"","previous_headings":"Summary and Recommendations","what":"Key Findings","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Missingness: ~17% missing [X] peptides showing MNAR evidence Test selection: Wilcoxon power N=3; Bayes factor usable Distribution fitting: Pareto/Skew Normal dominance artifact small N Power estimates: [Actual results] FDR impact: [Actual results]","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"practical-recommendations","dir":"","previous_headings":"Summary and Recommendations","what":"Practical Recommendations","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"[Based actual results]","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"caveats","dir":"","previous_headings":"Summary and Recommendations","what":"Caveats","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Small sample size limits distribution fitting reliability MNAR models approximations prop_null requires assumptions true effect rates","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"session-info-1","dir":"","previous_headings":"","what":"Session Info","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"```","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"implementation-steps","dir":"","previous_headings":"","what":"Implementation Steps","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"Update DDA Rmd following revised outline Move test comparison EARLY analysis Fix distribution fitting interpretation Use Bayes factor main analyses Create proper comparison table Remove/fix minimum detectable effect section Render carefully verify DDA HTML Check figure matches accompanying text Verify table values populated correctly Update PRM Rmd following revised outline Improve pedagogical tone throughout test comparison approach DDA Better MNAR explanation Use effect size informed data, assumed 2-fold Render carefully verify PRM HTML verification DDA Run devtools::check(vignettes = FALSE) Commit changes","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"text-must-match-figures","dir":"","previous_headings":"Writing Guidelines","what":"Text Must Match Figures","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"NEVER write explanatory text assumes result. Instead: - Run analysis first - Look actual output/figure - Write text accurately describes see Bad: “results show lognormal distributions dominate…” Good: “results show [describe actual bars figure]…”","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"explain-unexpected-results","dir":"","previous_headings":"Writing Guidelines","what":"Explain Unexpected Results","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"results don’t match intuition, explain : - Pareto/Skew Normal dominance → small sample size artifact - Zero Wilcoxon power → non-parametric tests need larger N - Empty MDE plots → using wrong test data","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"use-tables-for-comparisons","dir":"","previous_headings":"Writing Guidelines","what":"Use Tables for Comparisons","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"comparing multiple options (tests, conditions), use clear table:","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"pedagogical-consistency","dir":"","previous_headings":"Writing Guidelines","what":"Pedagogical Consistency","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"documents similar tone structure: - Explain “” “” - Use consistent terminology - Similar section headers appropriate","code":""},{"path":"https://teammaclean.github.io/peppwR/examples_plan.html","id":"verification-checklist","dir":"","previous_headings":"","what":"Verification Checklist","title":"Real-World Analysis Examples Implementation Plan (v3)","text":"implementation: - [ ] DDA Rmd renders without error - [ ] DDA figures match explanatory text - [ ] Test comparison table shows actual computed values - [ ] Bayes factor used main analyses (Wilcoxon) - [ ] Distribution fitting text explains Pareto/Skew Normal artifact - [ ] PRM Rmd renders without error - [ ] PRM figures match explanatory text - [ ] PRM pedagogical quality DDA - [ ] Effect size threshold informed data (assumed) - [ ] devtools::check(vignettes = FALSE) passes 0 errors, 0 warnings - [ ] Changes committed","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"peppwR Feature Addition Plan v2","text":"Four feature sets add peppwR: 1. Diagnostic Plots - Visual fit assessment power exploration 2. Empirical Bootstrap - on_fit_failure = \"empirical\" implementation 3. Missing Data Handling - Track NA rates, detect MNAR, incorporate simulations 4. FDR-Aware Mode - Multiple testing correction power analysis","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"missing-data-philosophy","dir":"","previous_headings":"Design Decisions","what":"Missing Data Philosophy","title":"peppwR Feature Addition Plan v2","text":"imputation - ever Track report NA rates per peptide Detect MNAR (Missing Random) patterns - low values systematically missing Incorporate missingness rates power simulations Always try fit, report % failing due NAs","code":""},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"fdr-mode","dir":"","previous_headings":"Design Decisions","what":"FDR Mode","title":"peppwR Feature Addition Plan v2","text":"User-configurable prop_null parameter (default 0.9 = 90% true nulls) Simulate full peptidome together, apply Benjamini-Hochberg correction Report power FDR adjustment","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"phase-a-diagnostic-plots","dir":"","previous_headings":"Implementation Phases","what":"Phase A: Diagnostic Plots","title":"peppwR Feature Addition Plan v2","text":"Files: R/plots.R, new tests/testthat/test-plots-diagnostic.R","code":""},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"phase-b-empirical-bootstrap","dir":"","previous_headings":"Implementation Phases","what":"Phase B: Empirical Bootstrap","title":"peppwR Feature Addition Plan v2","text":"Files: R/simulation.R, R/power.R","code":""},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"phase-c-missing-data-handling","dir":"","previous_headings":"Implementation Phases","what":"Phase C: Missing Data Handling","title":"peppwR Feature Addition Plan v2","text":"Files: R/fits.R, R/classes.R, R/simulation.R, R/plots.R","code":""},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"phase-d-fdr-aware-mode","dir":"","previous_headings":"Implementation Phases","what":"Phase D: FDR-Aware Mode","title":"peppwR Feature Addition Plan v2","text":"Files: R/simulation.R, R/power.R, R/classes.R","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"extended-peppwr_fits-phase-c","dir":"","previous_headings":"Key Data Structures","what":"Extended peppwr_fits (Phase C)","title":"peppwR Feature Addition Plan v2","text":"","code":"peppwr_fits <- list(   data = nested_tibble,   fits = list(),   best = character(),   call = call,   missingness = tibble(        # NEW     peptide_idx, n_total, n_missing, na_rate,     mnar_score,    # Positive = low values more likely missing     mnar_pvalue    # Test for MNAR pattern   ) )"},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"mnar-detection-logic","dir":"","previous_headings":"Key Data Structures","what":"MNAR Detection Logic","title":"peppwR Feature Addition Plan v2","text":"","code":"# Under MCAR: mean rank of observed values = (n+1)/2 # Under MNAR (low values missing): mean rank is higher # mnar_score = normalized deviation from expected mnar_score <- (observed_mean_rank - expected_mean_rank) / se"},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"fdr-simulation-structure","dir":"","previous_headings":"Key Data Structures","what":"FDR Simulation Structure","title":"peppwR Feature Addition Plan v2","text":"","code":"# Each iteration: # 1. Assign peptides to null (no effect) or alternative (has effect) # 2. Simulate all peptides # 3. Run tests, collect p-values # 4. Apply p.adjust(method = \"BH\") # 5. Power = proportion of true alternatives detected at fdr_threshold"},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"dependencies-between-phases","dir":"","previous_headings":"","what":"Dependencies Between Phases","title":"peppwR Feature Addition Plan v2","text":"Recommended order: → B → C → D (B parallel)","code":"Phase A (Plots) -----> Independent Phase B (Empirical) -> Independent Phase C (Missing) ---> Should complete before D Phase D (FDR) -------> Depends on C (uses missingness info)"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"verification","dir":"","previous_headings":"","what":"Verification","title":"peppwR Feature Addition Plan v2","text":"phase: phases:","code":"devtools::test()           # All tests pass devtools::check(vignettes = FALSE)  # 0 errors, 0 warnings # Manual verification fits <- fit_distributions(pilot_data, \"peptide_id\", \"condition\", \"abundance\") print(fits)  # Should show missingness summary  # Test FDR mode result <- power_analysis(fits, effect_size = 2, n_per_group = 6,                          find = \"power\", apply_fdr = TRUE, prop_null = 0.9) print(result)  # Should show FDR-adjusted power  # Test empirical bootstrap result <- power_analysis(fits, effect_size = 2, n_per_group = 6,                          find = \"power\", on_fit_failure = \"empirical\")  # Test missingness incorporation result <- power_analysis(fits, effect_size = 2, n_per_group = 6,                          find = \"power\", include_missingness = TRUE)"},{"path":"https://teammaclean.github.io/peppwR/feature_plan_v2.html","id":"estimated-scope","dir":"","previous_headings":"","what":"Estimated Scope","title":"peppwR Feature Addition Plan v2","text":"Phase : 5 functions, ~200 lines Phase B: 3 functions, ~80 lines Phase C: 7 tasks, ~300 lines Phase D: 3 tasks, ~150 lines Total: ~730 lines new code + tests","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"peppwr-","dir":"","previous_headings":"","what":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"Power analysis phosphopeptide abundance hypothesis tests via simulation. peppwR helps proteomics researchers answer critical experimental design questions: “sample size need?” — Find N required 80% power detect given effect “’s power?” — Calculate power given sample size effect “can detect?” — Find minimum detectable effect size design","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"Distribution fitting — Fit gamma, lognormal, normal, distributions pilot data Per-peptide analysis — Get power estimates across entire peptidome Multiple statistical tests — Wilcoxon, bootstrap-t, Bayes factor t-tests Missing data handling — Model MNAR (Missing Random) patterns common proteomics FDR-aware mode — Account multiple testing correction power calculations Rich visualizations — Power curves, heatmaps, QQ plots, diagnostic plots","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"Install development version GitHub:","code":"# install.packages(\"pak\") pak::pak(\"TeamMacLean/peppwR\")"},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"from-pilot-data-per-peptide-mode","dir":"","previous_headings":"Quick Start","what":"From Pilot Data (Per-Peptide Mode)","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"","code":"library(peppwR)  # Fit distributions to your pilot data fits <- fit_distributions(   pilot_data,   id = \"peptide\",   group = \"condition\",   value = \"abundance\" )  # Find required sample size for 80% power to detect 2-fold change result <- power_analysis(   fits,   effect_size = 2,   target_power = 0.8,   find = \"sample_size\" )  print(result) #> Per-peptide power analysis #> Question: sample_size #> Answer: N = 6 per group #> 73% of peptides achieve 80% power  plot(result)"},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"from-scratch-aggregate-mode","dir":"","previous_headings":"Quick Start","what":"From Scratch (Aggregate Mode)","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"pilot data? Specify assumed distribution parameters:","code":"result <- power_analysis(   distribution = \"gamma\",   params = list(shape = 2, rate = 0.1),   effect_size = 2,   target_power = 0.8,   find = \"sample_size\" )"},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"Getting Started — Introduction basic usage Power Analysis Workflow — Complete workflow real data Benchmarking — Performance characteristics Function Reference — Full API documentation","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"real-world-examples","dir":"","previous_headings":"Documentation","what":"Real-World Examples","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"DDA Time Course Analysis PRM Genotype Analysis","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"workflow-overview","dir":"","previous_headings":"","what":"Workflow Overview","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"","code":"flowchart TD     A[pilot_data] --> B[fit_distributions]     B --> C[power_analysis]     C --> D{find = ?}     D --> E[\"power\"]     D --> F[\"sample_size\"]     D --> G[\"effect_size\"]     E --> H[results + plots]     F --> H     G --> H      style A fill:#FFFFCC,stroke:#BD0026     style B fill:#FD8D3C,stroke:#BD0026,color:#fff     style C fill:#FD8D3C,stroke:#BD0026,color:#fff     style H fill:#FFFFCC,stroke:#BD0026"},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"use peppwR research, please cite:","code":"MacLean, D. (2026). peppwR: Power Analysis for Phosphopeptide Abundance Hypothesis Tests. R package version 0.1.0. https://github.com/TeamMacLean/peppwR"},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"Contributions welcome! Please open issue submit pull request.","code":""},{"path":"https://teammaclean.github.io/peppwR/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Power Analysis For Phosphopeptide Abundance Hypothesis Test","text":"MIT © Dan MacLean","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/next_prompt.html","id":"task","dir":"","previous_headings":"","what":"Task","title":"Next Session: Re-render Examples","text":"Re-render DDA PRM example documents recent updates.","code":""},{"path":"https://teammaclean.github.io/peppwR/next_prompt.html","id":"what-was-done","dir":"","previous_headings":"","what":"What Was Done","title":"Next Session: Re-render Examples","text":"Fixed find = \"effect_size\" per-peptide mode (working installed package date) Updated DDA example data-derived heatmap parameters Added explanation two thresholds (target_power vs proportion_threshold) examples Updated CLAUDE.md project status new bug (misleading red line)","code":""},{"path":[]},{"path":"https://teammaclean.github.io/peppwR/next_prompt.html","id":"id_1-re-render-examples","dir":"","previous_headings":"What Needs To Be Done","what":"1. Re-render Examples","title":"Next Session: Re-render Examples","text":"Rmd files updated HTML yet re-rendered: Note: Rendering takes ~20-25 minutes per document due power simulations.","code":"rmarkdown::render(\"inst/examples/dda-time-course-power.Rmd\") rmarkdown::render(\"inst/examples/prm-genotype-power.Rmd\")"},{"path":"https://teammaclean.github.io/peppwR/next_prompt.html","id":"id_2-verify-plots","dir":"","previous_headings":"What Needs To Be Done","what":"2. Verify Plots","title":"Next Session: Re-render Examples","text":"Check effect_size plots now show meaningful curves (empty).","code":""},{"path":"https://teammaclean.github.io/peppwR/next_prompt.html","id":"id_3-commit","dir":"","previous_headings":"What Needs To Be Done","what":"3. Commit","title":"Next Session: Re-render Examples","text":"","code":"git add inst/examples/*.Rmd inst/examples/*.html git commit -m \"Re-render examples with threshold explanation\""},{"path":"https://teammaclean.github.io/peppwR/next_prompt.html","id":"known-bug-to-fix-future-session","dir":"","previous_headings":"","what":"Known Bug to Fix (Future Session)","title":"Next Session: Re-render Examples","text":"Misleading red line per-peptide effect_size plot plot draws red horizontal line proportion_threshold (50%) users confuse target_power (80%). Fix R/plots.R: - Remove red line - Replace text annotation explaining answer See CLAUDE.md “Known Issues” section details.","code":""},{"path":"https://teammaclean.github.io/peppwR/next_prompt.html","id":"files-modified-not-yet-committed","dir":"","previous_headings":"","what":"Files Modified (Not Yet Committed)","title":"Next Session: Re-render Examples","text":"inst/examples/dda-time-course-power.Rmd - Added threshold explanation inst/examples/prm-genotype-power.Rmd - Added threshold explanation CLAUDE.md - Updated project status, added new bug","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/apply_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply missingness to a vector — apply_missingness","title":"Apply missingness to a vector — apply_missingness","text":"Apply missingness vector","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/apply_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply missingness to a vector — apply_missingness","text":"","code":"apply_missingness(x, na_rate, mnar_score = 0)"},{"path":"https://teammaclean.github.io/peppwR/reference/apply_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply missingness to a vector — apply_missingness","text":"x Numeric vector na_rate Proportion make NA mnar_score MNAR intensity (0 = MCAR)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/apply_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply missingness to a vector — apply_missingness","text":"Vector values replaced NA","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/bf_jzs.html","id":null,"dir":"Reference","previous_headings":"","what":"JZS Bayes factor approximation — bf_jzs","title":"JZS Bayes factor approximation — bf_jzs","text":"JZS Bayes factor approximation","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/bf_jzs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"JZS Bayes factor approximation — bf_jzs","text":"","code":"bf_jzs(t, n1, n2)"},{"path":"https://teammaclean.github.io/peppwR/reference/bf_jzs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"JZS Bayes factor approximation — bf_jzs","text":"t t-statistic n1 Sample size group 1 n2 Sample size group 2","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/bf_jzs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"JZS Bayes factor approximation — bf_jzs","text":"Bayes factor","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_fitted_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute fitted density values — compute_fitted_density","title":"Compute fitted density values — compute_fitted_density","text":"Compute fitted density values","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_fitted_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute fitted density values — compute_fitted_density","text":"","code":"compute_fitted_density(raw_vals, dist_name, x_range)"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_fitted_density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute fitted density values — compute_fitted_density","text":"raw_vals Raw observed values dist_name Distribution name x_range X values compute density ","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_fitted_density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute fitted density values — compute_fitted_density","text":"Density values NULL failure","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute missingness statistics for a vector of values — compute_missingness","title":"Compute missingness statistics for a vector of values — compute_missingness","text":"Calculates NA rate MNAR (Missing Random) score. MNAR detection uses observation MCAR, mean rank observed values (n+1)/2. MNAR low values missing, mean rank higher.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute missingness statistics for a vector of values — compute_missingness","text":"","code":"compute_missingness(values)"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute missingness statistics for a vector of values — compute_missingness","text":"values Numeric vector (may contain NAs)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute missingness statistics for a vector of values — compute_missingness","text":"List : n_total: Total number values n_missing: Number NA values na_rate: Proportion missing (0-1) mnar_score: Z-score measuring MNAR pattern. Positive values indicate low values likely missing. Values > 2 suggest MNAR.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_perpeptide_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute per-peptide power (helper for plot_power_vs_effect) — compute_perpeptide_power","title":"Compute per-peptide power (helper for plot_power_vs_effect) — compute_perpeptide_power","text":"Compute per-peptide power (helper plot_power_vs_effect)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_perpeptide_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute per-peptide power (helper for plot_power_vs_effect) — compute_perpeptide_power","text":"","code":"compute_perpeptide_power(   fits_data,   n_per_group,   effect_size,   alpha,   test,   n_sim )"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_qq_points.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute QQ points for a distribution fit — compute_qq_points","title":"Compute QQ points for a distribution fit — compute_qq_points","text":"Compute QQ points distribution fit","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_qq_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute QQ points for a distribution fit — compute_qq_points","text":"","code":"compute_qq_points(raw_vals, dist_name)"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_qq_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute QQ points for a distribution fit — compute_qq_points","text":"raw_vals Raw observed values dist_name Distribution name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_qq_points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute QQ points for a distribution fit — compute_qq_points","text":"List theoretical sample quantiles, NULL","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_t_stat.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute t-statistic for two groups — compute_t_stat","title":"Compute t-statistic for two groups — compute_t_stat","text":"Compute t-statistic two groups","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_t_stat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute t-statistic for two groups — compute_t_stat","text":"","code":"compute_t_stat(x, y)"},{"path":"https://teammaclean.github.io/peppwR/reference/compute_t_stat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute t-statistic for two groups — compute_t_stat","text":"x First group y Second group","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/compute_t_stat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute t-statistic for two groups — compute_t_stat","text":"t-statistic","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_effect_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Find minimum detectable effect size — find_effect_size","title":"Find minimum detectable effect size — find_effect_size","text":"Find minimum detectable effect size","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_effect_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find minimum detectable effect size — find_effect_size","text":"","code":"find_effect_size(   distribution,   params,   n_per_group,   target_power,   alpha,   test,   n_sim )"},{"path":"https://teammaclean.github.io/peppwR/reference/find_effect_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find minimum detectable effect size — find_effect_size","text":"distribution Distribution name params Distribution parameters n_per_group Sample size per group target_power Target power level alpha Significance level test Statistical test n_sim Number simulations per effect size","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_effect_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find minimum detectable effect size — find_effect_size","text":"List effect_size effect_curve","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_sample_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Find required sample size for target power — find_sample_size","title":"Find required sample size for target power — find_sample_size","text":"Find required sample size target power","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_sample_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find required sample size for target power — find_sample_size","text":"","code":"find_sample_size(   distribution,   params,   effect_size,   target_power,   alpha,   test,   n_sim )"},{"path":"https://teammaclean.github.io/peppwR/reference/find_sample_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find required sample size for target power — find_sample_size","text":"distribution Distribution name params Distribution parameters effect_size Effect size detect target_power Target power level alpha Significance level test Statistical test n_sim Number simulations per sample size","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/find_sample_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find required sample size for target power — find_sample_size","text":"List n power_curve","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/fit_distributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit distributions to peptide abundance data — fit_distributions","title":"Fit distributions to peptide abundance data — fit_distributions","text":"Fit distributions peptide abundance data","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/fit_distributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit distributions to peptide abundance data — fit_distributions","text":"","code":"fit_distributions(data, id, group, value, distributions = \"continuous\")"},{"path":"https://teammaclean.github.io/peppwR/reference/fit_distributions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit distributions to peptide abundance data — fit_distributions","text":"data data frame containing peptide abundance data id Column name peptide identifier group Column name group/condition value Column name abundance values distributions distributions fit: \"continuous\" (default), \"counts\", \"\", character vector distribution names","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/fit_distributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit distributions to peptide abundance data — fit_distributions","text":"peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/format_answer.html","id":null,"dir":"Reference","previous_headings":"","what":"Format answer based on question type — format_answer","title":"Format answer based on question type — format_answer","text":"Format answer based question type","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/format_answer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format answer based on question type — format_answer","text":"","code":"format_answer(answer, question)"},{"path":"https://teammaclean.github.io/peppwR/reference/format_answer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format answer based on question type — format_answer","text":"answer answer value question question type","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/format_answer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format answer based on question type — format_answer","text":"Formatted string","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dfunc.html","id":null,"dir":"Reference","previous_headings":"","what":"Get density function for a distribution — get_dfunc","title":"Get density function for a distribution — get_dfunc","text":"Get density function distribution","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dfunc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get density function for a distribution — get_dfunc","text":"","code":"get_dfunc(distribution)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_dfunc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get density function for a distribution — get_dfunc","text":"distribution Distribution name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dfunc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get density function for a distribution — get_dfunc","text":"Density function","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dist_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Get distribution parameters from fitted results — get_dist_params","title":"Get distribution parameters from fitted results — get_dist_params","text":"Get distribution parameters fitted results","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dist_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get distribution parameters from fitted results — get_dist_params","text":"","code":"get_dist_params(dist_name, fit_df, raw_data)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_dist_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get distribution parameters from fitted results — get_dist_params","text":"dist_name Distribution name fit_df Fit results data frame raw_data Raw data values","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_dist_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get distribution parameters from fitted results — get_dist_params","text":"List parameters","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_distribution_preset.html","id":null,"dir":"Reference","previous_headings":"","what":"Get distributions for a preset — get_distribution_preset","title":"Get distributions for a preset — get_distribution_preset","text":"Get distributions preset","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_distribution_preset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get distributions for a preset — get_distribution_preset","text":"","code":"get_distribution_preset(preset = \"continuous\")"},{"path":"https://teammaclean.github.io/peppwR/reference/get_distribution_preset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get distributions for a preset — get_distribution_preset","text":"preset One \"continuous\" (default), \"counts\", \"\"","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_distribution_preset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get distributions for a preset — get_distribution_preset","text":"Character vector distribution names","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_mnar_peptides.html","id":null,"dir":"Reference","previous_headings":"","what":"Get peptides showing MNAR pattern — get_mnar_peptides","title":"Get peptides showing MNAR pattern — get_mnar_peptides","text":"Returns peptides MNAR score exceeds threshold, indicating low values systematically missing (Missing Random).","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_mnar_peptides.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get peptides showing MNAR pattern — get_mnar_peptides","text":"","code":"get_mnar_peptides(fits, threshold = 2)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_mnar_peptides.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get peptides showing MNAR pattern — get_mnar_peptides","text":"fits peppwr_fits object threshold MNAR score threshold (default 2, corresponds ~95% confidence)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_mnar_peptides.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get peptides showing MNAR pattern — get_mnar_peptides","text":"tibble columns: peptide_id: Peptide identifier condition: Group/condition na_rate: Proportion missing values mnar_score: Z-score MNAR pattern mean_abundance: Mean observed values Sorted mnar_score descending. Returns empty tibble peptides exceed threshold.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_qfunc.html","id":null,"dir":"Reference","previous_headings":"","what":"Get quantile function for a distribution — get_qfunc","title":"Get quantile function for a distribution — get_qfunc","text":"Get quantile function distribution","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_qfunc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get quantile function for a distribution — get_qfunc","text":"","code":"get_qfunc(distribution)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_qfunc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get quantile function for a distribution — get_qfunc","text":"distribution Distribution name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_qfunc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get quantile function for a distribution — get_qfunc","text":"Quantile function","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_rfunc.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the random generation function for a distribution — get_rfunc","title":"Get the random generation function for a distribution — get_rfunc","text":"Get random generation function distribution","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_rfunc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the random generation function for a distribution — get_rfunc","text":"","code":"get_rfunc(distribution)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_rfunc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the random generation function for a distribution — get_rfunc","text":"distribution Distribution name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_rfunc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the random generation function for a distribution — get_rfunc","text":"Random generation function","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_test_func.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the test function for a given test name — get_test_func","title":"Get the test function for a given test name — get_test_func","text":"Get test function given test name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_test_func.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the test function for a given test name — get_test_func","text":"","code":"get_test_func(test)"},{"path":"https://teammaclean.github.io/peppwR/reference/get_test_func.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the test function for a given test name — get_test_func","text":"test Test name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/get_test_func.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the test function for a given test name — get_test_func","text":"Test function","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/is_count_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if data appears to be count data (non-negative integers) — is_count_data","title":"Check if data appears to be count data (non-negative integers) — is_count_data","text":"Check data appears count data (non-negative integers)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/is_count_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if data appears to be count data (non-negative integers) — is_count_data","text":"","code":"is_count_data(x)"},{"path":"https://teammaclean.github.io/peppwR/reference/is_count_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if data appears to be count data (non-negative integers) — is_count_data","text":"x Numeric vector","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/is_count_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if data appears to be count data (non-negative integers) — is_count_data","text":"TRUE data looks like counts, FALSE otherwise","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/map_dist_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Map distribution name to R function prefix — map_dist_name","title":"Map distribution name to R function prefix — map_dist_name","text":"Map distribution name R function prefix","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/map_dist_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map distribution name to R function prefix — map_dist_name","text":"","code":"map_dist_name(dist_name)"},{"path":"https://teammaclean.github.io/peppwR/reference/map_dist_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map distribution name to R function prefix — map_dist_name","text":"dist_name Distribution name","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/map_dist_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map distribution name to R function prefix — map_dist_name","text":"R function name random generation","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new peppwr_fits object — new_peppwr_fits","title":"Create a new peppwr_fits object — new_peppwr_fits","text":"Create new peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new peppwr_fits object — new_peppwr_fits","text":"","code":"new_peppwr_fits(data, fits, best, call, missingness = NULL)"},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new peppwr_fits object — new_peppwr_fits","text":"data Original data (nested tibble) fits Fit results per peptide (list tibbles dist, loglik, aic) best Best-fitting distribution per peptide (character vector) call Original function call missingness Tibble missingness statistics per peptide (optional)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new peppwr_fits object — new_peppwr_fits","text":"peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new peppwr_power object — new_peppwr_power","title":"Create a new peppwr_power object — new_peppwr_power","text":"Create new peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new peppwr_power object — new_peppwr_power","text":"","code":"new_peppwr_power(mode, question, answer, simulations, params, call)"},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new peppwr_power object — new_peppwr_power","text":"mode Either \"aggregate\" \"per_peptide\" question solved : \"power\", \"sample_size\", \"effect_size\" answer computed answer simulations List simulation details params List input parameters used call Original function call","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/new_peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new peppwr_power object — new_peppwr_power","text":"peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for peppwr_fits — plot.peppwr_fits","title":"Plot method for peppwr_fits — plot.peppwr_fits","text":"Creates bar chart showing count best-fit distributions","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for peppwr_fits — plot.peppwr_fits","text":"","code":"# S3 method for class 'peppwr_fits' plot(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for peppwr_fits — plot.peppwr_fits","text":"x peppwr_fits object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for peppwr_fits — plot.peppwr_fits","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for peppwr_power — plot.peppwr_power","title":"Plot method for peppwr_power — plot.peppwr_power","text":"Creates power curves % peptides threshold plots","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for peppwr_power — plot.peppwr_power","text":"","code":"# S3 method for class 'peppwr_power' plot(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for peppwr_power — plot.peppwr_power","text":"x peppwr_power object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot.peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for peppwr_power — plot.peppwr_power","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_density_overlay.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot density overlay: observed histogram with fitted density curve — plot_density_overlay","title":"Plot density overlay: observed histogram with fitted density curve — plot_density_overlay","text":"Plot density overlay: observed histogram fitted density curve","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_density_overlay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot density overlay: observed histogram with fitted density curve — plot_density_overlay","text":"","code":"plot_density_overlay(fits, peptide_id = NULL, n_overlay = 6)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_density_overlay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot density overlay: observed histogram with fitted density curve — plot_density_overlay","text":"fits peppwr_fits object peptide_id Specific peptide plot (NULL multiple) n_overlay Number peptides overlay peptide_id NULL","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_density_overlay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot density overlay: observed histogram with fitted density curve — plot_density_overlay","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot missingness statistics — plot_missingness","title":"Plot missingness statistics — plot_missingness","text":"Shows distribution NA rates, MNAR scores, relationship abundance missingness across peptides.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot missingness statistics — plot_missingness","text":"","code":"plot_missingness(fits)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot missingness statistics — plot_missingness","text":"fits peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot missingness statistics — plot_missingness","text":"ggplot object gtable (combined panels)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_param_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot distribution of fitted parameters across peptidome — plot_param_distribution","title":"Plot distribution of fitted parameters across peptidome — plot_param_distribution","text":"Plot distribution fitted parameters across peptidome","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_param_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot distribution of fitted parameters across peptidome — plot_param_distribution","text":"","code":"plot_param_distribution(fits)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_param_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot distribution of fitted parameters across peptidome — plot_param_distribution","text":"fits peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_param_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot distribution of fitted parameters across peptidome — plot_param_distribution","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_aggregate.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot power curve for aggregate mode — plot_power_aggregate","title":"Plot power curve for aggregate mode — plot_power_aggregate","text":"Plot power curve aggregate mode","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_aggregate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot power curve for aggregate mode — plot_power_aggregate","text":"","code":"plot_power_aggregate(x)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_aggregate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot power curve for aggregate mode — plot_power_aggregate","text":"x peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_aggregate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot power curve for aggregate mode — plot_power_aggregate","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_heatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot power heatmap: N x effect size grid — plot_power_heatmap","title":"Plot power heatmap: N x effect size grid — plot_power_heatmap","text":"Plot power heatmap: N x effect size grid","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_heatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot power heatmap: N x effect size grid — plot_power_heatmap","text":"","code":"plot_power_heatmap(   distribution,   params,   n_range,   effect_range,   n_steps = 6,   n_sim = 100,   test = \"wilcoxon\",   alpha = 0.05 )"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_heatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot power heatmap: N x effect size grid — plot_power_heatmap","text":"distribution Distribution name params Distribution parameters n_range Range sample sizes (vector length 2) effect_range Range effect sizes (vector length 2) n_steps Number grid points per dimension n_sim Number simulations per grid cell test Statistical test use alpha Significance level","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_heatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot power heatmap: N x effect size grid — plot_power_heatmap","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_perpeptide.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot % peptides at threshold for per-peptide mode — plot_power_perpeptide","title":"Plot % peptides at threshold for per-peptide mode — plot_power_perpeptide","text":"Plot % peptides threshold per-peptide mode","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_perpeptide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot % peptides at threshold for per-peptide mode — plot_power_perpeptide","text":"","code":"plot_power_perpeptide(x)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_perpeptide.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot % peptides at threshold for per-peptide mode — plot_power_perpeptide","text":"x peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_perpeptide.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot % peptides at threshold for per-peptide mode — plot_power_perpeptide","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_vs_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot power vs effect size at fixed N — plot_power_vs_effect","title":"Plot power vs effect size at fixed N — plot_power_vs_effect","text":"Plot power vs effect size fixed N","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_vs_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot power vs effect size at fixed N — plot_power_vs_effect","text":"","code":"plot_power_vs_effect(power_result, effect_range, n_steps = 10, n_sim = NULL)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_vs_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot power vs effect size at fixed N — plot_power_vs_effect","text":"power_result peppwr_power object effect_range Range effect sizes explore n_steps Number effect size values compute n_sim Number simulations per point","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_power_vs_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot power vs effect size at fixed N — plot_power_vs_effect","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_qq.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot QQ plots for goodness-of-fit — plot_qq","title":"Plot QQ plots for goodness-of-fit — plot_qq","text":"Plot QQ plots goodness--fit","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_qq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot QQ plots for goodness-of-fit — plot_qq","text":"","code":"plot_qq(fits, peptide_id = NULL, n_plots = 6)"},{"path":"https://teammaclean.github.io/peppwR/reference/plot_qq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot QQ plots for goodness-of-fit — plot_qq","text":"fits peppwr_fits object peptide_id Specific peptide plot (NULL multiple) n_plots Number peptides plot peptide_id NULL","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/plot_qq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot QQ plots for goodness-of-fit — plot_qq","text":"ggplot object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.character.html","id":null,"dir":"Reference","previous_headings":"","what":"Power analysis with specified distribution (aggregate mode) — power_analysis.character","title":"Power analysis with specified distribution (aggregate mode) — power_analysis.character","text":"Power analysis specified distribution (aggregate mode) Default power analysis method (aggregate mode defaults)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power analysis with specified distribution (aggregate mode) — power_analysis.character","text":"","code":"# S3 method for class 'character' power_analysis(   distribution,   params,   effect_size = NULL,   n_per_group = NULL,   target_power = NULL,   alpha = 0.05,   test = \"wilcoxon\",   find = \"power\",   n_sim = 1000,   ... )  # Default S3 method power_analysis(distribution, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power analysis with specified distribution (aggregate mode) — power_analysis.character","text":"distribution Distribution name (e.g., \"norm\", \"gamma\", \"lnorm\") params List distribution parameters effect_size Fold change detect n_per_group Sample size per group (required find=\"power\") target_power Target power (required find=\"sample_size\" find=\"effect_size\") alpha Significance level (default 0.05) test Statistical test use (default \"wilcoxon\") find solve : \"power\", \"sample_size\", \"effect_size\" n_sim Number simulations (default 1000) ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power analysis with specified distribution (aggregate mode) — power_analysis.character","text":"peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.html","id":null,"dir":"Reference","previous_headings":"","what":"Power analysis for peptide abundance data — power_analysis","title":"Power analysis for peptide abundance data — power_analysis","text":"Power analysis peptide abundance data","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power analysis for peptide abundance data — power_analysis","text":"","code":"power_analysis(distribution, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power analysis for peptide abundance data — power_analysis","text":"distribution Distribution name (character) peppwr_fits object per-peptide mode ... Additional arguments","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power analysis for peptide abundance data — power_analysis","text":"peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Power analysis for per-peptide mode using fitted distributions — power_analysis.peppwr_fits","title":"Power analysis for per-peptide mode using fitted distributions — power_analysis.peppwr_fits","text":"Power analysis per-peptide mode using fitted distributions","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power analysis for per-peptide mode using fitted distributions — power_analysis.peppwr_fits","text":"","code":"# S3 method for class 'peppwr_fits' power_analysis(   distribution,   effect_size = NULL,   n_per_group = NULL,   target_power = NULL,   alpha = 0.05,   test = \"wilcoxon\",   find = \"power\",   n_sim = 1000,   on_fit_failure = \"exclude\",   proportion_threshold = 0.5,   include_missingness = FALSE,   apply_fdr = FALSE,   prop_null = 0.9,   fdr_threshold = 0.05,   ... )"},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power analysis for per-peptide mode using fitted distributions — power_analysis.peppwr_fits","text":"distribution peppwr_fits object fit_distributions() effect_size Fold change detect n_per_group Sample size per group (required find=\"power\") target_power Target power (required find=\"sample_size\") alpha Significance level (default 0.05) test Statistical test use (default \"wilcoxon\") find solve : \"power\" \"sample_size\" n_sim Number simulations per peptide (default 1000) on_fit_failure handle failed fits: \"exclude\", \"empirical\", \"lognormal\" proportion_threshold Proportion peptides must reach target_power (default 0.5) include_missingness TRUE, incorporate peptide-specific NA rates simulations apply_fdr TRUE, use FDR-aware simulation Benjamini-Hochberg correction prop_null Proportion true null peptides (default 0.9 = 90% unchanged) fdr_threshold FDR threshold calling discoveries (default 0.05) ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/power_analysis.peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power analysis for per-peptide mode using fitted distributions — power_analysis.peppwr_fits","text":"peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for peppwr_fits — print.peppwr_fits","title":"Print method for peppwr_fits — print.peppwr_fits","text":"Print method peppwr_fits","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for peppwr_fits — print.peppwr_fits","text":"","code":"# S3 method for class 'peppwr_fits' print(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for peppwr_fits — print.peppwr_fits","text":"x peppwr_fits object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for peppwr_fits — print.peppwr_fits","text":"object invisibly","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for peppwr_power — print.peppwr_power","title":"Print method for peppwr_power — print.peppwr_power","text":"Print method peppwr_power","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for peppwr_power — print.peppwr_power","text":"","code":"# S3 method for class 'peppwr_power' print(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for peppwr_power — print.peppwr_power","text":"x peppwr_power object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for peppwr_power — print.peppwr_power","text":"object invisibly","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary.peppwr_fits — print.summary.peppwr_fits","title":"Print method for summary.peppwr_fits — print.summary.peppwr_fits","text":"Print method summary.peppwr_fits","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary.peppwr_fits — print.summary.peppwr_fits","text":"","code":"# S3 method for class 'summary.peppwr_fits' print(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary.peppwr_fits — print.summary.peppwr_fits","text":"x summary.peppwr_fits object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for summary.peppwr_fits — print.summary.peppwr_fits","text":"object invisibly","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary.peppwr_power — print.summary.peppwr_power","title":"Print method for summary.peppwr_power — print.summary.peppwr_power","text":"Print method summary.peppwr_power","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary.peppwr_power — print.summary.peppwr_power","text":"","code":"# S3 method for class 'summary.peppwr_power' print(x, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary.peppwr_power — print.summary.peppwr_power","text":"x summary.peppwr_power object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/print.summary.peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for summary.peppwr_power — print.summary.peppwr_power","text":"object invisibly","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Run power simulation — run_power_sim","title":"Run power simulation — run_power_sim","text":"Run power simulation","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run power simulation — run_power_sim","text":"","code":"run_power_sim(   distribution,   params,   n_per_group,   effect_size,   alpha = 0.05,   test = \"wilcoxon\",   n_sim = 1000 )"},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run power simulation — run_power_sim","text":"distribution Distribution name params List distribution parameters n_per_group Number samples per group effect_size Fold change treatment alpha Significance level test Statistical test use (\"wilcoxon\", \"bootstrap_t\", \"bayes_t\", \"rankprod\") n_sim Number simulations","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run power simulation — run_power_sim","text":"Power estimate (proportion significant results)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_empirical.html","id":null,"dir":"Reference","previous_headings":"","what":"Run power simulation using empirical bootstrap — run_power_sim_empirical","title":"Run power simulation using empirical bootstrap — run_power_sim_empirical","text":"Estimates power repeatedly resampling observed data rather sampling fitted distributions.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_empirical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run power simulation using empirical bootstrap — run_power_sim_empirical","text":"","code":"run_power_sim_empirical(   raw_data,   n_per_group,   effect_size,   alpha = 0.05,   test = \"wilcoxon\",   n_sim = 1000 )"},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_empirical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run power simulation using empirical bootstrap — run_power_sim_empirical","text":"raw_data Numeric vector observed values n_per_group Number samples per group effect_size Fold change treatment alpha Significance level test Statistical test use n_sim Number simulations","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_empirical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run power simulation using empirical bootstrap — run_power_sim_empirical","text":"Power estimate (proportion significant results)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_fdr.html","id":null,"dir":"Reference","previous_headings":"","what":"Run FDR-aware power simulation for whole peptidome — run_power_sim_fdr","title":"Run FDR-aware power simulation for whole peptidome — run_power_sim_fdr","text":"Simulates entire peptidome experiment mix true nulls true alternatives, applies Benjamini-Hochberg correction compute FDR-adjusted power.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_fdr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run FDR-aware power simulation for whole peptidome — run_power_sim_fdr","text":"","code":"run_power_sim_fdr(   fits,   effect_size,   n_per_group,   prop_null = 0.9,   fdr_threshold = 0.05,   alpha = 0.05,   test = \"wilcoxon\",   n_sim = 1000 )"},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_fdr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run FDR-aware power simulation for whole peptidome — run_power_sim_fdr","text":"fits peppwr_fits object effect_size Fold change treatment n_per_group Number samples per group prop_null Proportion peptides true nulls (effect). Default 0.9 (90% unchanged). fdr_threshold FDR threshold calling discoveries. Default 0.05. alpha Nominal significance level (used simulation). Default 0.05. test Statistical test use. Default \"wilcoxon\". n_sim Number simulation iterations. Default 1000.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_fdr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run FDR-aware power simulation for whole peptidome — run_power_sim_fdr","text":"FDR-adjusted power estimate (proportion true alternatives detected)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_with_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Run power simulation with missingness — run_power_sim_with_missingness","title":"Run power simulation with missingness — run_power_sim_with_missingness","text":"Estimates power accounting realistic missing data patterns.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_with_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run power simulation with missingness — run_power_sim_with_missingness","text":"","code":"run_power_sim_with_missingness(   distribution,   params,   n_per_group,   effect_size,   na_rate = 0,   mnar_score = 0,   alpha = 0.05,   test = \"wilcoxon\",   n_sim = 1000 )"},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_with_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run power simulation with missingness — run_power_sim_with_missingness","text":"distribution Distribution name params List distribution parameters n_per_group Number samples per group effect_size Fold change treatment na_rate Proportion values NA mnar_score MNAR intensity (0 = MCAR) alpha Significance level test Statistical test use n_sim Number simulations","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/run_power_sim_with_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run power simulation with missingness — run_power_sim_with_missingness","text":"Power estimate (proportion significant results)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_empirical.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate experiment using empirical bootstrap — simulate_empirical","title":"Simulate experiment using empirical bootstrap — simulate_empirical","text":"Resamples observed data instead using parametric distributions. Useful distribution fitting fails non-parametric analysis.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_empirical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate experiment using empirical bootstrap — simulate_empirical","text":"","code":"simulate_empirical(raw_data, n_per_group, effect_size)"},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_empirical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate experiment using empirical bootstrap — simulate_empirical","text":"raw_data Numeric vector observed values n_per_group Number samples per group effect_size Fold change treatment (multiplicative effect)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_empirical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate experiment using empirical bootstrap — simulate_empirical","text":"List control treatment vectors","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_experiment.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate an experiment with control and treatment groups — simulate_experiment","title":"Simulate an experiment with control and treatment groups — simulate_experiment","text":"Simulate experiment control treatment groups","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_experiment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate an experiment with control and treatment groups — simulate_experiment","text":"","code":"simulate_experiment(distribution, params, n_per_group, effect_size)"},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_experiment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate an experiment with control and treatment groups — simulate_experiment","text":"distribution Distribution name (e.g., \"norm\", \"gamma\", \"lnorm\") params List distribution parameters n_per_group Number samples per group effect_size Fold change treatment (multiplicative effect)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_experiment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate an experiment with control and treatment groups — simulate_experiment","text":"List control treatment vectors","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_with_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate experiment with realistic missingness — simulate_with_missingness","title":"Simulate experiment with realistic missingness — simulate_with_missingness","text":"Generates control treatment samples distribution, introduces missing values according specified rate MNAR pattern.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_with_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate experiment with realistic missingness — simulate_with_missingness","text":"","code":"simulate_with_missingness(   distribution,   params,   n_per_group,   effect_size,   na_rate = 0,   mnar_score = 0 )"},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_with_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate experiment with realistic missingness — simulate_with_missingness","text":"distribution Distribution name (e.g., \"norm\", \"gamma\", \"lnorm\") params List distribution parameters n_per_group Number samples per group effect_size Fold change treatment (multiplicative effect) na_rate Proportion values make NA (0-1) mnar_score MNAR intensity: 0 = MCAR, positive = low values likely missing. Typical values: 0-3.","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/simulate_with_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate experiment with realistic missingness — simulate_with_missingness","text":"List control treatment vectors (may contain NAs)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for peppwr_fits — summary.peppwr_fits","title":"Summary method for peppwr_fits — summary.peppwr_fits","text":"Summary method peppwr_fits","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for peppwr_fits — summary.peppwr_fits","text":"","code":"# S3 method for class 'peppwr_fits' summary(object, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for peppwr_fits — summary.peppwr_fits","text":"object peppwr_fits object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for peppwr_fits — summary.peppwr_fits","text":"list summary statistics","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for peppwr_power — summary.peppwr_power","title":"Summary method for peppwr_power — summary.peppwr_power","text":"Summary method peppwr_power","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for peppwr_power — summary.peppwr_power","text":"","code":"# S3 method for class 'peppwr_power' summary(object, ...)"},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for peppwr_power — summary.peppwr_power","text":"object peppwr_power object ... Additional arguments (ignored)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/summary.peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for peppwr_power — summary.peppwr_power","text":"list summary statistics","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bayes_t.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayes factor t-test — test_bayes_t","title":"Bayes factor t-test — test_bayes_t","text":"Computes Bayes factor difference two groups","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bayes_t.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayes factor t-test — test_bayes_t","text":"","code":"test_bayes_t(control, treatment)"},{"path":"https://teammaclean.github.io/peppwR/reference/test_bayes_t.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayes factor t-test — test_bayes_t","text":"control Control group values treatment Treatment group values","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bayes_t.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayes factor t-test — test_bayes_t","text":"Bayes factor (BF10: evidence alternative null)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bootstrap_t.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap-t test — test_bootstrap_t","title":"Bootstrap-t test — test_bootstrap_t","text":"Performs bootstrap-t test comparing two groups","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bootstrap_t.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap-t test — test_bootstrap_t","text":"","code":"test_bootstrap_t(control, treatment, n_boot = 1000)"},{"path":"https://teammaclean.github.io/peppwR/reference/test_bootstrap_t.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap-t test — test_bootstrap_t","text":"control Control group values treatment Treatment group values n_boot Number bootstrap iterations (default 1000)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_bootstrap_t.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap-t test — test_bootstrap_t","text":"p-value test","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_rankprod.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank Products test — test_rankprod","title":"Rank Products test — test_rankprod","text":"Performs rank products test comparing two groups Simplified implementation two-group comparison","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_rankprod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank Products test — test_rankprod","text":"","code":"test_rankprod(control, treatment, n_perm = 1000)"},{"path":"https://teammaclean.github.io/peppwR/reference/test_rankprod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank Products test — test_rankprod","text":"control Control group values treatment Treatment group values n_perm Number permutations p-value estimation (default 1000)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_rankprod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rank Products test — test_rankprod","text":"p-value test","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_wilcoxon.html","id":null,"dir":"Reference","previous_headings":"","what":"Wilcoxon rank-sum test — test_wilcoxon","title":"Wilcoxon rank-sum test — test_wilcoxon","text":"Wilcoxon rank-sum test","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_wilcoxon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wilcoxon rank-sum test — test_wilcoxon","text":"","code":"test_wilcoxon(control, treatment)"},{"path":"https://teammaclean.github.io/peppwR/reference/test_wilcoxon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wilcoxon rank-sum test — test_wilcoxon","text":"control Control group values treatment Treatment group values","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/test_wilcoxon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wilcoxon rank-sum test — test_wilcoxon","text":"p-value test","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_fits.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate a peppwr_fits object — validate_peppwr_fits","title":"Validate a peppwr_fits object — validate_peppwr_fits","text":"Validate peppwr_fits object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_fits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate a peppwr_fits object — validate_peppwr_fits","text":"","code":"validate_peppwr_fits(x)"},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_fits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate a peppwr_fits object — validate_peppwr_fits","text":"x Object validate","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_fits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate a peppwr_fits object — validate_peppwr_fits","text":"validated object (invisibly)","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate a peppwr_power object — validate_peppwr_power","title":"Validate a peppwr_power object — validate_peppwr_power","text":"Validate peppwr_power object","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate a peppwr_power object — validate_peppwr_power","text":"","code":"validate_peppwr_power(x)"},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate a peppwr_power object — validate_peppwr_power","text":"x Object validate","code":""},{"path":"https://teammaclean.github.io/peppwR/reference/validate_peppwr_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate a peppwr_power object — validate_peppwr_power","text":"validated object (invisibly)","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"peppwr-010","dir":"Changelog","previous_headings":"","what":"peppwR 0.1.0","title":"peppwR 0.1.0","text":"Initial CRAN release.","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"core-features-0-1-0","dir":"Changelog","previous_headings":"","what":"Core Features","title":"peppwR 0.1.0","text":"fit_distributions() fits candidate distributions (gamma, lognormal, normal, inverse Gaussian, inverse gamma) peptide abundance data power_analysis() performs power analysis two modes: Aggregate mode: Specify distribution parameters directly Per-peptide mode: Use fitted distributions pilot data Three analysis questions supported via find parameter: find = \"sample_size\": N need target power? find = \"power\": ’s power given N? find = \"effect_size\": ’s minimum detectable effect?","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"statistical-tests-0-1-0","dir":"Changelog","previous_headings":"","what":"Statistical Tests","title":"peppwR 0.1.0","text":"Wilcoxon rank-sum test (test = \"wilcoxon\", default) Bootstrap-t test (test = \"bootstrap_t\") Bayes factor t-test (test = \"bayes_t\")","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"missing-data-handling-0-1-0","dir":"Changelog","previous_headings":"","what":"Missing Data Handling","title":"peppwR 0.1.0","text":"compute_missingness() calculates NA rates MNAR scores per peptide MNAR (Missing Random) detection low-abundance dropouts simulate_with_missingness() incorporates missing data patterns power simulations","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"fdr-aware-mode-0-1-0","dir":"Changelog","previous_headings":"","what":"FDR-Aware Mode","title":"peppwR 0.1.0","text":"apply_fdr = TRUE per-peptide mode simulates whole-peptidome experiments Benjamini-Hochberg correction Configurable prop_null expected proportion true nulls","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"diagnostic-plots-0-1-0","dir":"Changelog","previous_headings":"","what":"Diagnostic Plots","title":"peppwR 0.1.0","text":"plot_density_overlay(): Observed histogram fitted density curve plot_qq(): QQ plots goodness--fit assessment plot_power_heatmap(): N x effect size power lookup grid plot_power_vs_effect(): Power sensitivity fixed N plot_param_distribution(): Distribution fit quality across peptidome plot_missingness(): NA rate MNAR score distributions","code":""},{"path":"https://teammaclean.github.io/peppwR/news/index.html","id":"empirical-bootstrap-0-1-0","dir":"Changelog","previous_headings":"","what":"Empirical Bootstrap","title":"peppwR 0.1.0","text":"on_fit_failure = \"empirical\" option uses bootstrap resampling parametric fitting fails","code":""}]
